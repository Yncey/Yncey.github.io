<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yasir&#39;S Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-22T06:53:54.023Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yasir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刷新邻接页（Flush Neighbor Page）</title>
    <link href="http://example.com/2021/01/22/5.nnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%88%B7%E6%96%B0%E9%82%BB%E6%8E%A5%E9%A1%B5%EF%BC%88Flush%20Neighbor%20Page%EF%BC%89/"/>
    <id>http://example.com/2021/01/22/5.nnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%88%B7%E6%96%B0%E9%82%BB%E6%8E%A5%E9%A1%B5%EF%BC%88Flush%20Neighbor%20Page%EF%BC%89/</id>
    <published>2021-01-22T07:53:46.000Z</published>
    <updated>2021-01-22T06:53:54.023Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h2 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h2><p>InnoDB存储引擎还提供了Flush Neighbor Page(刷新邻接页)的特性。其工作原理为：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区(extent)的所有页，如果是脏页，那么一起进行刷新。<br>有两个问题：<br>1）是不是可能将不怎么脏的页进行了写入，而该页之后又会 很快变成脏页？<br>2）固态硬盘有着较高的IOPS，是否还需要这个特性？<br>所以，InnoDB1.2.x版本开始提供了参数innodb_flush_neighbors，用来控制是否启用该特性。对于传统机械硬盘建议启用该特性，而对于固态硬盘有着较高的IOPS性能的磁盘，则建议将该参数设置为0，即关闭该特性。</p><h2 id="启动、关闭和恢复"><a href="#启动、关闭和恢复" class="headerlink" title="启动、关闭和恢复"></a>启动、关闭和恢复</h2><p>InnoDB存储引擎是MySql数据库的存储引擎之一，因此InnoDB存储引擎的启动和关闭，或者说MySql数据库服务器的启动和关闭过程对InnoDB存储引擎的处理过程。<br>在关闭时，参数 innodb_fast_shutdown影响着表的InnoDB存储引擎的行为，该参数可以为0，1，2，默认值为1；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;innodb_fast_shutdown&#39;;  </span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| innodb_fast_shutdown | 1     |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>（1）为0时，表示在MySql数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数设置为0，然后再关闭数据库。<br>（2）1是参数 innodb_fast_shutdown的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。<br>（3）2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySql数据库启动时，会进行恢复操作。</p><p>当正常关闭MySql数据库时，下次的启动应该会非常正常。但是如果没有正常地关闭数据库，如用kill命令关闭数据库，在MySql数据库运行中重启了服务器，或者在关闭数据库时，将参数innodb_fast_shutdown设置为了2，下次MySql数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><p>参数innodb_force_recovery影响了整个InnoDB存储引擎恢复的状态。该参数默认值为0，表示当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySql数据库可能发生宕机（crash)，并把错误写入错误日志中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;innodb_force_recovery&#39;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_force_recovery | 0     |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>某些情况下，可能并不需要进行完整的恢复操作，因为用户自己知道怎么进行恢复。比如在对一个表进行alter table操作时发生了意外，数据库重启时会对InnoDB表进行回滚操作，对于一个大表来说这需要很长时间，可能是几个小时。这时用户可以自行进行恢复，如可以把表删除，从备份中重新导入数据到表，可能这些操作的速度要远远快于回滚操作。</p><p>参数innodb_force_recovery还可以设置为6个非零值：1-6，大的数字表示包含了前面所有小数字表示的影响。具体情况如下：<br>1：忽略检查到的corrupt页。<br>2：阻止Master Thread线程的运行，如Master Thread线程需要进行full purge，而这会导致crash。<br>3：不进行事务的回滚操作。<br>4：不进行插入缓冲的合并操作。<br>5：不查看撤销日志（Undo Log），InnoDB存储引擎会将未提交的事务视为已提交。<br>6：不进行前滚的操作。</p><p>参数innodb_force_recovery的值大于0时，可以对表进行select,creaete和drop操作，但是insert,update和delete这类DML操作是不允许的。</p><blockquote><p>参考链接：<a href="https://blog.csdn.net/linux_ever/article/details/62045117">https://blog.csdn.net/linux_ever/article/details/62045117</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入缓冲（Insert Buffer）&lt;/li&gt;
&lt;li&gt;两次写（Double Write）&lt;/li&gt;
&lt;li&gt;自适应哈希索引（Adaptive Hash Index）&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>DB死锁排查分析与思考</title>
    <link href="http://example.com/2021/01/20/DB%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>http://example.com/2021/01/20/DB%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2021-01-20T05:09:46.000Z</published>
    <updated>2021-01-20T06:59:50.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、出现死锁的当前场景"><a href="#一、出现死锁的当前场景" class="headerlink" title="一、出现死锁的当前场景"></a>一、出现死锁的当前场景</h2><p>在测试环境上做业务流程的联调验证自测，在跑自测用例时，突然发现在多线程并发情况下有数据未从业务表中删除完成，通过Spring Boot工程打印出的Log日志中可以看到出现了死锁问题。下面将先给大家还原下死锁的当前场景，然后逐步分析和使用正确方法排查死锁的原因。</p><h3 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;hw_band_width_bill_record&#96; (</span><br><span class="line"></span><br><span class="line">&#96;ID&#96; bigint(20) unsigned NOT NULLAUTO_INCREMENT COMMENT &#39;主键id,自增&#39;,</span><br><span class="line"></span><br><span class="line">&#96;CUSTOMER_ID&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;USER_ID&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;CLOUD_SER_TYPE_CODE&#96; varchar(50) NOT NULL COMMENT……,</span><br><span class="line"></span><br><span class="line">&#96;RES_TYPE_CODE&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;RES_SPEC_CODE&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;RES_INSTANCE_ID&#96; varchar(50) DEFAULT NULL COMMENT……,</span><br><span class="line"></span><br><span class="line">&#96;RES_ATTR_VALUES&#96; varchar(50) DEFAULT NULLCOMMENT ……,</span><br><span class="line"></span><br><span class="line">-- 限于篇幅问题这里省略该数据表的其他字段</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (&#96;ID&#96;),</span><br><span class="line"></span><br><span class="line">KEY&#96;custId_product_res_type_spec_index&#96;(&#96;CUSTOMER_ID&#96;,&#96;RES_TYPE_CODE&#96;,&#96;RES_SPEC_CODE&#96;,&#96;RES_ATTR_VALUES&#96;) USING BTREE)</span><br><span class="line"></span><br><span class="line">ENGINE&#x3D;InnoDBAUTO_INCREMENT&#x3D;54 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;……&#39;</span><br></pre></td></tr></table></figure><p>其中，<code>ID</code>为主键索引，<code>CUSTOMER_ID</code>,<code>RES_TYPE_CODE</code>,<code>RES_SPEC_CODE</code>,<code>RES_ATTR_VALUES</code>等字段组成了非唯一的普通BTREE索引。</p><h3 id="业务库的事务隔离级别"><a href="#业务库的事务隔离级别" class="headerlink" title="业务库的事务隔离级别"></a>业务库的事务隔离级别</h3><p>可以通过<code>SELECT @@tx_isolation</code>的SQL来查询当前数据库的事务隔离级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT @@tx_isolation;</span><br><span class="line"></span><br><span class="line">+-----------------+</span><br><span class="line">|@@tx_isolation|</span><br><span class="line">+-----------------+</span><br><span class="line">|REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"></span><br><span class="line">1row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="业务应用工程的Log日志"><a href="#业务应用工程的Log日志" class="headerlink" title="业务应用工程的Log日志"></a>业务应用工程的Log日志</h3><p>当业务应用工程出现异常或者报错时，绝大部分童鞋的第一反应肯定都是去工程对应的Log日志里面去排查定位问题。对应于该死锁问题Case的工程Log日志如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.DeadlockLoserDataAccessException:###Error updating database.Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException:Deadlock found when trying to get lock; try restarting transaction###The error may involveHwBandWidthBillRecordMapper.deleteResBwBillsByIdAndSpecValues-Inline</span><br><span class="line"></span><br><span class="line">The error occurred while setting parameters</span><br><span class="line"></span><br><span class="line">SQL: delete from hw_band_width_bill_recordwhere CUSTOMER_ID = ?and CLOUD_SER_TYPE_CODE = ?and RES_TYPE_CODE = ?and RES_SPEC_CODE = ?and RES_ATTR_VALUES = ?</span><br><span class="line"></span><br><span class="line">Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException:Deadlock found when trying to get lock; try restarting transaction; SQL []; Deadlock</span><br><span class="line"></span><br><span class="line">found when trying to get lock; try restarting transaction; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock;try restarting transaction (限于篇幅问题这里省略了部分日志)</span><br><span class="line">Caused by:com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlockfound when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>从以上打印的堆栈日志里面可以清楚的发现业务工程代码在多线程并发的环境下执行了Delete SQL语句后出现了死锁异常。不过，仅仅通过上述日志还不足以清楚地分析和查明出现死锁异常的根本原因，那怎么办？下面将通过MySQL的InnoDB的状态日志进行进一步的深入分析。</p><h3 id="MySQL数据库死锁日志信息"><a href="#MySQL数据库死锁日志信息" class="headerlink" title="MySQL数据库死锁日志信息"></a>MySQL数据库死锁日志信息</h3><p>可能很多做过开发的童鞋都没有自己登录过数据库服务器，排查过MySQL的InnoDB Status的状态日志信息来深入分析死锁问题。这里，我们可以先进入测试/线上环境数据库虚拟机的数据库安装bin目录下，通过“mysql-h localhost -P 3306 -u test -p”命令来连接登录。然后使用“SHOW ENGINE INNODB STATUS”命令查询数据库的最近一次死锁日志信息。这里需要注意的是，该命令只能查看到最近一条死锁日志信息，如果想看到多条历史死锁可以在MySQL中把死锁信息打印到错误日志里，开启如下变量即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_print_all_deadlocks&#x3D; 1；</span><br><span class="line">本Case中的死锁日志信息如下：</span><br><span class="line"></span><br><span class="line">\------------------------</span><br><span class="line">LATESTDETECTED DEADLOCK</span><br><span class="line">\------------------------</span><br><span class="line"></span><br><span class="line">2017-12-0519:46:52 7f6d3e588700</span><br><span class="line"></span><br><span class="line">(1) TRANSACTION: TRANSACTION10375675, ACTIVE 0 sec fetching rows mysqltables in use 1, locked 1 LOCKWAIT 4 lock struct(s), heap size 1184, 2 row lock(s), undo log entries 4</span><br><span class="line"></span><br><span class="line">MySQLthread id 550477, OS thread handle 0x7f6db6ab8700, query id 33896336 10.129.3.1test updating</span><br><span class="line"></span><br><span class="line">deletefrom hw_band_width_bill_record where CUSTOMER_ID &#x3D;&#39;0314e4814d014eaabf4ab09f7fa97fed&#39; and CLOUD_SER_TYPE_CODE &#x3D;&#39;hws.service.type.vpc&#39; and RES_TYPE_CODE &#x3D;&#39;hws.resource.type.bandwidth&#39; and RES_SPEC_CODE &#x3D; &#39;19_bgp&#39; and RES_ATTR_VALUES &#x3D;&#39;&#123;&quot;specSize&quot;:1&#125;&#39; </span><br><span class="line"></span><br><span class="line">(1) WAITING FOR THIS LOCK TO BE GRANTED: RECORDLOCKS space id 1369 page no 3 n bits 104 index &#96;PRIMARY&#96; of table&#96;res_hw_cloud_bill&#96;.&#96;hw_band_width_bill_record&#96; trx id 10375675 lock_mode Xlocks rec but not gap waiting</span><br><span class="line"></span><br><span class="line">(2) TRANSACTION:</span><br><span class="line"></span><br><span class="line">TRANSACTION10375676, ACTIVE 0 sec starting index read, thread declared inside InnoDB 5000 mysqltables in use 1, locked 1 4lock struct(s), heap size 1184, 3 row lock(s), undo log entries 5 MySQLthread id 550478, OS thread handle 0x7f6d3e588700, query id 33896338 10.129.3.1test updating </span><br><span class="line"></span><br><span class="line">deletefrom hw_band_width_bill_record where CUSTOMER_ID &#x3D; &#39;0314e4814d014eaabf4ab09f7fa97fed&#39; and CLOUD_SER_TYPE_CODE &#x3D;&#39;hws.service.type.vpc&#39; and RES_TYPE_CODE &#x3D;&#39;hws.resource.type.bandwidth&#39; and RES_SPEC_CODE &#x3D; &#39;19_bgp&#39; and RES_ATTR_VALUES &#x3D;&#39;&#123;&quot;specSize&quot;:6&#125;&#39;</span><br><span class="line"></span><br><span class="line">(2) HOLDS THE LOCK(S):</span><br><span class="line"></span><br><span class="line">RECORDLOCKS space id 1369 page no 3 n bits 104 index &#96;PRIMARY&#96; of table&#96;res_hw_cloud_bill&#96;.&#96;hw_band_width_bill_record&#96; trx id 10375676 lock_mode Xlocks rec but not gap</span><br><span class="line"></span><br><span class="line">(2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">RECORDLOCKS space id 1369 page no 3 n bits 104 index &#96;PRIMARY&#96; of table&#96;res_hw_cloud_bill&#96;.&#96;hw_band_width_bill_record&#96; trx id 10375676 lock_mode Xlocks rec but not gap waiting </span><br><span class="line"></span><br><span class="line">WE ROLL BACK TRANSACTION (1)</span><br><span class="line"></span><br><span class="line">\------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">\------------</span><br></pre></td></tr></table></figure><p>从上面打印的这段日志中，我们可以进行一定的初步分析。从这段日志里可以看到，<code>TRANSACTION (1)</code>和<code>TRANSACTION (2)</code>分别持有一定数量的行锁，然后又等待对方的锁，最后MySQL检测到Deadlock，然后选择回滚了<code>TRANSACTION (1)</code>：InnoDB目前处理死锁的方法是将持有最少行级排他锁的事务进行回滚。</p><h2 id="二、对于业务库死锁的深入分析"><a href="#二、对于业务库死锁的深入分析" class="headerlink" title="二、对于业务库死锁的深入分析"></a>二、对于业务库死锁的深入分析</h2><p>在进一步深入分析MySQL的死锁日志之前有必要先了解下MySQL数据库的MVCC机制、锁的概念和事务隔离级别。</p><h3 id="MySQL-InnoDB的MVCC机制与锁的模型概念"><a href="#MySQL-InnoDB的MVCC机制与锁的模型概念" class="headerlink" title="MySQL InnoDB的MVCC机制与锁的模型概念"></a>MySQL InnoDB的MVCC机制与锁的模型概念</h3><p>MySQL InnoDB存储引擎，实现了基于多版本的并发控制协议—MVCC (Multi-Version Concurrency Control)。InnoDB存储引擎MVCC机制的优点可以总结为，“读不加锁，读写不冲突”。这在读多写少的业务应用中，读写不冲突是非常重要的，极大的增加了系统的并发度和解决各种性能问题。在InnoDB中常见的几种锁模型如下：</p><p>（1）LOCK_ORDINARY[next_key_lock]，默认是LOCK_ORDINARY，即next-keylock，锁住行及其前面的间隙，其为行级记录锁和间隙锁的结合，用于解决幻读的问题。</p><p>（2）LOCK_GAP：间隙锁，锁住行以前的间隙，不锁住本行。</p><p>（3）LOCK_REC_NOT_GAP：行级锁，锁住行而不锁住任何间隙。</p><p>（4）LOCK_INSERT_INTENTION：插入意向锁，如果插入的记录在某个已经锁定的间隙内为这个锁。</p><p>因此在InnoDB中，读操作大致可以概括为两类：快照读(snapshot read)与当前读(current read)。快照读，读取的是记录的可见版本(有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>一般来说，简单的Select SQL语句都属于快照读，例如<code>select * from where……</code></p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>对于“insert/delete/update”等增删改的SQL语句，属于当前读，需要加锁。例如如下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure><h3 id="说说数据库的隔离级别"><a href="#说说数据库的隔离级别" class="headerlink" title="说说数据库的隔离级别"></a>说说数据库的隔离级别</h3><p>数据库的事务隔离级别<code>Isolation Level</code>，是数据库的一个关键特性。相信对数据库原理有所了解的朋友，一定都对4种隔离级别：<code>Read Uncommited</code>，<code>Read Committed</code>，<code>Repeatable Read</code>，<code>Serializable</code>有了比较深入的认识。这里就不再对这4种隔离级别的定义进行详细的阐述了，而是主要跟大家介绍下在MySQL InnoDB存储引擎中对于上述的“当前读”，在这四种不同的隔离级别情况下加锁情况有何区别？（一般“快照读”可以忽略，基本一样的）</p><h4 id="1-Read-Uncommited（未提交读）"><a href="#1-Read-Uncommited（未提交读）" class="headerlink" title="1. Read Uncommited（未提交读）"></a>1. Read Uncommited（未提交读）</h4><p>在该级别下，可以读取未提交记录。此隔离级别，一般不太会使用。</p><h4 id="2-Read-Committed（提交读）"><a href="#2-Read-Committed（提交读）" class="headerlink" title="2. Read Committed（提交读）"></a>2. Read Committed（提交读）</h4><p>在该级别下，针对“当前读”，RC隔离级别保证对读取到的记录加锁(记录锁)，而不会在记录之间加间隙锁，允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果，允许不可重复读。</p><h4 id="3-Repeatable-Read（可重复读）"><a href="#3-Repeatable-Read（可重复读）" class="headerlink" title="3. Repeatable Read（可重复读）"></a>3. Repeatable Read（可重复读）</h4><p>在该级别下，针对“当前读”，RR隔离级别保证对读取到的记录加锁(记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入(间隙锁，但是在唯一索引和非唯一索引条件下还是有一定区别的)，解决了不可重复读的问题，但可能存在幻读（幻读可以通过Next-Key锁解决）。</p><h4 id="4-Serializable（序列化）"><a href="#4-Serializable（序列化）" class="headerlink" title="4. Serializable（序列化）"></a>4. Serializable（序列化）</h4><p>在该级别下，InnoDB隐式将全部读操作视为“当前读”，并且要求事务序列化一个接一个执行。因此，并发度急剧下降，一般情况下也不太会使用该隔离级别。</p><h3 id="分析死锁日志信息与降低死锁的方法"><a href="#分析死锁日志信息与降低死锁的方法" class="headerlink" title="分析死锁日志信息与降低死锁的方法"></a>分析死锁日志信息与降低死锁的方法</h3><p>通过上文的初步分析和对MySQL InnoDB死锁的基本模型/DB事务隔离级别的介绍，现在再回过头来看下本Case中的死锁日志信息，应该就会有一些相对深刻的理解了。下面将进一步给大家做更深入的分析，在篇幅的最后给出自己总结的一些降低死锁发生频率的大致方法。</p><h4 id="1-死锁日志中信息提取"><a href="#1-死锁日志中信息提取" class="headerlink" title="1. 死锁日志中信息提取"></a>1. 死锁日志中信息提取</h4><p>TRX1:<code>10375675</code>(出发死锁权重回滚)</p><p>LOCK HOLD:没有提供该事务获取到的锁</p><p>LOCKWAIT:</p><table><thead><tr><th>表</th><th>索引</th><th>锁模式</th><th>记录</th></tr></thead><tbody><tr><td>hw_band_width_bill_record</td><td>PRIMARY</td><td>LOCKX|LOCK_REC_NOT_GAP</td><td>space id1369 page no 3 n bits 104</td></tr></tbody></table><p>锁的信息：该事务总共有2个行锁，持有1个行锁，另外一个1锁处于锁等待状态</p><p> 当前发生死锁的SQL语句：<code>delete from hw_band_width_bill_record where CUSTOMER_ID = &#39;0314e4814d014eaabf4ab09f7fa97fed&#39; andCLOUD_SER_TYPE_CODE = &#39;hws.service.type.vpc&#39; andRES_TYPE_CODE = &#39;hws.resource.type.bandwidth&#39; andRES_SPEC_CODE = &#39;19_bgp&#39; andRES_ATTR_VALUES = &#39;&#123;&quot;specSize&quot;:1&#125;&#39;</code></p><p>TRX2:<code>10375676</code></p><p>LOCK HOLD:该事务持有锁的大致信息（锁的模式为：LOCK X|LOCK_REC_NOT_GAP）LOCKWAIT:</p><p>LOCKWAIT:</p><table><thead><tr><th>表</th><th>索引</th><th>锁模式</th><th>记录</th></tr></thead><tbody><tr><td>hw_band_width_bill_record</td><td>PRIMARY</td><td>LOCKX|LOCK_REC_NOT_GAP</td><td>space id 1369 page no 3 n bits 104</td></tr></tbody></table><p>锁的信息：该事务总共有3个行锁，持有2个行锁，另外一个行锁处于锁等待状态</p><p> 当前发生死锁的SQL语句：<code>delete from hw_band_width_bill_record where CUSTOMER_ID =&#39;0314e4814d014eaabf4ab09f7fa97fed&#39; and CLOUD_SER_TYPE_CODE =&#39;hws.service.type.vpc&#39; and RES_TYPE_CODE =&#39;hws.resource.type.bandwidth&#39; and RES_SPEC_CODE = &#39;19_bgp&#39; and RES_ATTR_VALUES =&#39;&#123;&quot;specSize&quot;:6&#125;&#39;</code></p><p>从以上MySQL InnoDB死锁日志的提取信息中即可看到，事务1和事务2有分别在等待对方的锁释放，形成了一个环，因此产生了数据库的死锁。</p><h4 id="2-InnoDB行锁难道锁的不只是一行？"><a href="#2-InnoDB行锁难道锁的不只是一行？" class="headerlink" title="2. InnoDB行锁难道锁的不只是一行？"></a>2. InnoDB行锁难道锁的不只是一行？</h4><p>由于本Case中所建的数据库表是用InnoDB引擎的，InnoDB支持行锁和表锁。而InnoDB行锁的原理是通过给索引上的索引项加锁来实现的。而这一点MySQL与Oracle数据库有差别，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点表示：只有通过索引条件检索数据，InnoDB才使用行级锁。如果未走到索引上，InnoDB将使用表锁，会把执行SQL语句中所有扫描过的行都锁定（这里需要注意的是，如果在<code>RR</code>事务隔离级别下且索引为非唯一索引，不仅会对数据表中的每一行加上<code>LOCK_REC_NOT_GAP</code>的行锁，而且还会两数据行的间隙加上<code>LOCK_GAP</code>间隙锁）。在实际的业务应用开发中，要特别注意InnoDB行锁的这一特性，否则可能导致大量的锁冲突，从而影响系统并发性能。由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁。所以虽然是访问不同行的记录，但是如果是使用相同的索引键，也同样会出现锁冲突的。当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。</p><p>下面可以先看下在该Case中，我们业务表索引的情况。如下图可以看到执行的Delete SQL语句走的是范围扫描，未正确走到建立的索引上（对于如何正确建立索引的问题可以看下之间写的《大型分布式业务平台数据库常用优化方法（上）》篇，该篇幅介绍索引的原理和如何正确使用索引）</p><p><img src="https://i.loli.net/2021/01/20/JVRcB5dMKy9aozw.png" alt="img"></p><p>了解MySQL InnoDB的加锁原理和如何正确加索引后，只要调整下创建索引的字段（即为创建索引使用上图中的where条件的5个字段，然后执行Delete SQL语句即可实现覆盖索引，MySQL InnoDB加的锁为对应的行锁和行之间的GAP锁）即可让咱们的Delete SQL语句精确走到索引以缓解死锁的问题。实际上，我再更新索引后，死锁问题也确实得到了解决。</p><h4 id="3-MySQL-InnoDB锁与索引-隔离级别的关系"><a href="#3-MySQL-InnoDB锁与索引-隔离级别的关系" class="headerlink" title="3. MySQL InnoDB锁与索引/隔离级别的关系"></a>3. MySQL InnoDB锁与索引/隔离级别的关系</h4><p>从上述篇幅中可以得到的结论是，“InnoDB行锁的原理是通过给索引上的索引项加锁来实现”，我们知道InnoDB对于主键使用了聚簇索引，这是一种数据存储方式，表数据是和主键一起存储，主键索引的叶结点存储行数据。对于普通索引，其叶子节点存储的是主键值。相信仔细阅读了上面篇幅的同学，对执行未正确落到索引的“当前读”SQL，InnoDB引擎都会加表锁的这一行为比较熟悉，因此这里不再赘述业务表无索引这一情况。这一节将通过2个小例子，来进一步阐述大家，在InnoDB引擎中可能不太会被关注到的锁与索引/隔离级别的两种关系。</p><h5 id="3-1-非唯一索引-RC隔离级别"><a href="#3-1-非唯一索引-RC隔离级别" class="headerlink" title="3.1 非唯一索引+RC隔离级别"></a>3.1 非唯一索引+<code>RC</code>隔离级别</h5><p>在下面第一个的实例中，假设数据库的隔离级别为Read Committed隔离级别，表为table1(表字段由<code>id</code>、<code>token</code>和<code>message</code>组成，其中id字段为自增的主键，在token字段上建了一个非唯一索引)，如果此时执行<code>delete from table1 where token = ‘asd’</code>，那么加锁的情况会怎么样呢？先来看下面这幅图：</p><p><img src="https://i.loli.net/2021/01/20/q4DwFd8jQ2AIkaW.png" alt="img"></p><p>可以看到，由于token列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p><h5 id="3-2-非唯一索引-RR隔离级别"><a href="#3-2-非唯一索引-RR隔离级别" class="headerlink" title="3.2 非唯一索引+RR隔离级别"></a>3.2 非唯一索引+<code>RR</code>隔离级别</h5><p>在接下来的第二个实例中，假设将原来数据库的隔离级别为由上面的RC级别改为，Repeatable Read隔离级别，表table1字段和索引均不变(表字段由<code>id</code>、<code>token</code>和<code>message</code>组成，其中id字段为自增的主键，在token字段上建了一个非唯一索引)，如果此时仍然执行<code>delete from table1 where token = ‘asd’</code>，那么最后的加锁行为会怎么样的呢？可以先来看下下面这幅图：</p><p><img src="https://i.loli.net/2021/01/20/ujm1E68Qdg3nphb.png" alt="img"></p><p>在上图中，相对于前面的<code>Read Committed</code>级别下token非唯一索引条件]看似相同，其实却有很大的区别。主要区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来不是加在记录上的，是加载两条记录之间的位置。这里的GAP锁，就是在RR隔离级别下，相对于RC隔离级别，不会出现的不可重复读的关键。确实，这个GAP锁，锁住的位置，也不是记录本身，而是两条记录之间的间隙。所谓不可重复读，就是同一个事务，连续做两次当前读 (例如：<code>select * from table1 where token = ‘asd’ for update;</code>，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 。然而在RR级别下，并不能解决幻影读的问题。在标准的数据库事务隔离级别中，幻读是由更高的隔离级别 SERIALIZABLE 解决的，但是它也可以通过上文提到过的MySQL的 <code>Next-Key</code> 锁解决。</p><p>因此，在RR隔离级别下，token列上有一个非唯一索引，对应SQL：<code>delete from table1 where token = ‘asd’;</code>首先，通过token索引定位到第一条满足查询条件的记录，先在记录上加X锁，在数据行之间的间隙加上GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录为止，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p><h4 id="4-如何降低发生MySQL-InnoDB死锁频率"><a href="#4-如何降低发生MySQL-InnoDB死锁频率" class="headerlink" title="4. 如何降低发生MySQL InnoDB死锁频率"></a>4. 如何降低发生MySQL InnoDB死锁频率</h4><p>DB死锁在行锁及事务场景下很难完全消除，但可以通过表设计和SQL调整等措施减少锁冲突和死锁，下面列举了一些降低死锁发生的主要方法：</p><p>a. 尽量使用较低的隔离级别，比如如果发生了GAP间隙锁，可以尝试把DB的事务隔离级别调整成为RC(read committed)级别来避免。当然在RC的隔离级别下需要考虑业务是否能够接受“不可重复读”的问题；</p><p>b. 在业务上线之前精心设计并核查下业务表上创建的索引。业务工程DAO层中的SQL语句尽量使用索引访问数据（如果对于自己的业务SQL不确定，可以使用<code>Explain</code>关键字来查看对应的执行计划是怎么样的），使加锁更精确，从而减少锁冲突的机会；</p><p>c. 选择合理的事务大小，小事务发生锁冲突的概率一般也更小；对于使用Spring Transaction注解的同学，也可以考虑使用其编程式声明Spring事务模板的方式来将类或者方法级别的事务划分给代码块更小级别的事务。</p><p>d. 在不同线程中去访问一组DB的数据表时，尽量约定以相同的顺序进行访问；对于同一个单表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</p><p>e. 对于一些特定的业务流程，可以使用提升DB锁粒度的方式（在业务允许的情况下降低一定的并发度），比如表锁，来减少出现死锁的可能。</p><p>本文从一次测试环境的DB死锁Case出发，首先还原了发生死锁的当前场景，给出包括数据表结构、业务库的事务隔离级别、工程日志和数据库死锁日志在内的信息；然后从这些信息中逐步分析，先介绍了InnoDB的锁模型和MVCC机制，以及在四种不同隔离级别下当前读的不同区别；最后根据从死锁日志出提取的信息出发分析了死锁的根本原因，并给出降低死锁产生几率的一般方法。限于笔者的才疏学浅，对MySQL InnoDB的死锁可能还有理解不到位的地方，如有阐述不合理之处还望留言一起探讨。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、出现死锁的当前场景&quot;&gt;&lt;a href=&quot;#一、出现死锁的当前场景&quot; class=&quot;headerlink&quot; title=&quot;一、出现死锁的当前场景&quot;&gt;&lt;/a&gt;一、出现死锁的当前场景&lt;/h2&gt;&lt;p&gt;在测试环境上做业务流程的联调验证自测，在跑自测用例时，突然发现在多线</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB引擎之-异步IO（Async IO）</title>
    <link href="http://example.com/2021/01/19/4.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%BC%82%E6%AD%A5IO%EF%BC%88Async%20IO%EF%BC%89/"/>
    <id>http://example.com/2021/01/19/4.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%BC%82%E6%AD%A5IO%EF%BC%88Async%20IO%EF%BC%89/</id>
    <published>2021-01-19T07:53:46.000Z</published>
    <updated>2021-01-19T08:43:52.194Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h2 id="关于AIO与SIO"><a href="#关于AIO与SIO" class="headerlink" title="关于AIO与SIO"></a>关于AIO与SIO</h2><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO的方式来处理磁盘操作。</p><ol><li>同步IO：我们常用的read/write函数（Linux上）就是这类IO，特点是，在函数执行的时候，调用者会等待函数执行完成，而且没有消息通知机制，因为函数返回了，就表示操作完成了，后续直接检查返回值就可知道操作是否成功。这类IO操作，编程比较简单，在同一个线程中就能完成所有操作，但是需要调用者等待，在数据库系统中，比较适合急需某些数据的时候调用，例如WAL中日志必须在返回客户端前落盘，则进行一次同步IO操作。</li><li>异步IO：在数据库中，后台刷数据块的IO线程，基本都使用了异步IO。数据库前台线程只需要把刷块请求提交到异步IO的队列中即可返回做其他事情，而后台线程IO线程，则定期检查这些提交的请求是否已经完成，如果完成再做一些后续处理工作。同时异步IO由于常常是一批一批的请求提交，如果不同请求访问同一个文件且偏移量连续，则可以合并成一个IO请求。例如，第一个请求读取文件1，偏移量100开始的200字节数据，第二个请求读取文件1，偏移量300开始的100字节数据，则这两个请求可以合并为读取文件1，偏移量100开始的300字节数据。数据预读中的逻辑预读也常常使用异步IO技术。</li></ol><h2 id="Innodb-使用异步IO的场景"><a href="#Innodb-使用异步IO的场景" class="headerlink" title="Innodb 使用异步IO的场景"></a>Innodb 使用异步IO的场景</h2><p>  总的来说innodb 只会对数据文件采用异步IO，为了保存日志是真正被写入到磁盘，innodb不会对日志文件启用异步IO;innodb只会对数据文件的read-ahead ,write 这两个操作启用异步IO</p><h2 id="异步IO在mysql中解决了什么问题"><a href="#异步IO在mysql中解决了什么问题" class="headerlink" title="异步IO在mysql中解决了什么问题"></a>异步IO在mysql中解决了什么问题</h2><p>  在没有IO这个功能之前，innodb对数据的读写请求先放入任务队列，后台read-thread ，write-thread从任务队列中拿出任务并执行读写操作；后台读写线程的个数可以通过show engine innodb status 语句来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">376 OS file reads, 54 OS file writes, 7 OS fsyncs</span><br><span class="line">41.77 reads&#x2F;s, 21886 avg bytes&#x2F;read, 6.00 writes&#x2F;s, 0.78 fsyncs&#x2F;s</span><br></pre></td></tr></table></figure><p>  由上面的内容可以看出默认情况下innodb会有4个read-thread 和4个write-thread ，问题就出现在这里，如果业务繁重，读写任务会非常的多，而innodb只有八个读写线程，这样的话队列中的其它读写请求就没能得到及时的响应。</p><p>  引入异步IO之后，读写请求不再像之前那样先放入队列，等着后台的读写线程去执行任务；而是查询线程直接发起异步请求，这样一来冲破了读写线程个数的硬性限制，二来由于异步IO是否阻塞的这也进一步提高了性能。</p><h2 id="怎么启用mysql异步IO"><a href="#怎么启用mysql异步IO" class="headerlink" title="怎么启用mysql异步IO"></a>怎么启用mysql异步IO</h2><p>首先OS要有异步io，且开启，然后mysqld要链接，要不然OS异步io没有开启，数据库的异步io也起不来。（this variable applies to Linux systems only, and cannot be changed while the server is running.）</p><ol><li>文件系统层面需要打开这个功能：<br>一般都是默认开启的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldconfig -v|grep libaio</span><br><span class="line">libaio.so.1.0.0 -&gt; libaio.so.1.0.0</span><br><span class="line">libaio.so.1 -&gt; libaio.so.1.0.1</span><br></pre></td></tr></table></figure><ol start="2"><li>AIO是数据库层面的一个特性需要打开：<br>默认是开启，但是阿里云默认是关闭的，开启的native aio性能提升，可以提高到75%。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show variables like &#39;innodb_use_native_aio&#39;;</span><br><span class="line">+-------------------------+-----------------+</span><br><span class="line">| Variable_name           | Value           |</span><br><span class="line">+-------------------------+-----------------+</span><br><span class="line">| innodb_use_native_aio   | OFF             |</span><br><span class="line">+-------------------------+-----------------+</span><br></pre></td></tr></table></figure><h2 id="异步IO的优缺点"><a href="#异步IO的优缺点" class="headerlink" title="异步IO的优缺点"></a>异步IO的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>不用等待直接响应上一个用户的请求；</li><li>多次的请求在一起排序，请求的数据页是在一起的，一次读出来，减少多次读。（数据库的读写请求队列放在文件系统中单独分配的一块小内存结构里，非文件系统的缓存）<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li></ol><p>异步IO对于我们来说是不可控的，所以说在启用异步IO的情况下相当于是我们把IO的控制权交出去了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入缓冲（Insert Buffer）&lt;/li&gt;
&lt;li&gt;两次写（Double Write）&lt;/li&gt;
&lt;li&gt;自适应哈希索引（Adaptive Hash Index）&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>oh my zsh安装配置(国内可用)</title>
    <link href="http://example.com/2020/12/11/oh%20my%20zsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE(%E5%9B%BD%E5%86%85%E5%8F%AF%E7%94%A8)/"/>
    <id>http://example.com/2020/12/11/oh%20my%20zsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE(%E5%9B%BD%E5%86%85%E5%8F%AF%E7%94%A8)/</id>
    <published>2020-12-11T03:09:46.000Z</published>
    <updated>2020-12-11T06:14:23.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="oh-my-zsh安装配置-国内可用"><a href="#oh-my-zsh安装配置-国内可用" class="headerlink" title="oh my zsh安装配置(国内可用)"></a>oh my zsh安装配置(国内可用)</h2><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><blockquote><p>dnf 改为系统中软件下载工具命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install zsh</span><br></pre></td></tr></table></figure><h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh my zsh"></a>安装oh my zsh</h3><h4 id="克隆这个项目到本地-前提是你得有装git"><a href="#克隆这个项目到本地-前提是你得有装git" class="headerlink" title="克隆这个项目到本地(前提是你得有装git)"></a>克隆这个项目到本地(前提是你得有装git)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure><h4 id="创建一个zsh的配置文件"><a href="#创建一个zsh的配置文件" class="headerlink" title="创建一个zsh的配置文件"></a>创建一个zsh的配置文件</h4><p>注意:如果你已经有一个~/.zshrc文件的话，建议你先做备份。使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.zshrc ~/.zshrc.orig</span><br></pre></td></tr></table></figure><p>然后开始创建zsh的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="设置zsh为你的默认的shell"><a href="#设置zsh为你的默认的shell" class="headerlink" title="设置zsh为你的默认的shell"></a>设置zsh为你的默认的shell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h4 id="重启并开始使用你的zsh-打开一个新的终端窗口便可…"><a href="#重启并开始使用你的zsh-打开一个新的终端窗口便可…" class="headerlink" title="重启并开始使用你的zsh (打开一个新的终端窗口便可…)"></a>重启并开始使用你的zsh (打开一个新的终端窗口便可…)</h4><h3 id="oh-my-zsh皮肤"><a href="#oh-my-zsh皮肤" class="headerlink" title="oh-my-zsh皮肤"></a>oh-my-zsh皮肤</h3><p><a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><h3 id="自动补全插件"><a href="#自动补全插件" class="headerlink" title="自动补全插件"></a>自动补全插件</h3><p>下载 incr 自动补全插件 <a href="http://mimosa-pudica.net/src/incr-0.2.zsh">http://mimosa-pudica.net/src/incr-0.2.zsh</a><br> 将插件放在 oh-my-zsh 自定义插件目录中</p><p><img src="https://i.loli.net/2020/12/10/batfNkCw2xHdW6q.png" alt="img"></p><p>打开 oh-my-zsh 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/10/RZgrAUXdN4HJwam.png" alt="img"></p><p>在 <code>plugins</code> 中添加 <code>incr</code><br> 在配置文件结束添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/custom/plugins/incr/incr*.zsh</span><br></pre></td></tr></table></figure><p>更新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;oh-my-zsh安装配置-国内可用&quot;&gt;&lt;a href=&quot;#oh-my-zsh安装配置-国内可用&quot; class=&quot;headerlink&quot; title=&quot;oh my zsh安装配置(国内可用)&quot;&gt;&lt;/a&gt;oh my zsh安装配置(国内可用)&lt;/h2&gt;&lt;h3 id=</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu保存git用户名和密码</title>
    <link href="http://example.com/2020/12/11/Git%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/"/>
    <id>http://example.com/2020/12/11/Git%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-11T03:09:46.000Z</published>
    <updated>2020-12-11T05:50:11.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何在Ubuntu下解决Git保存用户名和密码呢？</p></blockquote><h3 id="打开Git-配置文件-该文件中保存着所有的配置信息"><a href="#打开Git-配置文件-该文件中保存着所有的配置信息" class="headerlink" title="打开Git 配置文件,该文件中保存着所有的配置信息"></a>打开Git 配置文件,该文件中保存着所有的配置信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure><h3 id="修改配置文件，添加下面这一行。"><a href="#修改配置文件，添加下面这一行。" class="headerlink" title="修改配置文件，添加下面这一行。"></a>修改配置文件，添加下面这一行。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">helper = store</span><br></pre></td></tr></table></figure><h4 id="记住密码"><a href="#记住密码" class="headerlink" title="记住密码"></a>记住密码</h4><p>helper = store #用来保存密码,提交一次会自动记住 </p><h4 id="密码保存一个小时"><a href="#密码保存一个小时" class="headerlink" title="密码保存一个小时"></a>密码保存一个小时</h4><p>helper = cache – timeout 3600 # 密码只保存一个小时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如何在Ubuntu下解决Git保存用户名和密码呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;打开Git-配置文件-该文件中保存着所有的配置信息&quot;&gt;&lt;a href=&quot;#打开Git-配置文件-该文件中保存着所有的配置信息&quot; class=&quot;h</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu添加开机启动</title>
    <link href="http://example.com/2020/12/11/Ubuntu%20%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2020/12/11/Ubuntu%20%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</id>
    <published>2020-12-11T03:09:46.000Z</published>
    <updated>2020-12-11T05:49:36.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu添加开机启动"><a href="#Ubuntu添加开机启动" class="headerlink" title="Ubuntu添加开机启动"></a>Ubuntu添加开机启动</h2><blockquote><p>以Shadowsocks为例添加软件开机启动项</p></blockquote><ol><li><p>运行terminal</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-session-properties</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/11/HzTSx1ymZqeGRwl.png" alt="image-20201211134227760"></p></li><li><p>查找软件位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis ss-qt</span><br></pre></td></tr></table></figure></li><li><p>添加 /usr/bin/ss-qt5  就能开机启动你的Shadowsocks-qt5  如果其他程序的话  你也可以在 /usr/bin/  目录下面找到，然后使用上面的命令添加就好了</p></li></ol><p><img src="https://i.loli.net/2020/12/11/3I8vlbyqHBitQxp.png" alt="image-20201211134404269"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ubuntu添加开机启动&quot;&gt;&lt;a href=&quot;#Ubuntu添加开机启动&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu添加开机启动&quot;&gt;&lt;/a&gt;Ubuntu添加开机启动&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以Shadowsocks为例添加软</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 添加软件快捷启动方式</title>
    <link href="http://example.com/2020/12/11/Linux%20%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2020/12/11/Linux%20%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2020-12-11T03:09:46.000Z</published>
    <updated>2020-12-11T05:49:21.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>拿linux下的IntelliJ IDEA举个例子，其安装以后，启动方式为软件bin目录下的一个sh文件，这时候每次打开需要从文件管理器查找那个sh文件并执行，十分麻烦，为什么不能像其他软件一样有一个在菜单中的应用图片呢？</p></blockquote><p>下面我们来为其创建一个链接。</p><h3 id="跳转到-usr-share-applications"><a href="#跳转到-usr-share-applications" class="headerlink" title="跳转到/usr/share/applications"></a>跳转到/usr/share/applications</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/applications</span><br></pre></td></tr></table></figure><h3 id="编辑这个文件"><a href="#编辑这个文件" class="headerlink" title="编辑这个文件"></a>编辑这个文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit IntelliJ-IDEA.desktop</span><br></pre></td></tr></table></figure><h3 id="添加以下内容"><a href="#添加以下内容" class="headerlink" title="添加以下内容"></a>添加以下内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=IntelliJ IDEA</span><br><span class="line">Icon=/usr/local/idea-IU-203.5981.155/bin/idea.png</span><br><span class="line">Exec=sh /usr/local/idea-IU-203.5981.155/bin/idea.sh</span><br><span class="line">MimeType=application/x-py;</span><br><span class="line">Name[en_US]=IntelliJ IDEA</span><br></pre></td></tr></table></figure><p>注意Icon和Exec的路径要和软件中sh文件和图标文件对应</p><p>4）此时在软件菜单中已经能够看到启动图标了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;拿linux下的IntelliJ IDEA举个例子，其安装以后，启动方式为软件bin目录下的一个sh文件，这时候每次打开需要从文件管理器查找那个sh文件并执行，十分麻烦，为什么不能像其他软件一样有一个在菜单中的应用图片呢？&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB引擎之-自适应哈希索引（Adaptive Hash Index）</title>
    <link href="http://example.com/2020/12/07/3.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%EF%BC%88Adaptive%20Hash%20Index%EF%BC%89/"/>
    <id>http://example.com/2020/12/07/3.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%EF%BC%88Adaptive%20Hash%20Index%EF%BC%89/</id>
    <published>2020-12-07T01:53:46.000Z</published>
    <updated>2020-12-09T06:19:24.351Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li><p>插入缓冲（Insert Buffer）</p></li><li><p>两次写（Double Write）</p></li><li><p>自适应哈希索引（Adaptive Hash Index）</p></li><li><p>异步IO（Async IO）</p></li><li><p>刷新邻接页（Flush Neighbor Page）</p></li></ul><h2 id="自适应哈希索引（Adaptive-Hash-Index）定义"><a href="#自适应哈希索引（Adaptive-Hash-Index）定义" class="headerlink" title="自适应哈希索引（Adaptive Hash Index）定义"></a>自适应哈希索引（Adaptive Hash Index）定义</h2><p>  InnoDB本身不支持哈希索引，所有索引检索都走B树，Adaptive Hash index可以认为是“索引的索引”</p><p>  （Btree上的”索引”）。当对某个页面访问次数满足一定条件会将页面地址存于Hash表，下次查询可以非常快速的找到页面不需要Btree去查。</p><p>  （哈希索引：哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。）</p><p>  AHI的目的是根据用户提供的查询条件加速定位到叶子节点，如果有固定的查询pattern，都可以通过AHI受益，特别是Btree深度比较大的时候。</p><p>自适应哈希索引 （AHI） 是 InnoDB 中最不为人所知的功能之一。从理论上讲，它自主确定何时使用快速哈希查找表补充基于 InnoDB B 树的索引，然后在用户不提示的情况下自动生成它们。</p><p>由于 AHI 工作 “像魔术一样”， 它几乎没有可用的配置。在早期版本中，没有任何可用的配置选项。添加了较新版本<code>innodb_adaptive_hash_index</code> 如果需要，请禁用 AHI（将其设置为”0”或”OFF”）。MySQL 5.7 增加了通过启用 AHI 对 AHI 进行分区的能力<code>innodb_adaptive_hash_index_parts</code>.（5.5以后 （FYI）功能存在于 Percona 服务器中，<code>innodb_adaptive_hash_index_partitions</code>）。</p><p>要了解 AHI 对性能的影响，我们可以把它理解为缓存。如果 AHI发生 “Hit” ，则会有更好的查找性能;如果是 AHI “Miss”， 那么性能会稍微差一点 （因为检查哈希表的匹配速度很快， 但不是免费的） 。</p><p>不过，这并不是唯一的问题。除了查找成本外，还有 AHI 维护成本。我们可以将维护成本（从 AHI 中添加和删除的行）与成功的查找进行比较。高比率意味着以低成本加速了大量查找。低比率意味着相反：我们可能付出太多的维护成本，但收效甚微。</p><p>最后，添加AHI会有额外的成本。如果工作负载包括查找大量索引或表，则可以通过设置<code>innodb_adaptive_hash_index_parts</code> 。但是，如果存在热索引，AHI 可能会成为高并发的瓶颈，可能需要禁用。</p><p>要确定 AHI 是否可能帮助我的工作负载，我们应该验证 AHI 命中和成功查找到维护操作的比率是否尽可能高。</p><p>我们看一些简单工作负载的情况。使用主键的基本 Sysbench 查找 - 尽可能简单的工作负载。我们会发现，即使在这种情况下，我们也会发现一些行为。</p><p>使用 MySQL 5.7.11 与 16GB 缓冲池。系统台的基本命令行是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --test=/usr/share/doc/sysbench/tests/db/select.lua   --report-interval=1 --oltp-table-size=1 --max-time=0 --oltp-read-only=off --max-requests=0 --num-threads=1 --rand-type=uniform --db-driver=mysql --mysql-password=password --mysql-db=test_innodb  run</span><br></pre></td></tr></table></figure><p><strong>查找一行</strong></p><p><code>oltp-table-size=1</code> ;测试 AHI 基本的情况下,有100%的命中率，没有HI维护操作。</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size1.png"><img src="https://i.loli.net/2020/12/07/6Wl3fBSvVKGETDR.png" alt="oltp table size=1"></a></p><p><strong>表中的 10000 行</strong></p><p>OLTP 表设置更改为<code>oltp-table-size=10000</code>：</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size10k.png"><img src="https://i.loli.net/2020/12/07/6p5gyF9LafDwTGM.png" alt="oltp table size=10k"></a></p><p><img src="https://i.loli.net/2020/12/07/3KLupnrhBHRJykj.png" alt="oltp table size=10k-2"></p><p>同样，几乎看不到开销。有一个罕见的事件，16行左右被添加到AHI（可能是由于AHI哈希冲突）。它几乎是完美的。</p><p><strong>表中的 10M 行</strong></p><p>将设置更改为<code>oltp-table-size=10000000</code>，现在有更多的数据（但仍比缓冲池大小少得多）：</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size10m.png"><img src="https://i.loli.net/2020/12/07/x4Z8IcfX3hnHeAk.png" alt="oltp table size=10m"></a></p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size10m-2.png"><img src="https://i.loli.net/2020/12/07/fa2ViFYKJRAjGQt.png" alt="oltp table size=10m-2"></a></p><p>这种情况下，有一个热身期，接近100%的命中率 - 没有完全达到100%（即使在更长的运行后）。在这种情况下，维护操作一直都在运行没有停止的迹象。 对于 1000 万行， 哈希冲突的可能性更高 — 导致更多的 AHI 重建。</p><p><strong>表中 500M 行，均匀分布</strong></p><p>现在，让我们将 OLTP 表大小设置为如下：<code>oltp-table-size=500000000</code>.这会导致数据大小超出 Innodb 缓冲池大小。</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m.png"><img src="https://i.loli.net/2020/12/07/yglezphXQHOPw1J.png" alt="oltp table size=500m"></a></p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-2.png"><img src="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-2.png" alt="oltp table size=500m-2"></a></p><p>这时我们看到很多缓冲池缺失，导致非常差的 AHI 命中率（永远不会达到 1%）。还可以看到从 AHI 添加或者移除数万行的较大开销。在这种情况下，AHI 不会添加任何值</p><p><strong>500M 行，帕雷托分布</strong></p><p>最后，让我们使用设置<code>oltp-table-size=500000000</code>，添加<code>--rand-type=pareto</code>设置启用了倾斜分布，这是许多实际数据访问模式的一个更典型的场景。</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-Pareto.png"><img src="https://i.loli.net/2020/12/07/IqAZ3yfsY5uEBVW.png" alt="oltp table size=500m-Pareto"></a></p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-Pareto-2.png"><img src="https://i.loli.net/2020/12/07/rmqYVDuGoQbnEM3.png" alt="oltp table size=500m-Pareto-2"></a></p><p>在这种情况下，我们看到 AHI 命中率逐渐提高，并接近 50%。AHI 维护开销正在下降，但从未达到任何表明它值得的东西。</p><blockquote><p>从上面配置中可以看到，InnoDB中的自适应哈希索引并不总是有效提高性能的！有些情况下，AHI 确实有帮助，有些情况下，AHI 添加了大量数据结构维护开销。在这些情况下，最好禁用 AHI。</p><p>如官网所说：由于很难预先预测<code>adaptive hash index</code>功能是否适合特定系统和工作负载，因此请考虑在启用和禁用时运行基准测试。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;插入缓冲（Insert Buffer）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两次写（Double Write）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自适应哈希索引（Adaptive </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 客户端推荐</title>
    <link href="http://example.com/2020/12/03/Redis%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A8%E8%8D%90/"/>
    <id>http://example.com/2020/12/03/Redis%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A8%E8%8D%90/</id>
    <published>2020-12-03T03:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.351Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发过程中，项目常常都会使用Redis来做缓存或者Session服务器，为了更直观方便，开发者常常会使用一些可视化工具，如 Redis Desktop Manager、Redis Clent等，但界面UI做得不尽人意，作为当今时代，对软件的UI还是有所期待的，今天给大家分享一款，高颜值、功能强大的Redis客户端工具</p><h2 id="Another-Redis-Desktop-Manager"><a href="#Another-Redis-Desktop-Manager" class="headerlink" title="Another Redis Desktop Manager"></a>Another Redis Desktop Manager</h2><p>gitee开源地址：<a href="https://gitee.com/qishibo/AnotherRedisDesktopManager">AnotherRedisDesktopManager: Github国内镜像，供下载使用，有问题可移步到 (gitee.com)</a></p><p>github开源地址：<a href="https://github.com/qishibo/AnotherRedisDesktopManager">qishibo/AnotherRedisDesktopManager: 🚀🚀🚀A faster, better and more stable redis desktop manager, compatible with Linux, windows, mac. What’s more, it won’t crash when loading a large number of keys. (github.com)</a></p><p>一个更快、更好、更稳定的redis桌面管理工具，可以运行于Linux、Windows、Mac三大平台，并且当加载大数量的key不会crash</p><blockquote><p>🚀🚀🚀 A faster, better and more stable redis desktop manager, compatible with Linux, windows, mac. What’s more, it won’t crash when loading a large number of keys.</p></blockquote><p><img src="https://i.loli.net/2020/12/03/1yVO9dftPL6mq7g.png" alt="Another Redis DeskTop Manager"></p><h2 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h2><p><img src="https://i.loli.net/2020/12/03/AIzSwk2qtevHObV.png" alt="多语言支持"></p><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><h3 id="深色主题效果"><a href="#深色主题效果" class="headerlink" title="深色主题效果"></a>深色主题效果</h3><p><img src="https://i.loli.net/2020/12/03/kvaDJuxZLPByHlR.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/12/03/Rwf8qVk7Tnoe2CD.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/12/03/6Nj3aoFxwuY5gfZ.jpg" alt="img"></p><h3 id="亮色主题效果"><a href="#亮色主题效果" class="headerlink" title="亮色主题效果"></a>亮色主题效果</h3><p><img src="https://i.loli.net/2020/12/03/BpAL8UbodZ7IeVa.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/12/03/BpAL8UbodZ7IeVa.jpg"></p><p><img src="https://i.loli.net/2020/12/03/YjtNxwTMr1zkWi9.jpg" alt="img"></p><blockquote><p>服务器状态监控，数据操作等等功能齐全。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常开发过程中，项目常常都会使用Redis来做缓存或者Session服务器，为了更直观方便，开发者常常会使用一些可视化工具，如 Redis Desktop Manager、Redis Clent等，但界面UI做得不尽人意，作为当今时代，对软件的UI还是有所期待的，今天给大家</summary>
      
    
    
    
    <category term="activate" scheme="http://example.com/categories/activate/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB引擎之-两次写（Double Write）</title>
    <link href="http://example.com/2020/12/03/2.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E4%B8%A4%E6%AC%A1%E5%86%99%EF%BC%88Double%20Write%EF%BC%89/"/>
    <id>http://example.com/2020/12/03/2.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E4%B8%A4%E6%AC%A1%E5%86%99%EF%BC%88Double%20Write%EF%BC%89/</id>
    <published>2020-12-03T02:00:46.000Z</published>
    <updated>2020-12-09T06:19:24.351Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h3 id="经典Partial-page-write问题"><a href="#经典Partial-page-write问题" class="headerlink" title="经典Partial page write问题"></a>经典Partial page write问题</h3><p>介绍double write之前我们有必要了解<code>partial page write</code>（部分页失效）。</p><p>InnoDB的Page Size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以Page为单位进行操作的。我们知道，由于文件系统对一次大数据页（例如InnoDB的16KB）大多数情况下不是原子操作，这意味着如果服务器宕机了，可能只做了部分写入。16K的数据，写入4K时，发生了系统断电/os crash ，只有一部分写是成功的，这种情况下就是<code>partial page write</code>问题。</p><p>我们一般可能会想到，如果发生写失效，MySQL可以根据redo log进行恢复。这是一个办法，但是必须清楚地认识到，redo log中记录的是对页的物理修改，如偏移量<code>800</code>，写<code>aaaa</code>记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。MySQL在恢复的过程中检查page的checksum，checksum就是检查page的最后事务号，发生<code>partial page write</code>问题时，page已经损坏，找不到该page中的事务号。在InnoDB看来，这样的数据页是无法通过checksum验证的，就无法恢复。即时我们强制让其通过验证，也无法从崩溃中恢复，因为当前InnoDB存在的一些日志类型，有些是逻辑操作，并不能做到幂等。</p><p>为了解决这个问题，InnoDB实现了<code>double write buffer</code>，简单来说，就是在写数据页之前，先把这个数据页写到一块独立的物理文件位置（ibdata），然后再写到数据页。这样在宕机重启时，如果出现数据页损坏，那么在应用redo log之前，需要通过该页的副本来还原该页，然后再进行redo log重做，这就是<code>double write</code>。<code>double write</code>技术带给innodb存储引擎的是数据页的可靠性，下面对<code>double write</code>技术进行解析，让大家充分理解<code>double write</code>是如何做到保障数据页的可靠性。</p><h3 id="double-write体系结构"><a href="#double-write体系结构" class="headerlink" title="double write体系结构"></a>double write体系结构</h3><p><code>double write</code>由两部分组成，一部分是InnoDB内存中的<code>double write buffer</code>，大小为2M，另一部分是物理磁盘上<code>ibdata</code>系统表空间中大小为2MB，共128个连续的Page，既2个分区。其中120个用于批量写脏，另外8个用于Single Page Flush。做区分的原因是批量刷脏是后台线程做的，不影响前台线程。而Single page flush是用户线程发起的，需要尽快的刷脏并替换出一个空闲页出来。</p><p>对于批量刷脏，每次找到一个可做flush的page，对其持有S lock，然后将该page拷贝到dblwr中，当dblwr满后者一次批量刷脏结束时，将dblwr中的page全部刷到ibdata中，注意这是同步写操作；然后再唤醒后台IO线程去写数据页。当后台IO线程完成写操作后，会去更新dblwr中的计数以腾出空间，释放block上的S锁，完成写入。</p><p>对于Single Page Flush，则做的是同步写操作，在挑出一个可以刷脏的page后，先加入到dblwr中，刷到<code>ibdata</code>，然后写到用户表空间，完成后，会对该用户表空间做一次fsync操作。</p><p>Single Page Flush在buffer pool中free page不够时触发，通常由前台线程发起，由于每次single page flush都会导致一次fsync操作，在大并发负载下，如果大量线程去做flush，很显然会产生严重的性能下降。Percona在5.6版本中做了优化，可以选择由后台线程lru manager来做预刷，避免用户线程陷入其中。</p><p>如果发生了极端情况（断电），InnoDB再次启动后，发现了一个Page数据已经损坏，那么此时就可以从double write buffer中进行数据恢复了。</p><h3 id="double-write工作流程"><a href="#double-write工作流程" class="headerlink" title="double write工作流程"></a>double write工作流程</h3><p>当一系列机制（main函数触发、checkpoint等）触发数据缓冲池中的脏页进行刷新到data file的时候，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的double write buffer，之后通过double write buffer再分两次、每次1MB顺序写入共享表空间的物理磁盘上。然后马上调用fsync函数，同步脏页进磁盘上。由于在这个过程中，double write页的存储时连续的，因此写入磁盘为顺序写，性能很高；完成<code>double write</code>后，再将脏页写入实际的各个表空间文件，这时写入就是离散的了。各模块协作情况如下图（第一步应为脏页产生的redo记录log buffer，然后log buffer写入redo log file，为简化次要步骤直接连线表示）：</p><p><a href="http://www.ywnds.com/wp-content/uploads/2017/04/2017041411205698.jpg"><img src="https://i.loli.net/2020/12/01/BCwp5buVkWTU6X7.jpg" alt="MySQL InnoDB特性：两次写（Double Write）"></a></p><p>查看double write工作情况，可以执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show status like &quot;%InnoDB_dblwr%&quot; ;</span><br><span class="line">+ -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- +</span><br><span class="line">| Variable_name                | Value         |</span><br><span class="line">+ -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- +</span><br><span class="line">| Innodb_dblwr_pages_written   | 61932183      |</span><br><span class="line">| Innodb_dblwr_writes          | 15237891      |</span><br><span class="line">+ -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- +</span><br><span class="line">2 rows in set ( 0.01 sec )</span><br></pre></td></tr></table></figure><p>以上数据显示，double write一共写了 61932183个页，一共写了15237891次，从这组数据我们可以分析，之前讲过在开启double write后，每次脏页刷新必须要先写double write，而double write存在于磁盘上的是两个连续的区，每个区由连续的页组成，一般情况下一个区最多有64个页，所以一次IO写入应该可以最多写64个页。而根据以上我这个系统Innodb_dblwr_pages_written与Innodb_dblwr_writes的比例来看，一次大概在4个页左右，远远还没到64，所以从这个角度也可以看出，系统写入压力并不高。</p><p>如果操作系统在将页写入磁盘的过程中发送了崩溃，在恢复过程中，InnoDB存储引擎可以从工序表空间中的double write中找到该页的副本，将其复制到表空间文件，再应用redo log。下面显示了一个由double write进行恢复的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">090924 11 : 36 : 32    mysqld restarted</span><br><span class="line">090924 11 : 26 : 33    InnoDB : Database was not shut down normally !</span><br><span class="line">InnoDB : Starting crash recovery .</span><br><span class="line">InnoDB : Reading tablespace information from the .ibd files . . .</span><br><span class="line">InnoDB : Crash recovery may have faild for some .ibd files !</span><br><span class="line">InnoDB : Restoring possible half - written data pages from the doublewrite .</span><br><span class="line">InnoDB : buffer . . .</span><br></pre></td></tr></table></figure><h3 id="double-write缺点"><a href="#double-write缺点" class="headerlink" title="double write缺点"></a>double write缺点</h3><p>dblwr位于共享表空间上的double write buffer实际上也是一个文件，引入了一次额外写的开销，每个数据页都被要求写两次。由于需要大量的fsync操作，所以它会降低MySQL的整体性能，但是并不会降低到原来的50%。这主要是因为：</p><ol><li><p>double write是一个连接的存储空间，所以硬盘在写数据的时候是顺序写，而不是随机写，这样性能更高。</p></li><li><p>将数据从double write buffer写到真正的segment中的时候，系统会自动合并连接空间刷新的方式，每次可以刷新多个pages。</p></li></ol><p>double write默认开启，参数skip_innodb_double_write虽然可以禁止使用double write功能，但还是强烈建议大家使用double write。避免部分写失效问题，当然，如果你的数据表空间放在本身就提供了部分写失效防范机制的文件系统上，如ZFS/FusionIO/DirectFS文件系统，在这种情况下，就可以不开启double write了。</p><h3 id="double-write在恢复的时候是如何工作的？"><a href="#double-write在恢复的时候是如何工作的？" class="headerlink" title="double write在恢复的时候是如何工作的？"></a>double write在恢复的时候是如何工作的？</h3><p>如果是写double write buffer本身失败，那么这些数据不会被写到磁盘，InnoDB此时会从磁盘载入原始的数据，然后通过InnoDB的事务日志来计算出正确的数据，重新写入到double write buffer。</p><p>如果double write buffer写成功的话，但是写磁盘失败，InnoDB就不用通过事务日志来计算了，而是直接用buffer的数据再写一遍。如上图中显示，在恢复的时候，InnoDB直接比较页面的checksum，如果不对的话，Innodb存储引擎可以从共享表空间的double write中找到该页的一个最近的副本，将其复制到表空间文件，再应用redo log，就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏，但InnoDB的恢复通常需要较长的时间。</p><h3 id="MariaDB-MySQL-Facebook-Percona-5-7的改进"><a href="#MariaDB-MySQL-Facebook-Percona-5-7的改进" class="headerlink" title="MariaDB/MySQL/Facebook/Percona 5.7的改进"></a>MariaDB/MySQL/Facebook/Percona 5.7的改进</h3><h4 id="MariaDB-MySQL改进"><a href="#MariaDB-MySQL改进" class="headerlink" title="MariaDB/MySQL改进"></a>MariaDB/MySQL改进</h4><p>MariaDB使用参数<a href="https://mariadb.com/kb/en/mariadb/fusion-io-nvmfs-atomic-write-support/?spm=5176.100239.blogcont50627.8.RbCnm5">innodb_use_atomic_writes</a>来控制原子写行为，当打开该选项时，会使用O_DIRECT模式打表空间，通过posix_fallocate来扩展文件（而不是写0扩展），当在启动时检查到支持atomic write时，即使开启了innodb_doublewrite，也会关闭掉。</p><p>Oracle MySQL同样支持FusionIO的Atomic Write特性（Fusion-io Non-Volatile Memory (NVM) file system），对于支持原子写的文件系统，也会自动关闭double write buffer。</p><h4 id="Facebook改进"><a href="#Facebook改进" class="headerlink" title="Facebook改进"></a>Facebook改进</h4><p>实际上这不能算是改进，只是提供了一个新的选项。在现实场景中，宕机是非常低概率的事件。大部分情况下dblwr都是用不上的。但如果我们直接关闭dblwr，如果真的发生例如掉电宕机了，我们需要知道哪些page可能损坏了。</p><p>因此Facebook MySQL提供了一个选项，可以写page之前，只将对应的page number写到dblwr中（而不是写全page），在崩溃恢复时，先读出记录在dblwr中的page号，检查对应的数据页是否损坏，如果损坏了，那就需要从备库重新恢复该实例。</p><h4 id="Percona-5-7改进"><a href="#Percona-5-7改进" class="headerlink" title="Percona 5.7改进"></a>Percona 5.7改进</h4><p>Percona Server的每个版本都对InnoDB的刷脏逻辑做了不少的优化，进入5.7版本也不例外。在官方5.7中已经实现了多个Page Cleaner，我们可以把Page Cleaner配置成和buffer pool instance的个数相同，可以更好的实现并行刷脏。</p><p>但是官方版本中，Page cleaner既要负责刷FLUSH LIST，同时也要做LRU FLUSH(但每个bp instance不超过innodb_lru_scan_depth)。而这两部分任务是可以独立进行的。</p><p>因此Percona Server增加了多个LRU FLUSH线程，可以更高效的进行lru flush，避免用户线程陷入single page flush状态。每个buffer pool instance拥有自己的lru flush线程和page cleaner线程。lru flush基于当前free list的长度进行自适应计算。 每个lru线程负责自己的那个Buffer pool。因此不同lru flush线程的繁忙程度可能是不一样的。</p><p>在解决上述问题后，bp flush的并行效率大大的提升了。但是对于所有的刷脏操作，都需要走到double write buffer。这意味着dblwr成为了新的瓶颈。为了解决这个问题，dblwr进行了拆分，每个bp instance都有自己的dblwr区域。这样各个Lru flush线程及Page cleaner线程在做page flush时就不会相互间产生锁冲突，从而提升了系统的扩展性。</p><p>你可以通过参数来配置一个独立于ibdata之外的文件来存储dblwr，文件被划分成多个区域，分区数为bp instance的个数，每个分区的大小为2 * srv_doublewrite_batch_size，每个batch size默认配置为120个page，其中一个用于刷FLUSH LIST，一个用于刷LRU。</p><p>如果fast shutdown设置为2，dblwr文件在正常shutdown时会被删除掉，并在重启后重建。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入缓冲（Insert Buffer）&lt;/li&gt;
&lt;li&gt;两次写（Double Write）&lt;/li&gt;
&lt;li&gt;自适应哈希索引（Adaptive Hash Index）&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB引擎之-插入缓冲（Insert Buffer）</title>
    <link href="http://example.com/2020/12/01/1.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%EF%BC%88Insert%20Buffer%EF%BC%89/"/>
    <id>http://example.com/2020/12/01/1.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%EF%BC%88Insert%20Buffer%EF%BC%89/</id>
    <published>2020-12-01T03:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB引擎之-插入缓冲（Insert-Buffer）"><a href="#InnoDB引擎之-插入缓冲（Insert-Buffer）" class="headerlink" title="InnoDB引擎之-插入缓冲（Insert Buffer）"></a>InnoDB引擎之-插入缓冲（Insert Buffer）</h2><p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><p>今天主题就是 <code>插入缓冲（Insert Buffer）</code>,由于InnoDB引擎底层数据存储结构式B+树，对于索引又有聚集索引和非聚集索引。</p><p>在进行数据插入时必然会引起索引的变化，聚集索引一般都是递增有序的。非聚集索引就不一定是什么数据了，其离散性导致了在插入时结构的不断变化，从而导致插入性能降低。</p><p>为了解决非聚集索引插入性能的问题，InnoDB引擎 创造了Insert Buffer。</p><h3 id="Insert-Buffer-存储"><a href="#Insert-Buffer-存储" class="headerlink" title="Insert Buffer 存储"></a>Insert Buffer 存储</h3><p><img src="https://i.loli.net/2020/12/01/sjZ13dzIkYBhanv.png" alt="InnerDB存储引擎内存结构"></p><p>上图可能大家会认为Insert Buffer 就是InnoDB 缓冲池的一个组成部分。</p><blockquote><p><strong>重点</strong>：其实对也不对，InnoDB 缓冲池确实包含了Insert Buffer的信息，但Insert Buffer 和数据页一样，也是物理存在的（以B+树的形式存在共享表空间中）。</p></blockquote><h3 id="Insert-Buffer-作用"><a href="#Insert-Buffer-作用" class="headerlink" title="Insert Buffer 作用"></a>Insert Buffer 作用</h3><p>先说几个点：</p><ul><li><p>一张表只能有一个主键索引，那是因为其物理存储是一个B+树。（别忘了聚集索引叶子节点存储的数据，而数据只有一份）</p></li><li><p>非聚集索引叶子节点存的是聚集索引的主键</p></li></ul><h3 id="Insert-Buffer-插入过程"><a href="#Insert-Buffer-插入过程" class="headerlink" title="Insert Buffer  插入过程"></a>Insert Buffer  插入过程</h3><h4 id="聚集索引插入"><a href="#聚集索引插入" class="headerlink" title="聚集索引插入"></a>聚集索引插入</h4><p>在InnoDB存储引擎中，主键是行唯一的标识符（聚集索引）。</p><p>插入数据一般都是按照主键递增插入，因此聚集索引都是顺序的，不需要磁盘的随机读取。</p><p>比如表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line"> id INT AUTO_INCREMENT,</span><br><span class="line"> name VARCHAR(30),</span><br><span class="line"> PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上表中主键 id,它有以下的特性：</p><ul><li>id列是自增长的</li><li>id列插入NULL值时，由于AUTO_INCREMENT的原因，其值会递增</li><li>同时数据页中的行记录按id的值进行顺序存放</li></ul><p>一般情况下由于聚集索引的有序性，不需要随机读取页中的数据，顺序插入速度是非常快的。</p><p>但如果你把列 id 插入UUID这种数据，那你插入就是和非聚集索引一样都是随机的了。会导致你的B+ tree结构不停地变化，那性能必然会受到影响。</p><h4 id="非聚集索引插入"><a href="#非聚集索引插入" class="headerlink" title="非聚集索引插入"></a>非聚集索引插入</h4><p>表中一般有很多非聚集索引，比如我按照b字段查询，且b字段不是唯一的。如下表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line"> id INT AUTO_INCREMENT,</span><br><span class="line"> name VARCHAR(30),</span><br><span class="line"> PRIMARY KEY(id),</span><br><span class="line"> KEY(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如上表：</p><ul><li>有一个聚集索引 id</li><li>有一个不唯一的非聚集索引 name</li><li>在插入数据时数据页是按照主键id进行顺序存放</li><li>辅助索引 name的数据插入不是顺序的</li></ul><p>非聚集索引也是一颗B+树，只是叶子节点存的是聚集索引的主键和name 的值.因为不能保证name列的数据是顺序的，所以非聚集索引这棵树的插入必然也不是顺序的了。当然如果name列插入的是时间类型数据，那其非聚集索引的插入也是顺序的。</p><blockquote><p>可以看出非聚集索引插入的离散性导致了插入性能的下降，因此InnoDB引擎设计了 Insert Buffer来提高插入性能 。</p></blockquote><p>  <strong>Insert Buffer 插入过程：</strong></p><pre><code>1. 首先对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中。2. 若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。3. 给外部的感觉好像是树已经插入非聚集的索引的叶子节点，而其实是存放在其他位置了</code></pre><p>  以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，通常会将多个插入操作一起进行merge，这就大大的提升了非聚集索引的插入性能。</p><h3 id="Insert-Buffer的使用要求："><a href="#Insert-Buffer的使用要求：" class="headerlink" title="Insert Buffer的使用要求："></a>Insert Buffer的使用要求：</h3><ul><li>索引是非聚集索引</li><li>索引不是唯一（unique）的</li></ul><p>只有满足上面两个必要条件时，InnoDB存储引擎才会使用Insert Buffer来提高插入性能。</p><p><strong>那为什么必须满足上面两个条件呢？</strong></p><p>第一点索引是非聚集索引就不用说了，人家聚集索引本来就是顺序的也不需要你</p><p>第二点必须不是唯一（unique）的，因为在写入Insert Buffer时，数据库并不会去判断插入记录的唯一性。如果再去查找肯定又是离散读取的情况了，这样Insert Buffer就失去了意义。</p><h3 id="Insert-Buffer信息查看"><a href="#Insert-Buffer信息查看" class="headerlink" title="Insert Buffer信息查看"></a>Insert Buffer信息查看</h3><p>我们可以使用命令SHOW ENGINE INNODB STATUS来查看Insert Buffer的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 7545, free list len 3790, seg size 11336, </span><br><span class="line">8075308 inserts,7540969 merged sec, 2246304 merges</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用命令后，我们会看到很多信息，这里我们只看下INSERT BUFFER 的:</p><ul><li>seg size 代表当前Insert Buffer的大小  11336*16KB</li><li>free listlen 代表了空闲列表的长度</li><li>size 代表了已经合并记录页的数量</li><li>Inserts 代表了插入的记录数</li><li>merged recs 代表了合并的插入记录数量</li><li>merges 代表合并的次数，也就是实际读取页的次数</li></ul><p>merges：merged recs大约为1∶3，代表了Insert Buffer 将对于非聚集索引页的离散IO逻辑请求大约降低了2/3</p><h3 id="Insert-Buffer的问题"><a href="#Insert-Buffer的问题" class="headerlink" title="Insert Buffer的问题"></a>Insert Buffer的问题</h3><p>说了这么多针对于Insert Buffer的好处，但目前Insert Buffer也存在一个问题：</p><p>即在写密集的情况下，插入缓冲会占用过多的缓冲池内存（innodb_buffer_pool），默认最大可以占用到1/2的缓冲池内存。</p><p>占用了过大的缓冲池必然会对其他缓冲池操作带来影响</p><h3 id="Insert-Buffer的优化"><a href="#Insert-Buffer的优化" class="headerlink" title="Insert Buffer的优化"></a>Insert Buffer的优化</h3><p>MySQL5.5之前的版本中其实都叫做Insert Buffer，之后优化为 <code>Change Buffer</code>可以看做是 Insert Buffer 的升级版。</p><p>插入缓冲（ Insert Buffer）这个其实只针对 INSERT 操作做了缓冲，而Change Buffer 对INSERT、DELETE、UPDATE都进行了缓冲，所以可以统称为写缓冲，其可以分为：</p><ul><li>Insert Buffer</li><li>Delete Buffer</li><li>Purgebuffer</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>Insert Buffer到底是个什么？</strong></p><ul><li>其实Insert Buffer的数据结构就是一棵B+树。</li><li>在MySQL 4.1之前的版本中每张表有一棵Insert Buffer B+树</li><li>目前版本是全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer</li><li>这棵B+树存放在共享表空间ibdata1中</li></ul><p><strong>以下几种情况下 Insert Buffer会写入真正非聚集索引，也就是所说的Merge Insert Buffer</strong></p><ul><li>当辅助索引页被读取到缓冲池中时</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时</li><li>Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作</li></ul><p><strong>一句话概括下：</strong>Insert Buffer 就是用于提升非聚集索引页的插入性能的，其数据结构类似于数据页的一个B+树，物理存储在共享表空间ibdata1中 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;InnoDB引擎之-插入缓冲（Insert-Buffer）&quot;&gt;&lt;a href=&quot;#InnoDB引擎之-插入缓冲（Insert-Buffer）&quot; class=&quot;headerlink&quot; title=&quot;InnoDB引擎之-插入缓冲（Insert Buffer）&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL 语句优化整理</title>
    <link href="http://example.com/2020/11/25/SQL%20%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/11/25/SQL%20%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/</id>
    <published>2020-11-25T05:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.355Z</updated>
    
    <content type="html"><![CDATA[<p>为了提高 SQL 查询效率，我们都会采取一切 SQL 语句的优化。</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>可以在num上设置默认值0，<strong>确保表中num列没有null值</strong>，然后这样查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">10</span> <span class="keyword">or</span> num=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>可以这样查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">10</span></span><br><span class="line">union all</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>下面的查询也将导致全表扫描：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name like <span class="string">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure><p>若要提高效率，可以考虑全文检索。</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="title">in</span>(<span class="params"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span>)</span></span><br></pre></td></tr></table></figure><p>对于连续的数值，能用 between 就不要用 in 了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num between <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；<strong>它必须在编译时进行选择。</strong>然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=@num</span><br></pre></td></tr></table></figure><p>可以改为强制查询使用索引：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="title">with</span>(<span class="params">index(索引名</span>)) <span class="keyword">where</span> num</span>=@num</span><br></pre></td></tr></table></figure><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num/<span class="number">2</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure><p>应改为:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="title">substring</span>(<span class="params">name,<span class="number">1</span>,<span class="number">3</span></span>)</span>=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">--name以abc开头的id</span><br><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="title">datediff</span>(<span class="params">day,createdate,<span class="string">&#x27;2005-11-30&#x27;</span></span>)</span>=<span class="number">0</span></span><br><span class="line">--<span class="string">&#x27;2005-11-30&#x27;</span>生成的id</span><br></pre></td></tr></table></figure><p>应改为:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name like <span class="string">&#x27;abc%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> createdate&gt;=<span class="string">&#x27;2005-11-30&#x27;</span> <span class="keyword">and</span> createdate&lt;<span class="string">&#x27;2005-12-1&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p><strong>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算</strong>，否则系统将不能正确使用索引。</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> <span class="meta">#t from t where 1=0</span></span><br></pre></td></tr></table></figure><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="comment">#t(...)</span></span><br></pre></td></tr></table></figure><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>很多时候用 exists 代替 in 是一个好的选择：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> num <span class="title">in</span>(<span class="params"><span class="keyword">select</span> num <span class="keyword">from</span> b</span>)</span></span><br></pre></td></tr></table></figure><p>用下面的语句替换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> <span class="title">exists</span>(<span class="params"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> num=a.num</span>)</span></span><br></pre></td></tr></table></figure><h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，<strong>一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。</strong>若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h3 id="19"><a href="#19" class="headerlink" title="19"></a>19</h3><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><h3 id="20"><a href="#20" class="headerlink" title="20"></a>20</h3><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><h3 id="21"><a href="#21" class="headerlink" title="21"></a>21</h3><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><h3 id="22"><a href="#22" class="headerlink" title="22"></a>22</h3><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。<strong>但是，对于一次性事件，最好使用导出表。</strong></p><h3 id="23"><a href="#23" class="headerlink" title="23"></a>23</h3><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><h3 id="24"><a href="#24" class="headerlink" title="24"></a>24</h3><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><h3 id="25"><a href="#25" class="headerlink" title="25"></a>25</h3><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><h3 id="26"><a href="#26" class="headerlink" title="26"></a>26</h3><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><h3 id="27"><a href="#27" class="headerlink" title="27"></a>27</h3><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括<strong>“合计”的例程通常要比使用游标执行的速度快。</strong>如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><h3 id="28"><a href="#28" class="headerlink" title="28"></a>28</h3><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><h3 id="29"><a href="#29" class="headerlink" title="29"></a>29</h3><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><h3 id="30"><a href="#30" class="headerlink" title="30"></a>30</h3><p>尽量避免大事务操作，提高系统并发能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了提高 SQL 查询效率，我们都会采取一切 SQL 语句的优化。&lt;/p&gt;
&lt;h3 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h3&gt;&lt;p&gt;对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring事物失效原因整理</title>
    <link href="http://example.com/2020/11/24/Spring%E4%BA%8B%E7%89%A9%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/11/24/Spring%E4%BA%8B%E7%89%A9%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E6%95%B4%E7%90%86/</id>
    <published>2020-11-24T03:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring事物实现方式及原理"><a href="#Spring事物实现方式及原理" class="headerlink" title="Spring事物实现方式及原理"></a>Spring事物实现方式及原理</h2><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。真正的数据库层的事务提交和回滚是在binlog提交之后进行提交的 通过 redo log 来重做， undo log来回滚。</p><p>一般我们在程序里面使用的都是在方法上面加<code>@Transactional</code> 注解，这种属于声明式事物。</p><p>声明式事务本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><h2 id="失效原因"><a href="#失效原因" class="headerlink" title="失效原因"></a>失效原因</h2><h3 id="数据库本身不支持事物"><a href="#数据库本身不支持事物" class="headerlink" title="数据库本身不支持事物"></a>数据库本身不支持事物</h3><p>这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB</p><h3 id="当前类的调用"><a href="#当前类的调用" class="headerlink" title="当前类的调用"></a>当前类的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        updateUser(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这种情况下是不会有事物管理操作的。</p><p>通过看声明式事物的原理可知，Spring使用的是AOP切面的方式，本质上使用的是动态代理来达到事物管理的目的，当前类调用的方法上面加<code>@Transactional</code> 这个是没有任何作用的，因为调用这个方法的是<code>this</code>.</p><p>OK， 我们在看下面的一种例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        updateUser(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次在 update 方法上加了 <code>@Transactional</code>，updateUser 加了 <code>REQUIRES_NEW</code> 新开启一个事务，那么新开的事务管用么？</p><p>答案是：不管用！</p><p>因为它们发生了自身调用，就调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效，这也是老生常谈的经典问题了。</p><h3 id="方法不是public的"><a href="#方法不是public的" class="headerlink" title="方法不是public的"></a>方法不是public的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private</code> 方法是不会被Spring代理的，因此是不会有事物产生的，这种做法是无效的。</p><h3 id="没有被Spring管理"><a href="#没有被Spring管理" class="headerlink" title="没有被Spring管理"></a>没有被Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有被Spring管理的bean， Spring连代理对象都无法生成，当然无效咯。</p><h3 id="配置的事物传播性有问题"><a href="#配置的事物传播性有问题" class="headerlink" title="配置的事物传播性有问题"></a>配置的事物传播性有问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下Spring的事物传播行为</p><p>Spring 事务的传播行为说的是，当多个事务同时存在的时候， Spring 如何处理这些事务的行为。</p><ol><li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行</li><li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER： 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按 REQUIRED 属性执行</li></ol><p>当传播行为设置了PROPAGATION_NOT_SUPPORTED，PROPAGATION_NEVER，PROPAGATION_SUPPORTS这三种时，就有可能存在事物不生效</p><h3 id="异常被-“抓住”了"><a href="#异常被-“抓住”了" class="headerlink" title="异常被 “抓住”了"></a>异常被 “抓住”了</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">catch</span>(Execption e)&#123;</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;异常&quot;</span>,e)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常被抓了，这样子代理类就没办法知道你到底有没有错误，需不需要回滚，所以这种情况也是没办法回滚的哦。</p><h3 id="接口层声明式事物使用cglib代理"><a href="#接口层声明式事物使用cglib代理" class="headerlink" title="接口层声明式事物使用cglib代理"></a>接口层声明式事物使用cglib代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用</p><p>注解@Transactional cglib与java动态代理最大区别是代理目标对象不用实现接口,那么注解要是写到接口方法上，要是使用cglib代理，这是注解事物就失效了，为了保持兼容注解最好都写到实现类方法上。</p><h3 id="rollbackFor异常指定错误"><a href="#rollbackFor异常指定错误" class="headerlink" title="rollbackFor异常指定错误"></a>rollbackFor异常指定错误</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种没有指定回滚异常，这个时候默认的回滚异常是<code>RuntimeException</code> ，如果出现其他异常那么就不会回滚事物</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring事物实现方式及原理&quot;&gt;&lt;a href=&quot;#Spring事物实现方式及原理&quot; class=&quot;headerlink&quot; title=&quot;Spring事物实现方式及原理&quot;&gt;&lt;/a&gt;Spring事物实现方式及原理&lt;/h2&gt;&lt;p&gt;Spring 事务的本质其实就是数据</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>java的优雅停机!!!</title>
    <link href="http://example.com/2020/11/24/java%E7%9A%84%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA!!!/"/>
    <id>http://example.com/2020/11/24/java%E7%9A%84%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA!!!/</id>
    <published>2020-11-24T03:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.355Z</updated>
    
    <content type="html"><![CDATA[<p><strong>优雅停机，就是在要关闭服务之前，不是立马全部关停，而是做好一些善后操作，比如：关闭线程、释放连接资源等。</strong></p><p>再比如，就是不会让调用方的请求处理了一增，一下就中断了。而处理完本次后，再停止服务。</p><p>Java语言中，我们可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook();</span><br></pre></td></tr></table></figure><p>方法来注册钩子，以保证程序平滑退出。（其他语言也类似）</p><p>来个栗子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用线程池处理任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设有5个线程需要执行任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> id = i;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : thread_&quot;</span> + id + <span class="string">&quot; start...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(id);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : thread_&quot;</span> + id + <span class="string">&quot; finish!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            executorService.submit(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个钩子处理未完任务</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No1 shutdown hooking...&quot;</span>);</span><br><span class="line">                <span class="keyword">boolean</span> shutdown = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executorService.shutdown();</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; shutdown signal got, wait threadPool finish.&quot;</span>);</span><br><span class="line">                    executorService.awaitTermination(<span class="number">1500</span>, TimeUnit.SECONDS);</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; all thread&#x27;s done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No1 shutdown done...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 多个关闭钩子并发执行</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No2 shutdown hooking...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No2 shutdown done...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(<span class="string">&quot;main method exit...&quot;</span>);</span><br><span class="line">        <span class="comment">// 故意调用jvm退出命令，发送关闭信号，否则正常情况下 jvm 会等待最后一个非守护线程关闭才会退出</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr7pe2iaeSicBuGxwcDcL37CZwmow3OzYRKPCYBGiblZfEf1qe3D4Nibia91aR4wrk4uAwFwOsztoUPEgWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>很明显，确实是优雅了，虽然最后收到了一关闭信号，但是仍然保证了任务的处理完成。很棒吧！</p><p>那么，在实际应用中是如何体现优雅停机呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -15 pid</span><br></pre></td></tr></table></figure><p>通过该命令发送一个关闭信号给到jvm, 然后就开始执行 Shutdown Hook 了，你可以做很多:</p><p>1、 关闭 socket 链接</p><p>2、 清理临时文件</p><p>3、 发送消息通知给订阅方，告知自己下线</p><p>4、 将自己将要被销毁的消息通知给子进程</p><p>5、 各种资源的释放</p><p>…</p><p>而在平时工作中，我们不乏看到很多运维同学，是这么干的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><p>如果这么干的话，jvm也无法了,kill -9 相当于一次系统宕机，系统断电。这会给应用杀了个措手不及，没有留给应用任何反应的机会。</p><p>所以，无论如何是优雅不起来了。</p><p>要优雅，是代码</p><p>其中，线程池的关闭方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line">executorService.awaitTermination(<span class="number">1500</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor 在 shutdown 之后会变成 SHUTDOWN 状态，无法接受新的任务，随后等待正在执行的任务执行完成。意味着，shutdown 只是发出一个命令，至于有没有关闭还是得看线程自己。</p><p>ThreadPoolExecutor 对于 shutdownNow 的处理则不太一样，方法执行之后变成 STOP 状态，并对执行中的线程调用 Thread.interrupt() 方法（但如果线程未处理中断，则不会有任何事发生），所以并不代表“立刻关闭”。</p><p>shutdown() ：启动顺序关闭，其中执行先前提交的任务，但不接受新任务。如果已经关闭，则调用没有附加效果。此方法不等待先前提交的任务完成执行。</p><p>shutdownNow()：尝试停止所有正在执行的任务，停止等待任务的处理，并返回正在等待执行的任务的列表。当从此方法返回时，这些任务将从任务队列中耗尽（删除）。此方法不等待主动执行的任务终止。</p><p>executor.awaitTermination(this.awaitTerminationSeconds, TimeUnit.SECONDS)); 控制等待的时间，防止任务无限期的运行（前面已经强调过了，即使是 shutdownNow 也不能保证线程一定停止运行）。</p><p>注意:</p><p>虚拟机会对多个ShutdownHook以未知的顺序调用，都执行完后再退出。</p><p>如果接收到 kill -15 pid 命令时，执行阻塞操作，可以做到等待任务执行完成之后再关闭 JVM。同时，也解释了一些应用执行 kill -15 pid 无法退出的问题，如:中断被阻塞了,或者hook运行了死循环代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;优雅停机，就是在要关闭服务之前，不是立马全部关停，而是做好一些善后操作，比如：关闭线程、释放连接资源等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再比如，就是不会让调用方的请求处理了一增，一下就中断了。而处理完本次后，再停止服务。&lt;/p&gt;
&lt;p&gt;Java语言中，我们</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Java8中Stream的实现原理</title>
    <link href="http://example.com/2020/11/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java8%E4%B8%ADStream%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2020/11/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java8%E4%B8%ADStream%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-24T02:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.355Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会使用Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？</p><p>比如Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线的原理，这是Stream实现的关键所在。</p><p>首先回顾一下容器执行Lambda表达式的方式，以<code>ArrayList.forEach()</code>方法为例，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList.forEach()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);<span class="comment">// 回调方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到<code>ArrayList.forEach()</code>方法的主要逻辑就是一个<em>for</em>循环，在该<em>for</em>循环里不断调用<code>action.accept()</code>回调方法完成对元素的遍历。</p><p>这完全没有什么新奇之处，回调方法在Java GUI的监听器中广泛使用。Lambda表达式的作用就是相当于一个回调方法，这很好理解。</p><p>Stream API中大量使用Lambda表达式作为回调方法，但这并不是关键。理解Stream我们更关心的是另外两个问题：流水线和自动并行。使用Stream或许很容易写入如下形式的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> longestStringLengthStartingWithA</span><br><span class="line">        = strings.stream()</span><br><span class="line">              .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">              .mapToInt(String::length)</span><br><span class="line">              .max();</span><br></pre></td></tr></table></figure><p>上述代码求出以字母<em>A</em>开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。</p><p>类库的实现着使用流水线（<em>Pipeline</em>）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了Stream的所有操作。</p><table><thead><tr><th>Stream操作分类</th><th></th><th></th></tr></thead><tbody><tr><td>中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip()</td><td></td></tr><tr><td>结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td><td></td></tr></tbody></table><p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(<em>Stateless</em>)和有状态的(<em>Stateful</em>)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果。</p><p>比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如<em>找到第一个满足条件的元素</em>。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p><p>为了更好的理解流的中间操作和终端操作，可以通过下面的两段代码来看他们的执行过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;\nA&quot;</span> + x))</span><br><span class="line">   .limit(<span class="number">3</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;B&quot;</span> + x))</span><br><span class="line">   .forEach(x -&gt; System.out.print(<span class="string">&quot;C&quot;</span> + x));</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A1B1C1</span><br><span class="line">A2B2C2</span><br><span class="line">A3B3C3</span><br></pre></td></tr></table></figure><p>中间操作是懒惰的，也就是中间操作不会对数据做任何操作，直到遇到了最终操作。而最终操作，都是比较热情的。他们会往前回溯所有的中间操作。也就是当执行到最后的forEach操作的时候，它会回溯到它的上一步中间操作，上一步中间操作，又会回溯到上上一步的中间操作，…，直到最初的第一步。</p><p>第一次forEach执行的时候，会回溯peek 操作，然后peek会回溯更上一步的limit操作，然后limit会回溯更上一步的peek操作，顶层没有操作了，开始自上向下开始执行，输出：A1B1C1 第二次forEach执行的时候，然后会回溯peek 操作，然后peek会回溯更上一步的limit操作，然后limit会回溯更上一步的peek操作，顶层没有操作了，开始自上向下开始执行，输出：A2B2C2</p><p>… 当第四次forEach执行的时候，然后会回溯peek 操作，然后peek会回溯更上一步的limit操作，到limit的时候，发现limit(3)这个job已经完成，这里就相当于循环里面的break操作，跳出来终止循环。</p><p>再来看第二段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;\nA&quot;</span> + x))</span><br><span class="line">   .skip(<span class="number">6</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;B&quot;</span> + x))</span><br><span class="line">   .forEach(x -&gt; System.out.print(<span class="string">&quot;C&quot;</span> + x));</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A1</span><br><span class="line">A2</span><br><span class="line">A3</span><br><span class="line">A4</span><br><span class="line">A5</span><br><span class="line">A6</span><br><span class="line">A7B7C7</span><br><span class="line">A8B8C8</span><br><span class="line">A9B9C9</span><br></pre></td></tr></table></figure><p>第一次forEach执行的时候，会回溯peek操作，然后peek会回溯更上一步的skip操作，skip回溯到上一步的peek操作，顶层没有操作了，开始自上向下开始执行，执行到skip的时候，因为执行到skip，这个操作的意思就是跳过，下面的都不要执行了，也就是就相当于循环里面的continue，结束本次循环。输出：A1</p><p>第二次forEach执行的时候，会回溯peek操作，然后peek会回溯更上一步的skip操作，skip回溯到上一步的peek操作，顶层没有操作了，开始自上向下开始执行，执行到skip的时候，发现这是第二次skip，结束本次循环。输出：A2</p><p>…</p><p>第七次forEach执行的时候，会回溯peek操作，然后peek会回溯更上一步的skip操作，skip回溯到上一步的peek操作，顶层没有操作了，开始自上向下开始执行，执行到skip的时候，发现这是第七次skip，已经大于6了，它已经执行完了skip(6)的job了。这次skip就直接跳过，继续执行下面的操作。输出：A7B7C7</p><p>…直到循环结束。</p><p>面试题推荐：100期面试题汇总</p><h2 id="一种直白的实现方式"><a href="#一种直白的实现方式" class="headerlink" title="一种直白的实现方式"></a>一种直白的实现方式</h2><p>仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。</p><p>具体说来，就是调用<code>filter()</code>方法后立即执行，选出所有以<em>A</em>开头的字符串并放到一个列表list1中，之后让list1传递给<code>mapToInt()</code>方法并立即执行，生成的结果放到list2中，最后遍历list2找出最大的数字作为最终结果。程序的执行流程如如所示：</p><p><img src="https://i.loli.net/2020/11/24/DKJ23moc9dEPHsA.png" alt="Stream Pipeline"></p><p>这样做实现起来非常简单直观，但有两个明显的弊端：</p><ol><li>迭代次数多。迭代次数跟函数调用的次数相等。</li><li>频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。</li></ol><p>这些弊端使得效率底下，根本无法接受。如果不使用Stream API我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String str : strings)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.startsWith(<span class="string">&quot;A&quot;</span>))&#123;<span class="comment">// 1. filter(), 保留以A开头的字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = str.length();<span class="comment">// 2. mapToInt(), 转换成长度</span></span><br><span class="line">        longest = Math.max(len, longest);<span class="comment">// 3. max(), 保留最长的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟Stream API等价的功能，但问题是Stream类库的设计者并不知道用户的意图是什么。</p><p>如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。</p><p>面试题推荐：100期面试题汇总</p><h2 id="Stream流水线解决方案"><a href="#Stream流水线解决方案" class="headerlink" title="Stream流水线解决方案"></a>Stream流水线解决方案</h2><p>我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：</p><ol><li>用户的操作如何记录？</li><li>操作如何叠加？</li><li>叠加之后的操作如何执行？</li><li>执行后的结果（如果有）在哪里？</li></ol><h3 id="操作如何记录"><a href="#操作如何记录" class="headerlink" title="操作如何记录"></a>操作如何记录</h3><p>注意这里使用的是“*操作(operation)*”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是&lt;*数据来源，操作，回调函数*&gt;构成的三元组。</p><p>Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的<em>PipelineHelper</em>来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。</p><p><img src="https://i.loli.net/2020/11/24/HR2qW49MJAe3iBm.png" alt="关系图"></p><p>还有<em>IntPipeline, LongPipeline, DoublePipeline</em>没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟<em>ReferencePipeline</em>是并列关系。</p><p>图中<em>Head</em>用于表示第一个Stage，即调用调用诸如<em>Collection.stream()\</em>方法产生的Stage，很显然这个Stage里不包含任何操作；*StatelessOp*和*StatefulOp*分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。</p><p>Stream流水线组织结构示意图如下：</p><p><img src="https://i.loli.net/2020/11/24/vBNjQsaw68f3HzS.png" alt="Stream流水线组织结构示意图"></p><p>图中通过<code>Collection.stream()</code>方法得到<em>Head</em>也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。<strong>这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作</strong>。这就是Stream记录操作的方式。</p><h3 id="操作如何叠加"><a href="#操作如何叠加" class="headerlink" title="操作如何叠加"></a>操作如何叠加</h3><p>以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。</p><p>这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。</p><p>这种协议由<em>Sink</em>接口完成，<em>Sink</em>接口包含的方法如下表所示：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void begin(long size)</td><td>开始遍历元素之前调用该方法，通知Sink做好准备。</td></tr><tr><td>void end()</td><td>所有元素遍历完成之后调用，通知Sink没有更多的元素了。</td></tr><tr><td>boolean cancellationRequested()</td><td>是否可以结束操作，可以让短路操作尽早结束。</td></tr><tr><td>void accept(T t)</td><td>遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前Stage.accept(T t)方法就行了。</td></tr></tbody></table><p>有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的<code>accept()</code>方法即可，并不需要知道其内部是如何处理的。</p><p>当然对于有状态的操作，Sink的<code>begin()</code>和<code>end()</code>方法也是必须实现的。比如Stream.sorted()是一个有状态的中间操作，其对应的Sink.begin()方法可能创建一个盛放结果的容器，而accept()方法负责将元素添加到该容器，最后end()负责对容器进行排序。</p><p>对于短路操作，<code>Sink.cancellationRequested()</code>也是必须实现的，比如Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回<em>true</em>，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。</p><p><strong>实际上Stream API内部实现的的本质，就是如何重写Sink的这四个接口方法</strong>。</p><p>有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。一种可能的Sink.accept()方法流程是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(U u)</span></span>&#123;</span><br><span class="line">    <span class="number">1.</span> 使用当前Sink包装的回调函数处理u</span><br><span class="line">    <span class="number">2.</span> 将处理结果传递给流水线下游的Sink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sink接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。</p><p>下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看Stream.map()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.map()，调用该方法将产生一个新的Stream</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/*opWripSink()方法返回由回调函数包装而成Sink*/</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; downstream)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    R r = mapper.apply(u);<span class="comment">// 1. 使用当前Sink包装的回调函数mapper处理u</span></span><br><span class="line">                    downstream.accept(r);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看似复杂，其实逻辑很简单，就是将回调函数<em>mapper</em>包装到一个Sink当中。由于Stream.map()是一个无状态的中间操作，所以map()方法返回了一个StatelessOp内部类对象（一个新的Stream），调用这个新Stream的opWripSink()方法将得到一个包装了当前回调函数的Sink。</p><p>再来看一个复杂一点的例子。Stream.sorted()方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，sorted()方法是如何将操作封装成Sink的呢？sorted()一种可能封装的Sink代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.sort()方法用到的Sink实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;<span class="comment">// 存放用于排序的元素</span></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; downstream, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(downstream, comparator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建一个存放排序元素的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.sort(comparator);<span class="comment">// 只有元素全部接收之后才能开始排序</span></span><br><span class="line">        downstream.begin(list.size());</span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;<span class="comment">// 下游Sink不包含短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 下游Sink包含短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;<span class="comment">// 每次都调用cancellationRequested()询问是否可以结束处理。</span></span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);<span class="comment">// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码完美的展现了Sink的四个接口方法是如何协同工作的：</p><ol><li>首先begin()方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；</li><li>之后通过accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；</li><li>最后end()方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；</li><li>如果下游的Sink是短路操作，将结果传递给下游时不断询问下游cancellationRequested()是否可以结束处理。</li></ol><h3 id="叠加之后的操作如何执行"><a href="#叠加之后的操作如何执行" class="headerlink" title="叠加之后的操作如何执行"></a>叠加之后的操作如何执行</h3><p><img src="https://i.loli.net/2020/11/24/cd9faq7bTvUJil4.png" alt="调用关系"></p><p>Sink完美封装了Stream每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。</p><p>是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。</p><p>结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。</p><p>结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理-&gt;转发]模型，结束操作的Sink就是调用链的出口。</p><p>我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在<em>PipelineHelper</em>中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。</p><p>但Stream类库的设计者没有这么做，而是设置了一个<code>Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)</code>方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？</p><p>这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.wrapSink()</span></span><br><span class="line"><span class="comment">// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，</span></span><br><span class="line"><span class="comment">// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());<span class="comment">// 通知开始遍历</span></span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);<span class="comment">// 迭代</span></span><br><span class="line">        wrappedSink.end();<span class="comment">// 通知遍历结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代，最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。后端技术精选公众号内回复“后端面试”，送你一份Java面试题宝典</p><h3 id="执行后的结果在哪里"><a href="#执行后的结果在哪里" class="headerlink" title="执行后的结果在哪里"></a>执行后的结果在哪里</h3><p>最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(<em>Side-effects</em>)，比如使用<code>Stream.forEach()</code>方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？</p><blockquote><p>特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的收集方式</span></span><br><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">      .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br><span class="line"><span class="comment">// 正确的收集方式</span></span><br><span class="line">List&lt;String&gt;results =</span><br><span class="line">     stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">             .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></span><br></pre></td></tr></table></figure><p>回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。</p><table><thead><tr><th>返回类型</th><th>对应的结束操作</th></tr></thead><tbody><tr><td>boolean</td><td>anyMatch() allMatch() noneMatch()</td></tr><tr><td>Optional</td><td>findFirst() findAny()</td></tr><tr><td>归约结果</td><td>reduce() collect()</td></tr><tr><td>数组</td><td>toArray()</td></tr></tbody></table><ol><li>对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。</li><li>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用reduce()方法实现的。</li><li>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做<em>Node</em>的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文详细介绍了Stream流水线的组织方式和执行过程，学习本文将有助于理解原理并写出正确的Stream代码，同时打消你对Stream API效率方面的顾虑。如你所见，Stream API实现如此巧妙，即使我们使用外部迭代手动编写等价代码，也未必更加高效。</p><p>注：留下本文所用的JDK版本，以便有考究癖的人考证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br><span class="line">java version &quot;1.8.0_101&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_101-b13)</span><br><span class="line">Java HotSpot(TM) Server VM (build 25.101-b13, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们经常会使用Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？&lt;/p&gt;
&lt;p&gt;比如Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>epub阅读软件分享</title>
    <link href="http://example.com/2020/11/23/epub%E9%98%85%E8%AF%BB%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    <id>http://example.com/2020/11/23/epub%E9%98%85%E8%AF%BB%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/</id>
    <published>2020-11-23T05:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.355Z</updated>
    
    <content type="html"><![CDATA[<p>智能时代，碎片化信息充斥 着我们的生活。手机不离手，各种社交/新闻软件可以使我们快速摄取信息知识。但是这种信息是片面的，不完整。看似我们获取了很多知识，但这些快餐式的信息传递并不能很好的提升我们的知识广度。还是完完整整的从书本中学习来的更踏实和全面。</p><p>电子书的普及和使用已经是非常完善的了。各种看电子书的设备/阅读软件/电子书格式满足不同的阅读需求。其实没有特别情况或者是经济方面比较宽松的情况下，不太需要购买专门的阅读设备，在手机上使用比较合适的阅读软件也能有很好的阅读体验。并且手机是随身物品，更方便随时阅读，不放过零碎时间。</p><p>铺垫了这么多是想给大家分享一下我使用过一些不错的阅读软件。最近使用epub格式电子书比较多，下面给大家说说可以支持epub格式的阅读软件。</p><h3 id="Neat-Reader"><a href="#Neat-Reader" class="headerlink" title="Neat Reader"></a>Neat Reader</h3><p>当时发现这款阅读器是想在应用商店找一找比较适合本地阅读的软件，neat reader是令我比较惊喜的。软件内部是没有书店书城来提供一些电子书资源的，但是作为看已有的电子书十分的适合。本地epub格式电子书可以一键传入软件中，书架上可以根据书名和最近阅读时间来排序。解析电子书打开速度也还不错，阅读提供了字体格式方面的自定义功能和阅读笔记方面的辅助功能。</p><p>整个软件是没有广告的，也没有什么书籍推荐，打开电子书就可以开始无打扰式阅读。登录账号有高级会员选项，可以额外获得10g云空间，解锁书架自定义排列和更多阅读设置。对于电子书很多又想随时不间断的阅读的用户，可以试试会员功能。</p><p>下载地址：<a href="https://links.jianshu.com/go?to=https://www.neat-reader.cn/">https://www.neat-reader.cn/</a></p><p><img src="https://upload-images.jianshu.io/upload_images/4129931-d34b5aa479238779.png" alt="img"></p><h3 id="Google-Play-Books"><a href="#Google-Play-Books" class="headerlink" title="Google Play Books"></a>Google Play Books</h3><p>看名字就知道是谷歌旗下的阅读软件了，这款软件不同于上一款，它拥有巨大的图书库，可以浏览上百万本好书。书城提供了一个很大的阅读平台，购买的电子书可以直接放在书架上。（顺便一说电子书的购买还是有些贵的）。</p><p>不仅可以线上阅读，支持epub格式和pdf格式的电子书，也可以阅读本地的图书。比较吸引人的一点是文本语音转换引擎可以在软件内大声朗读书籍。并且线上是有有声读物在贩的，在购买前支持试听。阅读时添加的注释可以与Google云端硬盘同步，但是好像没有直接导出功能。</p><p>下载地址：<a href="https://links.jianshu.com/go?to=https://play.google.com/store/apps/details?id=com.google.android.apps.books&hl=en_US">https://play.google.com/store/apps/details?id=com.google.android.apps.books&amp;hl=en_US</a></p><p><img src="https://upload-images.jianshu.io/upload_images/4129931-cafef508cd3e21bf.png" alt="img"></p><h3 id="Moon-Reader"><a href="#Moon-Reader" class="headerlink" title="Moon+ Reader"></a>Moon+ Reader</h3><p>这款可支持的格式比较多，epub, pdf,azw3, mobi, fb2, prc, chm, cbz, cbr等多种格式都可以支持使用。可以连接多个在线书库，内容算是比较丰富。而且它的自定义功能相当多，背景/主题/字体/配色/间距等等有很多选择，白天和夜晚模式也都分别有设置选项。阅读辅助功能除了基本功能，还有翻译功能可使用。</p><p>书架管理方面，可以选择我的珍藏/下载/作者/书籍分类，而且支持自制封面。可以说这款阅读软件比较全面，很是适合阅读的电子书格式比较杂乱的用户。但是我个人不是非常喜欢，感觉稍微有些累赘了。这款免费版是有弹窗广告的，高级版本没有广告而且可以解锁更多自定义功能。</p><p>下载地址：<a href="https://links.jianshu.com/go?to=http://www.moondownload.com/">http://www.moondownload.com/</a></p><p><img src="https://upload-images.jianshu.io/upload_images/4129931-f2538c3c202b5e3a.png" alt="img"></p><p>以上就是我分享的3款软件，它们功能不是很相同，但是使用感方面相当不错。如果你的手机缺一款阅读软件，可以试试我分享的这些。最后，还是想和大家说不要花太多的时间在一些快消新闻/段子上，让读书成为一种习惯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;智能时代，碎片化信息充斥 着我们的生活。手机不离手，各种社交/新闻软件可以使我们快速摄取信息知识。但是这种信息是片面的，不完整。看似我们获取了很多知识，但这些快餐式的信息传递并不能很好的提升我们的知识广度。还是完完整整的从书本中学习来的更踏实和全面。&lt;/p&gt;
&lt;p&gt;电子书的</summary>
      
    
    
    
    <category term="activate" scheme="http://example.com/categories/activate/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows10 添加Hyper-V</title>
    <link href="http://example.com/2020/11/23/win10%E6%B2%A1%E6%9C%89Hyper-V%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/11/23/win10%E6%B2%A1%E6%9C%89Hyper-V%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2020-11-23T03:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.355Z</updated>
    
    <content type="html"><![CDATA[<p>你还在找<code>Windows10</code>家庭版中开启<code>Hyper-v</code>的方法？如果你是因为要用<code>Docker for Windows</code>版本的话，我建议你去升级专业版</p><p><code>Windows10</code>家庭版添加<code>Hyper-V</code>的方法<br>将下面的内容复制到编辑器或者记事本当中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;%~dp0&quot;</span>``<span class="built_in">dir</span> /b %SystemRoot%\servicing\Packages\*Hyper<span class="literal">-V</span>*.mum &gt;hyper<span class="literal">-v</span>.txt``<span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;</span>) <span class="keyword">do</span> dism /online /norestart /<span class="built_in">add-package</span>:<span class="string">&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span>``<span class="built_in">del</span> hyper<span class="literal">-v</span>.txt``Dism /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Hyper</span><span class="literal">-V</span><span class="literal">-All</span> /LimitAccess /ALL</span><br></pre></td></tr></table></figure><p>进行保存，保存为<code>Hyper-V.cmd</code></p><p>在系统桌面上，我们找到并右键点击【Hyper-V.cmd】文件图标，在右键菜单中点击：<code>以管理员身份运行（A）</code></p><p>然后弹出一个 用户帐户控制 – Windows命令处理程序 对话框，我们点击：是</p><p>紧接着进行Windows命令处理，我们等待处理完成以后</p><p><img src="https://i.loli.net/2020/11/20/XktuN2zgAe1bRQ4.png" alt="命令"></p><p>在最末处输入：Y，电脑自动重启，进行配置更新。注意：不能关闭计算机</p><p>配置更新重启完成以后，我们去控制面板、所有控制面板项、程序和功能，点击启用或关闭<code>Windows</code>功能，就会发现我们已经有了<code>Hyper-v</code>功能</p><p><img src="https://i.loli.net/2020/11/20/FbMALVgGOqZINJU.jpg" alt="window功能"></p><p><strong>笔者认为Hyper-V不太方便，建议使用VMware或其它</strong>，提供一下VMware破解网盘地址，三个版本可以根据需要下载。PS：如果需要网盘破解地址可以留言或私信联系。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1LlLPbSEqmKbpb4ZnHfu3kg">https://pan.baidu.com/s/1LlLPbSEqmKbpb4ZnHfu3kg</a><br>提取码：irgp<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你还在找&lt;code&gt;Windows10&lt;/code&gt;家庭版中开启&lt;code&gt;Hyper-v&lt;/code&gt;的方法？如果你是因为要用&lt;code&gt;Docker for Windows&lt;/code&gt;版本的话，我建议你去升级专业版&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Windows10&lt;/co</summary>
      
    
    
    
    <category term="windows" scheme="http://example.com/categories/windows/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis为什么要分16个库</title>
    <link href="http://example.com/2020/11/20/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%8616%E4%B8%AA%E5%BA%93/"/>
    <id>http://example.com/2020/11/20/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%8616%E4%B8%AA%E5%BA%93/</id>
    <published>2020-11-20T05:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.351Z</updated>
    
    <content type="html"><![CDATA[<p>  在实际的项目中，Redis常被用作缓存、分布式锁、消息队列等的解决方案。但是在搭建好Redis服务后，Redis默认创建了<strong>16个数据库（db0~db15）</strong>，而在Redis集群下只有一个<strong>db0数据库</strong>。如下图所示。</p><p><img src="https://i.loli.net/2020/11/20/XL2egauRUC9Wkb8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQyNzEyOQ==,size_16,color_FFFFFF,t_70" alt="redis单机">  <img src="https://i.loli.net/2020/11/20/BiUfXu8aFpwxO2R.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQyNzEyOQ==,size_16,color_FFFFFF,t_70" alt="redis集群"></p><h3 id="一、16个数据库的由来"><a href="#一、16个数据库的由来" class="headerlink" title="一、16个数据库的由来"></a>一、16个数据库的由来</h3><p>  Redis是一个类似于<strong>字典结构</strong>的存储服务器，一个Redis实例提供了<strong>多个用来存储数据的字典</strong>，在客户端可以指定将数据存储于哪个字典中。这与在一个关系数据库实例中创建多个数据库类似，所以，可以将Redis中的每个字典都理解为一个独立的数据库。</p><p><img src="https://i.loli.net/2020/11/20/wzmtKMXQSunWgo8.png" alt="在这里插入图片描述"><br>  我们讲过Redis默认支持16个数据库，这可以通过修改Redis的配置文件/redis/redis.conf中的<strong>databases字段</strong>的值，设置完毕并重启Redis即可完成配置。</p><p><img src="https://i.loli.net/2020/11/20/k7aW1VlCZdRnMgz.jpg" alt="img"><br>  此外，客户端与Redis建立连接之后，默认会选择0号数据库即db0，但可以使用**<code>select</code>命令**更换存储的数据库。</p><p><img src="https://i.loli.net/2020/11/20/SVgpJ6OdNb7Kxfe.png" alt="更换db"></p><p>  也可以通过修改配置文件的方式选择默认数据库。</p><p><img src="https://i.loli.net/2020/11/20/7DMR6zBv4EKaLQc.jpg" alt="配置文件"></p><h3 id="二、正解Redis数据库概念"><a href="#二、正解Redis数据库概念" class="headerlink" title="二、正解Redis数据库概念"></a>二、正解Redis数据库概念</h3><p>  可以看到，Redis的数据库都以<strong>db+编号</strong>的方式命名，这是因为Redis不支持自定义数据库名。开发者则需要自己记录存储的数据与数据库之间的对应关系。此外，<strong>Redis不支持为每个数据库设置不同的访问密码，即客户端要么可以访问全部的数据库，要么所有的数据库都不能被访问。</strong></p><p>  Redis中存在这么一个命令<code>flushall</code>，该命令可以清空当前Redis实例下所有数据库的数据。这与类似于mysql的关系型数据库不同，<strong>关系型数据库的每个数据库常用于存储不同应用程序的数据，且不提供清除当前实例下所有数据库数据的方法。</strong></p><p>  因此，对于Redis来说，用<strong>命名空间</strong>的方式理解Redis提供的<strong>db0~db15数据库</strong>会更合适，且一个Redis实例不适合存储多个应用程序的数据。比如，我们可以这么做：<strong>使用db0数据库存储应用程序在生产环境的数据，用db1数据库存储测试环境的数据。</strong>但是，<strong>不适合用db0数据库存储应用程序A的数据，用db1存储应用程序B的数据。**</strong>不同的应用程序应使用不同的Redis实例。<strong>此外，我们不必担心使用过多的Redis实例造成数据库服务压力过大，因为Redis是非常轻量级的，</strong>一个空的Redis实例占用的内存只有1MB左右。**</p><h3 id="三、集群环境下的Redis实例"><a href="#三、集群环境下的Redis实例" class="headerlink" title="三、集群环境下的Redis实例"></a>三、集群环境下的Redis实例</h3><p>  在单体Redis的情况下可以使用<code>select</code>命令来实现数据库的切换，但在集群环境下，Redis不支持使用<code>select</code>命令来切换数据库，这是因为在集群环境下只有一个<strong>db0数据库</strong>。集群与单体Redis的区别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、key批量操作支持有限：例如mget、mset必须在一个slot；</span><br><span class="line"><span class="number">2</span>、Key事务和Lua支持有限：操作的key必须在一个节点；</span><br><span class="line"><span class="number">3</span>、key是数据分区的最小粒度：不支持bigkey分区；</span><br><span class="line"><span class="number">4</span>、不支持多个数据库：集群模式下只有一个db0；</span><br><span class="line"><span class="number">5</span>、复制只支持一层：不支持树形复制结构。</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ul><li>Redis实例默认创建了16个数据库，且不支持自定义命名，以dbX的方式命名（db0~db15）；</li><li>默认数据库的数量可以在配置文件中修改；</li><li>应以命名空间的方式理解Redis数据库db，<strong>多个应用程序不应使用同一个Redis的不同库，而应一个应用程序对应一个Redis实例，不同的数据库可用于存储不同环境的数据。</strong></li><li><strong>Redis集群下只有db0，不支持多db。</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  在实际的项目中，Redis常被用作缓存、分布式锁、消息队列等的解决方案。但是在搭建好Redis服务后，Redis默认创建了&lt;strong&gt;16个数据库（db0~db15）&lt;/strong&gt;，而在Redis集群下只有一个&lt;strong&gt;db0数据库&lt;/strong&gt;。如下</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka注册指定IP段</title>
    <link href="http://example.com/2020/11/19/Eureka%E6%B3%A8%E5%86%8C%E6%8C%87%E5%AE%9AIP%E6%AE%B5/"/>
    <id>http://example.com/2020/11/19/Eureka%E6%B3%A8%E5%86%8C%E6%8C%87%E5%AE%9AIP%E6%AE%B5/</id>
    <published>2020-11-19T03:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>最近项目在Eureka注册时，发现一个问题：注册的IP地址不是 10.10.3.XXX 的网络IP，而是另外一个网段的地址。</p><p>通过 ipconfig 命令查看本机的IP地址发现，该IP是本机虚拟网卡VMware的地址。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">无线局域网适配器 本地连接* <span class="number">13</span>:</span><br><span class="line"></span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line"></span><br><span class="line">以太网适配器 以太网 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">65</span>b2:b524:<span class="number">664</span>b:c414%<span class="number">13</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">10</span>.<span class="number">10</span>.<span class="number">3</span>.<span class="number">208</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . : <span class="number">10</span>.<span class="number">10</span>.<span class="number">3</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">以太网适配器 VMware Network Adapter VMnet1:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::d86f:a26d:c8f6:<span class="number">7038</span>%<span class="number">3</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192</span>.<span class="number">168</span>.<span class="number">15</span>.<span class="number">1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line"></span><br><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">6415</span>:<span class="number">235</span>:<span class="number">98</span>c4:<span class="number">9</span>ca7%<span class="number">2</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192</span>.<span class="number">168</span>.<span class="number">38</span>.<span class="number">1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></table></figure><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>Eureka管理页面注册列表展示的IP地址非局域网IP地址，是虚拟机的虚拟IP地址</p><h3 id="可能引起的问题"><a href="#可能引起的问题" class="headerlink" title="可能引起的问题"></a>可能引起的问题</h3><p>多人开发时，同事通过Feign调用接口，无法正确匹配IP地址，从而导致接口调用失败。</p><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>通过百度查找，提供了该解决方案：在 yml 文件中添加一下的配置，以达到忽略指定网卡的目的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">ignored-interfaces:</span> <span class="comment">## 忽略网卡</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">VMware.*</span></span><br></pre></td></tr></table></figure><p><strong>可是当我添加该配置后，发现仍不起作用！</strong>页面上显示的instance-id 还是 192.168.38.1 。这就很难受了</p><h2 id="刨根问底"><a href="#刨根问底" class="headerlink" title="刨根问底"></a>刨根问底</h2><p>于是我想能不能跑一跑Spring的启动代码，看看他到底是怎么取IP的。首先从Eureka自动配置类EurekaClientAutoConfiguration入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title">eurekaInstanceConfigBean</span><span class="params">(InetUtils inetUtils,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;</span><br><span class="line">    String hostname = getProperty(<span class="string">&quot;eureka.instance.hostname&quot;</span>);</span><br><span class="line">    <span class="comment">// 是否使用IP地址注册。这里就是从配置文件寻值，没找到就用默认值 false</span></span><br><span class="line">    <span class="keyword">boolean</span> preferIpAddress = Boolean.parseBoolean(getProperty(<span class="string">&quot;eureka.instance.prefer-ip-address&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取配置的IP地址</span></span><br><span class="line">    String ipAddress = getProperty(<span class="string">&quot;eureka.instance.ip-address&quot;</span>);</span><br><span class="line"></span><br><span class="line">    instance.setPreferIpAddress(preferIpAddress);</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(ipAddress)) &#123;</span><br><span class="line">        instance.setIpAddress(ipAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，Eureka并没有自己直接去系统获取IP地址，而是通过Spring的InetUtils类的findFirstNonLoopbackHostInfo来设置IP地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EurekaInstanceConfigBean</span><span class="params">(InetUtils inetUtils)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inetUtils = inetUtils;</span><br><span class="line">    <span class="keyword">this</span>.hostInfo = <span class="keyword">this</span>.inetUtils.findFirstNonLoopbackHostInfo();</span><br><span class="line">    <span class="keyword">this</span>.ipAddress = <span class="keyword">this</span>.hostInfo.getIpAddress();</span><br><span class="line">    <span class="keyword">this</span>.hostname = <span class="keyword">this</span>.hostInfo.getHostname();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看看findFirstNonLoopbackHostInfo()方法的代码。我在本地Debug跑的时候，项目启动该类会被调用两次，一次没有读取配置文件，项目启动Banner也没有打印，第二次配置文件已经读取。启动日志也打印了一部分。这里原因留个坑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">findFirstNonLoopbackAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InetAddress result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lowest = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (Enumeration&lt;NetworkInterface&gt; nics = NetworkInterface</span><br><span class="line">.getNetworkInterfaces(); nics.hasMoreElements();) &#123;</span><br><span class="line">NetworkInterface ifc = nics.nextElement();</span><br><span class="line">                <span class="comment">// 该网络接口是否启用并正在运行。调用的是native方法</span></span><br><span class="line"><span class="keyword">if</span> (ifc.isUp()) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;Testing interface: &quot;</span> + ifc.getDisplayName());</span><br><span class="line"><span class="keyword">if</span> (ifc.getIndex() &lt; lowest || result == <span class="keyword">null</span>) &#123;</span><br><span class="line">lowest = ifc.getIndex();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该网卡名称不在忽略范围内</span></span><br><span class="line"><span class="comment">// @formatter:off</span></span><br><span class="line"><span class="keyword">if</span> (!ignoreInterface(ifc.getDisplayName())) &#123;</span><br><span class="line">                        <span class="comment">// 遍历IP地址</span></span><br><span class="line"><span class="keyword">for</span> (Enumeration&lt;InetAddress&gt; addrs = ifc</span><br><span class="line">.getInetAddresses(); addrs.hasMoreElements();) &#123;</span><br><span class="line">InetAddress address = addrs.nextElement();</span><br><span class="line">                            <span class="comment">// 找到 IPV4 且不是回环地址(127.0.0.1) 且是优先选择的地址</span></span><br><span class="line"><span class="keyword">if</span> (address <span class="keyword">instanceof</span> Inet4Address</span><br><span class="line">&amp;&amp; !address.isLoopbackAddress()</span><br><span class="line">&amp;&amp; isPreferredAddress(address)) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;Found non-loopback interface: &quot;</span></span><br><span class="line">+ ifc.getDisplayName());</span><br><span class="line">                     </span><br><span class="line">result = address;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @formatter:on</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">log.error(<span class="string">&quot;Cannot get first non-loopback address&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> InetAddress.getLocalHost();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Unable to retrieve localhost&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码及注释可以看到，SpringCloud选择IP的原则是：<strong>选择已启动网卡的第一个不在忽略范围且不是回环地址(127.0.0.1)且是优先选择地址的IPV4地址</strong></p><p>那么我们想要重定义其所选的IP地址，就需要从忽略范围 和 是否是优先选择地址来做了。</p><h3 id="判断是否在忽略范围的代码"><a href="#判断是否在忽略范围的代码" class="headerlink" title="判断是否在忽略范围的代码"></a>判断是否在忽略范围的代码</h3><p>由该段代码知，要忽略的网口集合需要从 IgnoredInterfaces 这个属性中获得，那这个属性的值是什么？怎么配置呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** for testing */</span> <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreInterface</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历IgnoredInterfaces属性集合，该集合内是忽略的网口名字的正则表达式形式</span></span><br><span class="line">    <span class="keyword">for</span> (String regex : <span class="keyword">this</span>.properties.getIgnoredInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaceName.matches(regex)) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Ignoring interface: &quot;</span> + interfaceName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否是首选地址的代码"><a href="#判断是否是首选地址的代码" class="headerlink" title="判断是否是首选地址的代码"></a>判断是否是首选地址的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** for testing */</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isPreferredAddress</span><span class="params">(InetAddress address)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果配置了仅使用本地接口，则当该InetAddress是本地站点地址时返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isUseOnlySiteLocalInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> siteLocalAddress = address.isSiteLocalAddress();</span><br><span class="line">        <span class="keyword">if</span> (!siteLocalAddress) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Ignoring address: &quot;</span> + address.getHostAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> siteLocalAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果preferredNetworks列表没有配置，则所有地址返回True</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; preferredNetworks = <span class="keyword">this</span>.properties.getPreferredNetworks();</span><br><span class="line">    <span class="keyword">if</span> (preferredNetworks.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果配置了，则返回符合正则的地址</span></span><br><span class="line">    <span class="keyword">for</span> (String regex : preferredNetworks) &#123;</span><br><span class="line">        <span class="keyword">final</span> String hostAddress = address.getHostAddress();</span><br><span class="line">        <span class="keyword">if</span> (hostAddress.matches(regex) || hostAddress.startsWith(regex)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.trace(<span class="string">&quot;Ignoring address: &quot;</span> + address.getHostAddress());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/19/c67Qf2Zb9OXmqtI.png" alt="断点"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>eureka 显示的 instance-id 有两种值，通过 prefer-ip-address 的值来选择</li></ol><ul><li>ip:端口 true</li><li>hostname 主机名 false(默认)</li></ul><ol><li>当 prefer-ip-address 的值为 true 时，eureka 取这个值：eureka.client.instance-id</li></ol><ul><li>配置文件中的： eureka.client.instance-id 。可以配置成自己手写的值，也可以自动获取，通过 ${spring.cloud.client.ip-address}/{server.port} 来获取。<strong>但是 spring.cloud.client.ip-address 值的取值有一个BUG，Spring 从 InetUtils 获取 ipaddress 作为该值。但是取得是刚刚项目启动时获取的 ipaddress 参数(在加载yml中的配置之前)</strong></li><li>如果没有配置就又取hostname了</li></ul><ol><li>feign / ribbon 调用地址使用的是读取配置文件后的地址。故配置了忽略名单后，显示的虽然错误。但不会影响服务调用。</li></ol><p>所以如果读者想要即不影响调用，又不影响直接看地址需要增加一下配置：</p><p>yml写法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">ignoredInterfaces:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">VMware.*</span> <span class="comment"># 忽略虚拟机网卡</span></span><br><span class="line">      <span class="attr">use-only-site-local-interfaces:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">preferred-networks:</span> <span class="number">10.10</span><span class="string">.*.*</span> <span class="comment"># 优先使用 10.10.*.*</span></span><br></pre></td></tr></table></figure><p>properties写法：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略虚拟机网卡</span></span><br><span class="line"><span class="meta">spring.cloud.inetutils.ignoredInterfaces</span>=<span class="string">VMware.*</span></span><br><span class="line"><span class="meta">spring.cloud.inetutils.use-only-site-local-interfaces</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 优先使用 10.10.*.*</span></span><br><span class="line"><span class="meta">spring.cloud.inetutils.preferred-networks</span>=<span class="string">10.10.*.*</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;最近项目在Eureka注册时，发现一个问题：注册的IP地址不是 10.10.3.XXX 的网络IP，而是另外一个网段的地址。</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>Gas Mask：hosts 文件管理编辑利器</title>
    <link href="http://example.com/2020/11/17/Gas%20Mask%EF%BC%9Ahosts%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8/"/>
    <id>http://example.com/2020/11/17/Gas%20Mask%EF%BC%9Ahosts%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8/</id>
    <published>2020-11-17T03:09:46.000Z</published>
    <updated>2020-12-09T06:19:24.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gas-Mask：hosts-文件管理编辑利器"><a href="#Gas-Mask：hosts-文件管理编辑利器" class="headerlink" title="Gas Mask：hosts 文件管理编辑利器"></a>Gas Mask：hosts 文件管理编辑利器</h2><p>开发过程中，管理 hosts 文件是大部分程序员在切换环境的时候都接触过的事情。管理的方式特别简单，打开编辑器，注释某些行，反注释某些行。这个方式后来有更好的工具替代，就是本文要介绍的 Gas Mask。</p><p>经常地，我们在修改 hosts 的时候，面对一批 ip 容易分不清到底谁是谁，导致最后注释错误。我还因此把本来对开发环境的修改错误地修改到生产环境去了。</p><p>而 Gas Mask 能避免这样的错误。</p><p><img src="https://pic3.zhimg.com/a09acea151fb67a16801b8efe4b7571a_r.jpg" alt="img"></p><p>在这里我要介绍我使用的方式。</p><p>可以创建的类型总共有3种，LOCAL/REMOTE/COMBINED。</p><p>REMOTE ：主要是公共 hosts 文件的共享，一些人科学上网的方式就是通过这个，具体地址网上找一下。REMOTE 这种方式跟 LOCAL 是一样的区别只在于是否本地。</p><p>LOCAL ：如果你有多个环境，那么为每个环境分别创建一份 LOCAL 类型的 hosts。除了跟环境相关的配置，其他都不要放进去。每一个业务就是一份独立的 hosts，这是为了后边的 COMBINED 用法。</p><p>COMBINED：组合多个 hosts 文件为一个。如果没有这个功能，其实单单用 LOCAL 类型的 hosts 是可以的了，但还不够灵活。比方说「科学上网」的 hosts 是无论什么环境下都要配置的，那我不得不在创建每一个新的 hosts 以后，科学上网相关的记录都配置到 这个 hosts 中。</p><h4 id="网盘地址："><a href="#网盘地址：" class="headerlink" title="网盘地址："></a>网盘地址：</h4><blockquote><p>链接：<a href="https://pan.baidu.com/s/120Hn7I6dzVighhhvJWiHNw">https://pan.baidu.com/s/120Hn7I6dzVighhhvJWiHNw</a><br>提取码：eqr2<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Gas-Mask：hosts-文件管理编辑利器&quot;&gt;&lt;a href=&quot;#Gas-Mask：hosts-文件管理编辑利器&quot; class=&quot;headerlink&quot; title=&quot;Gas Mask：hosts 文件管理编辑利器&quot;&gt;&lt;/a&gt;Gas Mask：hosts 文件</summary>
      
    
    
    
    <category term="mac" scheme="http://example.com/categories/mac/"/>
    
    
  </entry>
  
</feed>
