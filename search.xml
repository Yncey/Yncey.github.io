<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis持久化技术及方案选择</title>
      <link href="2021/02/28/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E5%8F%8A%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9/"/>
      <url>2021/02/28/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E5%8F%8A%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis高可用概述"><a href="#一、Redis高可用概述" class="headerlink" title="一、Redis高可用概述"></a>一、Redis高可用概述</h2><p>在介绍Redis高可用之前，先说明一下在Redis的语境中高可用的含义。</p><p>我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。</p><p>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群，下面分别说明它们的作用，以及解决了什么样的问题。</p><ol><li>持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li><li>复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li><li>哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li><li>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li></ol><h2 id="二、Redis持久化概述"><a href="#二、Redis持久化概述" class="headerlink" title="二、Redis持久化概述"></a>二、Redis持久化概述</h2><p>持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。</p><p>Redis持久化分为RDB持久化和AOF持久化<strong>：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）；</strong>由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。</p><p>下面依次介绍RDB持久化和AOF持久化；由于Redis各个版本之间存在差异，如无特殊说明，以Redis3.0为准。</p><h2 id="三、RDB持久化"><a href="#三、RDB持久化" class="headerlink" title="三、RDB持久化"></a>三、RDB持久化</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。</p><h3 id="1-触发条件"><a href="#1-触发条件" class="headerlink" title="1. 触发条件"></a>1. 触发条件</h3><p>RDB持久化的触发分为手动触发和自动触发两种。</p><h4 id="1-手动触发"><a href="#1-手动触发" class="headerlink" title="1) 手动触发"></a>1) 手动触发</h4><p>save命令和bgsave命令都可以生成RDB文件。</p><p>save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。</p><p><img src="https://i.loli.net/2021/02/08/w4qoLGlUxrdZv7z.png" alt="img"></p><p>而bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。</p><p><img src="https://i.loli.net/2021/02/08/xQ9tTWgRHj2knyL.png" alt="img"></p><p>此时服务器执行日志如下：</p><p><img src="https://i.loli.net/2021/02/08/gE17MxbBLYq3UXF.png" alt="img"></p><p>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用；后文中也将只介绍bgsave命令。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化；下面介绍自动触发RDB持久化的条件。</p><h4 id="2-自动触发"><a href="#2-自动触发" class="headerlink" title="2) 自动触发"></a>2) 自动触发</h4><p><strong>save m n</strong></p><p>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。</p><p>例如，查看redis的默认配置文件(Linux下为redis根目录下的redis.conf)，可以看到如下配置信息：</p><p><img src="https://i.loli.net/2021/02/08/mTvXte5SPZQkOGA.png" alt="img"></p><p>其中save 900 1的含义是：当时间到900秒时，如果redis数据发生了至少1次变化，则执行bgsave；save 300 10和save 60 10000同理。当三个save条件满足任意一个时，都会引起bgsave的调用。</p><p><strong>save m n的实现原理</strong></p><p>Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。</p><p>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。</p><p>dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。</p><p>例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。</p><p>lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。</p><p>save m n的原理如下：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：</p><p>（1）当前时间-lastsave &gt; m</p><p>（2）dirty &gt;= n</p><p><strong>save m n 执行日志</strong></p><p>下图是save m n触发bgsave执行时，服务器打印日志的情况：</p><p><img src="https://i.loli.net/2021/02/08/baqo2uk9F1QxHcX.png" alt="img"></p><p><strong>其他自动触发机制</strong></p><p>除了save m n 以外，还有一些其他情况会触发bgsave：</p><ul><li>在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点</li><li>执行shutdown命令时，自动执行rdb持久化，如下图所示：</li></ul><p><img src="https://i.loli.net/2021/02/08/2Q7AwXdpRuVgHU1.png" alt="img"></p><h3 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h3><p>前面介绍了触发bgsave的条件，下面将说明bgsave命令的执行流程，如下图所示：</p><p><img src="https://i.loli.net/2021/02/08/Xm8oTSFleNJkit3.png" alt="img"></p><p>图片中的5个步骤所进行的操作如下：</p><ol><li><p>Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。</p></li><li><p>父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令</p></li><li><p>父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令</p></li><li><p>子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换</p></li><li><p>子进程发送信号给父进程表示完成，父进程更新统计信息</p></li></ol><h3 id="3-RDB文件"><a href="#3-RDB文件" class="headerlink" title="3. RDB文件"></a>3. RDB文件</h3><p>RDB文件是经过压缩的二进制文件，下面介绍关于RDB文件的一些细节。</p><p><strong>存储路径</strong></p><p>RDB文件的存储路径既可以在启动前配置，也可以通过命令动态设定。</p><p>配置：dir配置指定目录，dbfilename指定文件名。默认是Redis根目录下的dump.rdb文件。</p><p>动态设定：Redis启动后也可以动态修改RDB存储路径，在磁盘损害或空间不足时非常有用；执行命令为config set dir {newdir}和config set dbfilename {newFileName}。如下所示(Windows环境)：</p><p><img src="https://i.loli.net/2021/02/08/gCEFArzXeZSmlqh.png" alt="img"></p><p><strong>RDB文件格式</strong></p><p>RDB文件格式如下图所示（图片来源：《Redis设计与实现》）：</p><p><img src="https://i.loli.net/2021/02/08/AKzrGWH4waBNUMo.png" alt="img"></p><p>其中各个字段的含义说明如下：</p><ol><li><p>REDIS：常量，保存着”REDIS”5个字符。</p></li><li><p>db_version：RDB文件的版本号，注意不是Redis的版本号。</p></li><li><p>SELECTDB 0 pairs：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。</p></li><li><p>EOF：常量，标志RDB文件正文内容结束。</p></li><li><p>check_sum：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。</p></li></ol><p><strong>压缩</strong></p><p>Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；可以通过命令关闭：</p><p><img src="https://i.loli.net/2021/02/08/mFq7PCf2Mi6eRYV.png" alt="img"></p><p>需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行。</p><h3 id="4-启动时加载"><a href="#4-启动时加载" class="headerlink" title="4. 启动时加载"></a>4. 启动时加载</h3><p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</p><p>Redis启动日志中可以看到自动载入的执行：</p><p><img src="https://i.loli.net/2021/02/08/Nj9q5XbAmsoyv8E.png" alt="img"></p><p>Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。</p><h3 id="5-RDB常用配置总结"><a href="#5-RDB常用配置总结" class="headerlink" title="5. RDB常用配置总结"></a>5. RDB常用配置总结</h3><p>下面是RDB常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。</p><ul><li>save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式触发</li><li>stop-writes-on-bgsave-error yes：当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no</li><li>rdbcompression yes：是否开启RDB文件压缩</li><li>rdbchecksum yes：是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现</li><li>dbfilename dump.rdb：RDB文件名</li><li>dir ./：RDB文件和AOF文件所在目录</li></ul><h2 id="四、AOF持久化"><a href="#四、AOF持久化" class="headerlink" title="四、AOF持久化"></a>四、AOF持久化</h2><p>RDB持久化是将进程数据写入文件，而AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog）；当Redis重启时再次执行AOF文件中的命令来恢复数据。</p><p>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</p><h3 id="1-开启AOF"><a href="#1-开启AOF" class="headerlink" title="1. 开启AOF"></a>1. 开启AOF</h3><p>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：</p><p>appendonly yes</p><h3 id="2-执行流程-1"><a href="#2-执行流程-1" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h3><p>由于需要记录Redis的每条写命令，因此AOF不需要触发，下面介绍AOF的执行流程。</p><p>AOF的执行流程包括：</p><ul><li>命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；</li><li>文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；</li><li>文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。</li></ul><h4 id="1-命令追加-append"><a href="#1-命令追加-append" class="headerlink" title="1) 命令追加(append)"></a>1) 命令追加(append)</h4><p>Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。</p><p>命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。在AOF文件中，除了用于指定数据库的select命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。</p><h4 id="2-文件写入-write-和文件同步-sync"><a href="#2-文件写入-write-和文件同步-sync" class="headerlink" title="2) 文件写入(write)和文件同步(sync)"></a>2) 文件写入(write)和文件同步(sync)</h4><p>Redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数，说明如下：</p><p>为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。</p><p>AOF缓存区的同步文件策略由参数appendfsync控制，各个值的含义如下：</p><ul><li>always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。</li><li>no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</li><li>everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。<strong>everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置。</strong></li></ul><h4 id="3-文件重写-rewrite"><a href="#3-文件重写-rewrite" class="headerlink" title="3) 文件重写(rewrite)"></a>3) 文件重写(rewrite)</h4><p>随着时间流逝，Redis服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。</p><p>文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，<strong>AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!</strong></p><p>关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。</p><p>文件重写之所以能够压缩AOF文件，原因在于：</p><ul><li>过期的数据不再写入文件</li><li>无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等</li><li>多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。</li></ul><p><img src="https://i.loli.net/2021/02/08/calBL1oQPkfW79E.png" alt="img"></p><p>通过上述内容可以看出，由于重写后AOF执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。</p><p><strong>文件重写的触发</strong></p><p>文件重写的触发，分为手动触发和自动触发：</p><p>手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞。</p><p><img src="https://i.loli.net/2021/02/08/RzcPsOBLnH7TjVp.png" alt="img"></p><p>此时服务器执行日志如下：</p><p><img src="https://i.loli.net/2021/02/08/6hfrCeolpQ7L9is.png" alt="img"></p><p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机。</p><ul><li>auto-aof-rewrite-min-size：执行AOF重写时，文件的最小体积，默认值为64MB。</li><li>auto-aof-rewrite-percentage：执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值。</li></ul><p>其中，参数可以通过config get命令查看：</p><p><img src="https://i.loli.net/2021/02/08/FXUKOlEMStT9C6e.png" alt="img"></p><p>状态可以通过info persistence查看：</p><p><img src="https://i.loli.net/2021/02/08/iLDT68kwaFybRKY.png" alt="img"></p><p>只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。</p><p>自动触发bgrewriteaof时，可以看到服务器日志如下：</p><p><img src="https://i.loli.net/2021/02/08/MlDFbEiWnGI1sVU.png" alt="img"></p><p><strong>文件重写的流程</strong></p><p>文件重写流程如下图所示：</p><p><img src="https://i.loli.net/2021/02/08/Sk5R1OdgKBmzHV8.png" alt="img"></p><p>关于文件重写的流程，有两点需要特别注意：(1)重写由父进程fork子进程进行；(2)重写期间Redis执行的写命令，需要追加到新的AOF文件中，为此Redis引入了aof_rewrite_buf缓存。</p><p>对照上图，文件重写的流程如下：</p><ol><li><p>Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。</p></li><li><p>父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。</p></li></ol><p>3.1) 父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。<strong>Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。</strong></p><p>3.2) 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。<strong>由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。</strong></p><ol start="4"><li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。</li></ol><p>5.1) 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。</p><p>5.2) 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。</p><p>5.3) 使用新的AOF文件替换老文件，完成AOF重写。</p><h3 id="3-启动时加载"><a href="#3-启动时加载" class="headerlink" title="3. 启动时加载"></a>3. 启动时加载</h3><p>前面提到过，当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。</p><p>当AOF开启，且AOF文件存在时，Redis启动日志：</p><p><img src="https://i.loli.net/2021/02/08/aYWdb7wCMGgi9hc.png" alt="img"></p><p>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载(更早的一些版本可能会加载，但3.0不会)，Redis启动日志如下：</p><p><img src="https://i.loli.net/2021/02/08/ZXkEzJcN6i9WDjQ.png" alt="img"></p><p><strong>文件校验</strong></p><p>与载入RDB文件类似，Redis载入AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。但如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且aof-load-truncated参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。aof-load-truncated参数默认是开启的：</p><p><img src="https://i.loli.net/2021/02/08/KRw3GbjsFH7LEay.png" alt="img"></p><p><strong>伪客户端</strong></p><p>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时命令是直接从文件中读取的，并不是由客户端发送；因此Redis服务器在载入AOF文件之前，会创建一个没有网络连接的客户端，之后用它来执行AOF文件中的命令，命令执行的效果与带网络连接的客户端完全一样。</p><h3 id="4-AOF常用配置总结"><a href="#4-AOF常用配置总结" class="headerlink" title="4. AOF常用配置总结"></a>4. AOF常用配置总结</h3><p>下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。</p><ul><li>appendonly no：是否开启AOF</li><li>appendfilename “appendonly.aof”：AOF文件名</li><li>dir ./：RDB文件和AOF文件所在目录</li><li>appendfsync everysec：fsync持久化策略</li><li>no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡</li><li>auto-aof-rewrite-percentage 100：文件重写触发条件之一</li><li>auto-aof-rewrite-min-size 64mb：文件重写触发提交之一</li><li>aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件</li></ul><h2 id="五、方案选择与常见问题"><a href="#五、方案选择与常见问题" class="headerlink" title="五、方案选择与常见问题"></a>五、方案选择与常见问题</h2><p>前面介绍了RDB和AOF两种持久化方案的细节，下面介绍RDB和AOF的特点、如何选择持久化方案，以及在持久化过程中常遇到的问题等。</p><h3 id="1-RDB和AOF的优缺点"><a href="#1-RDB和AOF的优缺点" class="headerlink" title="1. RDB和AOF的优缺点"></a>1. RDB和AOF的优缺点</h3><p>RDB和AOF各有优缺点：</p><p><strong>RDB持久化</strong></p><p>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</p><p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p><p><strong>AOF持久化</strong></p><p>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p><h3 id="2-持久化策略选择"><a href="#2-持久化策略选择" class="headerlink" title="2. 持久化策略选择"></a>2. 持久化策略选择</h3><p>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。</p><p>在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。</p><p>下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。</p><p>（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。</p><p>（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。</p><p>（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</p><p>在这种情况下，一种可行的做法是：</p><p>master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好</p><p>slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。</p><p>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</p><ul><li>master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。</li><li>master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。</li></ul><p>（4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。</p><h3 id="3-fork阻塞：CPU的阻塞"><a href="#3-fork阻塞：CPU的阻塞" class="headerlink" title="3. fork阻塞：CPU的阻塞"></a>3. fork阻塞：CPU的阻塞</h3><p>在Redis的实践中，众多因素限制了Redis单机的内存不能过大，例如：</p><ul><li>当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；</li><li>当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；</li><li>以及持久化过程中的fork操作，下面详细说明。</li></ul><p>首先说明一下fork操作：</p><p>父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。</p><p>虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。</p><p>在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。</p><p>对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。</p><p>为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。</p><h3 id="4-AOF追加阻塞：硬盘的阻塞"><a href="#4-AOF追加阻塞：硬盘的阻塞" class="headerlink" title="4. AOF追加阻塞：硬盘的阻塞"></a>4. AOF追加阻塞：硬盘的阻塞</h3><p>前面提到过，在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。</p><p>这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。</p><p>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</p><p>AOF追加阻塞问题定位的方法：</p><p>（1）监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。</p><p>（2）AOF阻塞时的Redis日志：</p><p>Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.</p><p>（3）如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。</p><h3 id="5-info命令与持久化"><a href="#5-info命令与持久化" class="headerlink" title="5. info命令与持久化"></a>5. info命令与持久化</h3><p>前面提到了一些通过info命令查看持久化相关状态的方法，下面来总结一下。</p><p>（1）info Persistence</p><p>执行结果如下：</p><p><img src="https://i.loli.net/2021/02/08/A9ury3pokzUKB6v.png" alt="img"></p><p>其中比较重要的包括：</p><ul><li>rdb_last_bgsave_status:上次bgsave 执行结果，可以用于发现bgsave错误</li><li>rdb_last_bgsave_time_sec:上次bgsave执行时间（单位是s），可以用于发现bgsave是否耗时过长</li><li>aof_enabled:AOF是否开启</li><li>aof_last_rewrite_time_sec: 上次文件重写执行时间（单位是s），可以用于发现文件重写是否耗时过长</li><li>aof_last_bgrewrite_status: 上次bgrewrite执行结果，可以用于发现bgrewrite错误</li><li>aof_buffer_length和aof_rewrite_buffer_length:aof缓存区大小和aof重写缓冲区大小</li><li>aof_delayed_fsync:AOF追加阻塞情况的统计</li></ul><p>（2）info stats</p><p>其中与持久化关系较大的是：latest_fork_usec，代表上次fork耗时，可以参见前面的讨论。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文主要内容可以总结如下：</p><p>1、持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。</p><p>2、RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。</p><p>3、AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。</p><p>4、一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞、AOF追加阻塞等。</p><blockquote><p>参考链接：<a href="https://www.cnblogs.com/kismetv/p/9137897.html">https://www.cnblogs.com/kismetv/p/9137897.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>刷新邻接页（Flush Neighbor Page）</title>
      <link href="2021/01/22/5.nnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%88%B7%E6%96%B0%E9%82%BB%E6%8E%A5%E9%A1%B5%EF%BC%88Flush%20Neighbor%20Page%EF%BC%89/"/>
      <url>2021/01/22/5.nnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%88%B7%E6%96%B0%E9%82%BB%E6%8E%A5%E9%A1%B5%EF%BC%88Flush%20Neighbor%20Page%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h2 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h2><p>InnoDB存储引擎还提供了Flush Neighbor Page(刷新邻接页)的特性。其工作原理为：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区(extent)的所有页，如果是脏页，那么一起进行刷新。<br>有两个问题：<br>1）是不是可能将不怎么脏的页进行了写入，而该页之后又会 很快变成脏页？<br>2）固态硬盘有着较高的IOPS，是否还需要这个特性？<br>所以，InnoDB1.2.x版本开始提供了参数innodb_flush_neighbors，用来控制是否启用该特性。对于传统机械硬盘建议启用该特性，而对于固态硬盘有着较高的IOPS性能的磁盘，则建议将该参数设置为0，即关闭该特性。</p><h2 id="启动、关闭和恢复"><a href="#启动、关闭和恢复" class="headerlink" title="启动、关闭和恢复"></a>启动、关闭和恢复</h2><p>InnoDB存储引擎是MySql数据库的存储引擎之一，因此InnoDB存储引擎的启动和关闭，或者说MySql数据库服务器的启动和关闭过程对InnoDB存储引擎的处理过程。<br>在关闭时，参数 innodb_fast_shutdown影响着表的InnoDB存储引擎的行为，该参数可以为0，1，2，默认值为1；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;innodb_fast_shutdown&#39;;  </span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| innodb_fast_shutdown | 1     |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>（1）为0时，表示在MySql数据库关闭时，InnoDB需要完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数设置为0，然后再关闭数据库。<br>（2）1是参数 innodb_fast_shutdown的默认值，表示不需要完成上述的full purge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。<br>（3）2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySql数据库启动时，会进行恢复操作。</p><p>当正常关闭MySql数据库时，下次的启动应该会非常正常。但是如果没有正常地关闭数据库，如用kill命令关闭数据库，在MySql数据库运行中重启了服务器，或者在关闭数据库时，将参数innodb_fast_shutdown设置为了2，下次MySql数据库启动时都会对InnoDB存储引擎的表进行恢复操作。</p><p>参数innodb_force_recovery影响了整个InnoDB存储引擎恢复的状态。该参数默认值为0，表示当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySql数据库可能发生宕机（crash)，并把错误写入错误日志中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;innodb_force_recovery&#39;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_force_recovery | 0     |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>某些情况下，可能并不需要进行完整的恢复操作，因为用户自己知道怎么进行恢复。比如在对一个表进行alter table操作时发生了意外，数据库重启时会对InnoDB表进行回滚操作，对于一个大表来说这需要很长时间，可能是几个小时。这时用户可以自行进行恢复，如可以把表删除，从备份中重新导入数据到表，可能这些操作的速度要远远快于回滚操作。</p><p>参数innodb_force_recovery还可以设置为6个非零值：1-6，大的数字表示包含了前面所有小数字表示的影响。具体情况如下：<br>1：忽略检查到的corrupt页。<br>2：阻止Master Thread线程的运行，如Master Thread线程需要进行full purge，而这会导致crash。<br>3：不进行事务的回滚操作。<br>4：不进行插入缓冲的合并操作。<br>5：不查看撤销日志（Undo Log），InnoDB存储引擎会将未提交的事务视为已提交。<br>6：不进行前滚的操作。</p><p>参数innodb_force_recovery的值大于0时，可以对表进行select,create和drop操作，但是insert,update和delete这类DML操作是不允许的。</p><blockquote><p>参考链接：<a href="https://blog.csdn.net/linux_ever/article/details/62045117">https://blog.csdn.net/linux_ever/article/details/62045117</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DB死锁排查分析与思考</title>
      <link href="2021/01/20/DB%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/"/>
      <url>2021/01/20/DB%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一、出现死锁的当前场景"><a href="#一、出现死锁的当前场景" class="headerlink" title="一、出现死锁的当前场景"></a>一、出现死锁的当前场景</h2><p>在测试环境上做业务流程的联调验证自测，在跑自测用例时，突然发现在多线程并发情况下有数据未从业务表中删除完成，通过Spring Boot工程打印出的Log日志中可以看到出现了死锁问题。下面将先给大家还原下死锁的当前场景，然后逐步分析和使用正确方法排查死锁的原因。</p><h3 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;hw_band_width_bill_record&#96; (</span><br><span class="line"></span><br><span class="line">&#96;ID&#96; bigint(20) unsigned NOT NULLAUTO_INCREMENT COMMENT &#39;主键id,自增&#39;,</span><br><span class="line"></span><br><span class="line">&#96;CUSTOMER_ID&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;USER_ID&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;CLOUD_SER_TYPE_CODE&#96; varchar(50) NOT NULL COMMENT……,</span><br><span class="line"></span><br><span class="line">&#96;RES_TYPE_CODE&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;RES_SPEC_CODE&#96; varchar(50) NOT NULL COMMENT ……,</span><br><span class="line"></span><br><span class="line">&#96;RES_INSTANCE_ID&#96; varchar(50) DEFAULT NULL COMMENT……,</span><br><span class="line"></span><br><span class="line">&#96;RES_ATTR_VALUES&#96; varchar(50) DEFAULT NULLCOMMENT ……,</span><br><span class="line"></span><br><span class="line">-- 限于篇幅问题这里省略该数据表的其他字段</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (&#96;ID&#96;),</span><br><span class="line"></span><br><span class="line">KEY&#96;custId_product_res_type_spec_index&#96;(&#96;CUSTOMER_ID&#96;,&#96;RES_TYPE_CODE&#96;,&#96;RES_SPEC_CODE&#96;,&#96;RES_ATTR_VALUES&#96;) USING BTREE)</span><br><span class="line"></span><br><span class="line">ENGINE&#x3D;InnoDBAUTO_INCREMENT&#x3D;54 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;……&#39;</span><br></pre></td></tr></table></figure><p>其中，<code>ID</code>为主键索引，<code>CUSTOMER_ID</code>,<code>RES_TYPE_CODE</code>,<code>RES_SPEC_CODE</code>,<code>RES_ATTR_VALUES</code>等字段组成了非唯一的普通BTREE索引。</p><h3 id="业务库的事务隔离级别"><a href="#业务库的事务隔离级别" class="headerlink" title="业务库的事务隔离级别"></a>业务库的事务隔离级别</h3><p>可以通过<code>SELECT @@tx_isolation</code>的SQL来查询当前数据库的事务隔离级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT @@tx_isolation;</span><br><span class="line"></span><br><span class="line">+-----------------+</span><br><span class="line">|@@tx_isolation|</span><br><span class="line">+-----------------+</span><br><span class="line">|REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"></span><br><span class="line">1row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="业务应用工程的Log日志"><a href="#业务应用工程的Log日志" class="headerlink" title="业务应用工程的Log日志"></a>业务应用工程的Log日志</h3><p>当业务应用工程出现异常或者报错时，绝大部分童鞋的第一反应肯定都是去工程对应的Log日志里面去排查定位问题。对应于该死锁问题Case的工程Log日志如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.DeadlockLoserDataAccessException:###Error updating database.Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException:Deadlock found when trying to get lock; try restarting transaction###The error may involveHwBandWidthBillRecordMapper.deleteResBwBillsByIdAndSpecValues-Inline</span><br><span class="line"></span><br><span class="line">The error occurred while setting parameters</span><br><span class="line"></span><br><span class="line">SQL: delete from hw_band_width_bill_recordwhere CUSTOMER_ID = ?and CLOUD_SER_TYPE_CODE = ?and RES_TYPE_CODE = ?and RES_SPEC_CODE = ?and RES_ATTR_VALUES = ?</span><br><span class="line"></span><br><span class="line">Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException:Deadlock found when trying to get lock; try restarting transaction; SQL []; Deadlock</span><br><span class="line"></span><br><span class="line">found when trying to get lock; try restarting transaction; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock;try restarting transaction (限于篇幅问题这里省略了部分日志)</span><br><span class="line">Caused by:com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlockfound when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>从以上打印的堆栈日志里面可以清楚的发现业务工程代码在多线程并发的环境下执行了Delete SQL语句后出现了死锁异常。不过，仅仅通过上述日志还不足以清楚地分析和查明出现死锁异常的根本原因，那怎么办？下面将通过MySQL的InnoDB的状态日志进行进一步的深入分析。</p><h3 id="MySQL数据库死锁日志信息"><a href="#MySQL数据库死锁日志信息" class="headerlink" title="MySQL数据库死锁日志信息"></a>MySQL数据库死锁日志信息</h3><p>可能很多做过开发的童鞋都没有自己登录过数据库服务器，排查过MySQL的InnoDB Status的状态日志信息来深入分析死锁问题。这里，我们可以先进入测试/线上环境数据库虚拟机的数据库安装bin目录下，通过“mysql-h localhost -P 3306 -u test -p”命令来连接登录。然后使用“SHOW ENGINE INNODB STATUS”命令查询数据库的最近一次死锁日志信息。这里需要注意的是，该命令只能查看到最近一条死锁日志信息，如果想看到多条历史死锁可以在MySQL中把死锁信息打印到错误日志里，开启如下变量即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_print_all_deadlocks&#x3D; 1；</span><br><span class="line">本Case中的死锁日志信息如下：</span><br><span class="line"></span><br><span class="line">\------------------------</span><br><span class="line">LATESTDETECTED DEADLOCK</span><br><span class="line">\------------------------</span><br><span class="line"></span><br><span class="line">2017-12-0519:46:52 7f6d3e588700</span><br><span class="line"></span><br><span class="line">(1) TRANSACTION: TRANSACTION10375675, ACTIVE 0 sec fetching rows mysqltables in use 1, locked 1 LOCKWAIT 4 lock struct(s), heap size 1184, 2 row lock(s), undo log entries 4</span><br><span class="line"></span><br><span class="line">MySQLthread id 550477, OS thread handle 0x7f6db6ab8700, query id 33896336 10.129.3.1test updating</span><br><span class="line"></span><br><span class="line">deletefrom hw_band_width_bill_record where CUSTOMER_ID &#x3D;&#39;0314e4814d014eaabf4ab09f7fa97fed&#39; and CLOUD_SER_TYPE_CODE &#x3D;&#39;hws.service.type.vpc&#39; and RES_TYPE_CODE &#x3D;&#39;hws.resource.type.bandwidth&#39; and RES_SPEC_CODE &#x3D; &#39;19_bgp&#39; and RES_ATTR_VALUES &#x3D;&#39;&#123;&quot;specSize&quot;:1&#125;&#39; </span><br><span class="line"></span><br><span class="line">(1) WAITING FOR THIS LOCK TO BE GRANTED: RECORDLOCKS space id 1369 page no 3 n bits 104 index &#96;PRIMARY&#96; of table&#96;res_hw_cloud_bill&#96;.&#96;hw_band_width_bill_record&#96; trx id 10375675 lock_mode Xlocks rec but not gap waiting</span><br><span class="line"></span><br><span class="line">(2) TRANSACTION:</span><br><span class="line"></span><br><span class="line">TRANSACTION10375676, ACTIVE 0 sec starting index read, thread declared inside InnoDB 5000 mysqltables in use 1, locked 1 4lock struct(s), heap size 1184, 3 row lock(s), undo log entries 5 MySQLthread id 550478, OS thread handle 0x7f6d3e588700, query id 33896338 10.129.3.1test updating </span><br><span class="line"></span><br><span class="line">deletefrom hw_band_width_bill_record where CUSTOMER_ID &#x3D; &#39;0314e4814d014eaabf4ab09f7fa97fed&#39; and CLOUD_SER_TYPE_CODE &#x3D;&#39;hws.service.type.vpc&#39; and RES_TYPE_CODE &#x3D;&#39;hws.resource.type.bandwidth&#39; and RES_SPEC_CODE &#x3D; &#39;19_bgp&#39; and RES_ATTR_VALUES &#x3D;&#39;&#123;&quot;specSize&quot;:6&#125;&#39;</span><br><span class="line"></span><br><span class="line">(2) HOLDS THE LOCK(S):</span><br><span class="line"></span><br><span class="line">RECORDLOCKS space id 1369 page no 3 n bits 104 index &#96;PRIMARY&#96; of table&#96;res_hw_cloud_bill&#96;.&#96;hw_band_width_bill_record&#96; trx id 10375676 lock_mode Xlocks rec but not gap</span><br><span class="line"></span><br><span class="line">(2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">RECORDLOCKS space id 1369 page no 3 n bits 104 index &#96;PRIMARY&#96; of table&#96;res_hw_cloud_bill&#96;.&#96;hw_band_width_bill_record&#96; trx id 10375676 lock_mode Xlocks rec but not gap waiting </span><br><span class="line"></span><br><span class="line">WE ROLL BACK TRANSACTION (1)</span><br><span class="line"></span><br><span class="line">\------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">\------------</span><br></pre></td></tr></table></figure><p>从上面打印的这段日志中，我们可以进行一定的初步分析。从这段日志里可以看到，<code>TRANSACTION (1)</code>和<code>TRANSACTION (2)</code>分别持有一定数量的行锁，然后又等待对方的锁，最后MySQL检测到Deadlock，然后选择回滚了<code>TRANSACTION (1)</code>：InnoDB目前处理死锁的方法是将持有最少行级排他锁的事务进行回滚。</p><h2 id="二、对于业务库死锁的深入分析"><a href="#二、对于业务库死锁的深入分析" class="headerlink" title="二、对于业务库死锁的深入分析"></a>二、对于业务库死锁的深入分析</h2><p>在进一步深入分析MySQL的死锁日志之前有必要先了解下MySQL数据库的MVCC机制、锁的概念和事务隔离级别。</p><h3 id="MySQL-InnoDB的MVCC机制与锁的模型概念"><a href="#MySQL-InnoDB的MVCC机制与锁的模型概念" class="headerlink" title="MySQL InnoDB的MVCC机制与锁的模型概念"></a>MySQL InnoDB的MVCC机制与锁的模型概念</h3><p>MySQL InnoDB存储引擎，实现了基于多版本的并发控制协议—MVCC (Multi-Version Concurrency Control)。InnoDB存储引擎MVCC机制的优点可以总结为，“读不加锁，读写不冲突”。这在读多写少的业务应用中，读写不冲突是非常重要的，极大的增加了系统的并发度和解决各种性能问题。在InnoDB中常见的几种锁模型如下：</p><p>（1）LOCK_ORDINARY[next_key_lock]，默认是LOCK_ORDINARY，即next-keylock，锁住行及其前面的间隙，其为行级记录锁和间隙锁的结合，用于解决幻读的问题。</p><p>（2）LOCK_GAP：间隙锁，锁住行以前的间隙，不锁住本行。</p><p>（3）LOCK_REC_NOT_GAP：行级锁，锁住行而不锁住任何间隙。</p><p>（4）LOCK_INSERT_INTENTION：插入意向锁，如果插入的记录在某个已经锁定的间隙内为这个锁。</p><p>因此在InnoDB中，读操作大致可以概括为两类：快照读(snapshot read)与当前读(current read)。快照读，读取的是记录的可见版本(有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>一般来说，简单的Select SQL语句都属于快照读，例如<code>select * from where……</code></p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>对于“insert/delete/update”等增删改的SQL语句，属于当前读，需要加锁。例如如下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure><h3 id="说说数据库的隔离级别"><a href="#说说数据库的隔离级别" class="headerlink" title="说说数据库的隔离级别"></a>说说数据库的隔离级别</h3><p>数据库的事务隔离级别<code>Isolation Level</code>，是数据库的一个关键特性。相信对数据库原理有所了解的朋友，一定都对4种隔离级别：<code>Read Uncommited</code>，<code>Read Committed</code>，<code>Repeatable Read</code>，<code>Serializable</code>有了比较深入的认识。这里就不再对这4种隔离级别的定义进行详细的阐述了，而是主要跟大家介绍下在MySQL InnoDB存储引擎中对于上述的“当前读”，在这四种不同的隔离级别情况下加锁情况有何区别？（一般“快照读”可以忽略，基本一样的）</p><h4 id="1-Read-Uncommited（未提交读）"><a href="#1-Read-Uncommited（未提交读）" class="headerlink" title="1. Read Uncommited（未提交读）"></a>1. Read Uncommited（未提交读）</h4><p>在该级别下，可以读取未提交记录。此隔离级别，一般不太会使用。</p><h4 id="2-Read-Committed（提交读）"><a href="#2-Read-Committed（提交读）" class="headerlink" title="2. Read Committed（提交读）"></a>2. Read Committed（提交读）</h4><p>在该级别下，针对“当前读”，RC隔离级别保证对读取到的记录加锁(记录锁)，而不会在记录之间加间隙锁，允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果，允许不可重复读。</p><h4 id="3-Repeatable-Read（可重复读）"><a href="#3-Repeatable-Read（可重复读）" class="headerlink" title="3. Repeatable Read（可重复读）"></a>3. Repeatable Read（可重复读）</h4><p>在该级别下，针对“当前读”，RR隔离级别保证对读取到的记录加锁(记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入(间隙锁，但是在唯一索引和非唯一索引条件下还是有一定区别的)，解决了不可重复读的问题，但可能存在幻读（幻读可以通过Next-Key锁解决）。</p><h4 id="4-Serializable（序列化）"><a href="#4-Serializable（序列化）" class="headerlink" title="4. Serializable（序列化）"></a>4. Serializable（序列化）</h4><p>在该级别下，InnoDB隐式将全部读操作视为“当前读”，并且要求事务序列化一个接一个执行。因此，并发度急剧下降，一般情况下也不太会使用该隔离级别。</p><h3 id="分析死锁日志信息与降低死锁的方法"><a href="#分析死锁日志信息与降低死锁的方法" class="headerlink" title="分析死锁日志信息与降低死锁的方法"></a>分析死锁日志信息与降低死锁的方法</h3><p>通过上文的初步分析和对MySQL InnoDB死锁的基本模型/DB事务隔离级别的介绍，现在再回过头来看下本Case中的死锁日志信息，应该就会有一些相对深刻的理解了。下面将进一步给大家做更深入的分析，在篇幅的最后给出自己总结的一些降低死锁发生频率的大致方法。</p><h4 id="1-死锁日志中信息提取"><a href="#1-死锁日志中信息提取" class="headerlink" title="1. 死锁日志中信息提取"></a>1. 死锁日志中信息提取</h4><p>TRX1:<code>10375675</code>(出发死锁权重回滚)</p><p>LOCK HOLD:没有提供该事务获取到的锁</p><p>LOCKWAIT:</p><table><thead><tr><th>表</th><th>索引</th><th>锁模式</th><th>记录</th></tr></thead><tbody><tr><td>hw_band_width_bill_record</td><td>PRIMARY</td><td>LOCKX|LOCK_REC_NOT_GAP</td><td>space id1369 page no 3 n bits 104</td></tr></tbody></table><p>锁的信息：该事务总共有2个行锁，持有1个行锁，另外一个1锁处于锁等待状态</p><p> 当前发生死锁的SQL语句：<code>delete from hw_band_width_bill_record where CUSTOMER_ID = &#39;0314e4814d014eaabf4ab09f7fa97fed&#39; andCLOUD_SER_TYPE_CODE = &#39;hws.service.type.vpc&#39; andRES_TYPE_CODE = &#39;hws.resource.type.bandwidth&#39; andRES_SPEC_CODE = &#39;19_bgp&#39; andRES_ATTR_VALUES = &#39;&#123;&quot;specSize&quot;:1&#125;&#39;</code></p><p>TRX2:<code>10375676</code></p><p>LOCK HOLD:该事务持有锁的大致信息（锁的模式为：LOCK X|LOCK_REC_NOT_GAP）LOCKWAIT:</p><p>LOCKWAIT:</p><table><thead><tr><th>表</th><th>索引</th><th>锁模式</th><th>记录</th></tr></thead><tbody><tr><td>hw_band_width_bill_record</td><td>PRIMARY</td><td>LOCKX|LOCK_REC_NOT_GAP</td><td>space id 1369 page no 3 n bits 104</td></tr></tbody></table><p>锁的信息：该事务总共有3个行锁，持有2个行锁，另外一个行锁处于锁等待状态</p><p> 当前发生死锁的SQL语句：<code>delete from hw_band_width_bill_record where CUSTOMER_ID =&#39;0314e4814d014eaabf4ab09f7fa97fed&#39; and CLOUD_SER_TYPE_CODE =&#39;hws.service.type.vpc&#39; and RES_TYPE_CODE =&#39;hws.resource.type.bandwidth&#39; and RES_SPEC_CODE = &#39;19_bgp&#39; and RES_ATTR_VALUES =&#39;&#123;&quot;specSize&quot;:6&#125;&#39;</code></p><p>从以上MySQL InnoDB死锁日志的提取信息中即可看到，事务1和事务2有分别在等待对方的锁释放，形成了一个环，因此产生了数据库的死锁。</p><h4 id="2-InnoDB行锁难道锁的不只是一行？"><a href="#2-InnoDB行锁难道锁的不只是一行？" class="headerlink" title="2. InnoDB行锁难道锁的不只是一行？"></a>2. InnoDB行锁难道锁的不只是一行？</h4><p>由于本Case中所建的数据库表是用InnoDB引擎的，InnoDB支持行锁和表锁。而InnoDB行锁的原理是通过给索引上的索引项加锁来实现的。而这一点MySQL与Oracle数据库有差别，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点表示：只有通过索引条件检索数据，InnoDB才使用行级锁。如果未走到索引上，InnoDB将使用表锁，会把执行SQL语句中所有扫描过的行都锁定（这里需要注意的是，如果在<code>RR</code>事务隔离级别下且索引为非唯一索引，不仅会对数据表中的每一行加上<code>LOCK_REC_NOT_GAP</code>的行锁，而且还会两数据行的间隙加上<code>LOCK_GAP</code>间隙锁）。在实际的业务应用开发中，要特别注意InnoDB行锁的这一特性，否则可能导致大量的锁冲突，从而影响系统并发性能。由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁。所以虽然是访问不同行的记录，但是如果是使用相同的索引键，也同样会出现锁冲突的。当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。</p><p>下面可以先看下在该Case中，我们业务表索引的情况。如下图可以看到执行的Delete SQL语句走的是范围扫描，未正确走到建立的索引上（对于如何正确建立索引的问题可以看下之间写的《大型分布式业务平台数据库常用优化方法（上）》篇，该篇幅介绍索引的原理和如何正确使用索引）</p><p><img src="https://i.loli.net/2021/01/20/JVRcB5dMKy9aozw.png" alt="img"></p><p>了解MySQL InnoDB的加锁原理和如何正确加索引后，只要调整下创建索引的字段（即为创建索引使用上图中的where条件的5个字段，然后执行Delete SQL语句即可实现覆盖索引，MySQL InnoDB加的锁为对应的行锁和行之间的GAP锁）即可让咱们的Delete SQL语句精确走到索引以缓解死锁的问题。实际上，我再更新索引后，死锁问题也确实得到了解决。</p><h4 id="3-MySQL-InnoDB锁与索引-隔离级别的关系"><a href="#3-MySQL-InnoDB锁与索引-隔离级别的关系" class="headerlink" title="3. MySQL InnoDB锁与索引/隔离级别的关系"></a>3. MySQL InnoDB锁与索引/隔离级别的关系</h4><p>从上述篇幅中可以得到的结论是，“InnoDB行锁的原理是通过给索引上的索引项加锁来实现”，我们知道InnoDB对于主键使用了聚簇索引，这是一种数据存储方式，表数据是和主键一起存储，主键索引的叶结点存储行数据。对于普通索引，其叶子节点存储的是主键值。相信仔细阅读了上面篇幅的同学，对执行未正确落到索引的“当前读”SQL，InnoDB引擎都会加表锁的这一行为比较熟悉，因此这里不再赘述业务表无索引这一情况。这一节将通过2个小例子，来进一步阐述大家，在InnoDB引擎中可能不太会被关注到的锁与索引/隔离级别的两种关系。</p><h5 id="3-1-非唯一索引-RC隔离级别"><a href="#3-1-非唯一索引-RC隔离级别" class="headerlink" title="3.1 非唯一索引+RC隔离级别"></a>3.1 非唯一索引+<code>RC</code>隔离级别</h5><p>在下面第一个的实例中，假设数据库的隔离级别为Read Committed隔离级别，表为table1(表字段由<code>id</code>、<code>token</code>和<code>message</code>组成，其中id字段为自增的主键，在token字段上建了一个非唯一索引)，如果此时执行<code>delete from table1 where token = ‘asd’</code>，那么加锁的情况会怎么样呢？先来看下面这幅图：</p><p><img src="https://i.loli.net/2021/01/20/q4DwFd8jQ2AIkaW.png" alt="img"></p><p>可以看到，由于token列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p><h5 id="3-2-非唯一索引-RR隔离级别"><a href="#3-2-非唯一索引-RR隔离级别" class="headerlink" title="3.2 非唯一索引+RR隔离级别"></a>3.2 非唯一索引+<code>RR</code>隔离级别</h5><p>在接下来的第二个实例中，假设将原来数据库的隔离级别为由上面的RC级别改为，Repeatable Read隔离级别，表table1字段和索引均不变(表字段由<code>id</code>、<code>token</code>和<code>message</code>组成，其中id字段为自增的主键，在token字段上建了一个非唯一索引)，如果此时仍然执行<code>delete from table1 where token = ‘asd’</code>，那么最后的加锁行为会怎么样的呢？可以先来看下下面这幅图：</p><p><img src="https://i.loli.net/2021/01/20/ujm1E68Qdg3nphb.png" alt="img"></p><p>在上图中，相对于前面的<code>Read Committed</code>级别下token非唯一索引条件]看似相同，其实却有很大的区别。主要区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来不是加在记录上的，是加载两条记录之间的位置。这里的GAP锁，就是在RR隔离级别下，相对于RC隔离级别，不会出现的不可重复读的关键。确实，这个GAP锁，锁住的位置，也不是记录本身，而是两条记录之间的间隙。所谓不可重复读，就是同一个事务，连续做两次当前读 (例如：<code>select * from table1 where token = ‘asd’ for update;</code>，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 。然而在RR级别下，并不能解决幻影读的问题。在标准的数据库事务隔离级别中，幻读是由更高的隔离级别 SERIALIZABLE 解决的，但是它也可以通过上文提到过的MySQL的 <code>Next-Key</code> 锁解决。</p><p>因此，在RR隔离级别下，token列上有一个非唯一索引，对应SQL：<code>delete from table1 where token = ‘asd’;</code>首先，通过token索引定位到第一条满足查询条件的记录，先在记录上加X锁，在数据行之间的间隙加上GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录为止，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p><h4 id="4-如何降低发生MySQL-InnoDB死锁频率"><a href="#4-如何降低发生MySQL-InnoDB死锁频率" class="headerlink" title="4. 如何降低发生MySQL InnoDB死锁频率"></a>4. 如何降低发生MySQL InnoDB死锁频率</h4><p>DB死锁在行锁及事务场景下很难完全消除，但可以通过表设计和SQL调整等措施减少锁冲突和死锁，下面列举了一些降低死锁发生的主要方法：</p><p>a. 尽量使用较低的隔离级别，比如如果发生了GAP间隙锁，可以尝试把DB的事务隔离级别调整成为RC(read committed)级别来避免。当然在RC的隔离级别下需要考虑业务是否能够接受“不可重复读”的问题；</p><p>b. 在业务上线之前精心设计并核查下业务表上创建的索引。业务工程DAO层中的SQL语句尽量使用索引访问数据（如果对于自己的业务SQL不确定，可以使用<code>Explain</code>关键字来查看对应的执行计划是怎么样的），使加锁更精确，从而减少锁冲突的机会；</p><p>c. 选择合理的事务大小，小事务发生锁冲突的概率一般也更小；对于使用Spring Transaction注解的同学，也可以考虑使用其编程式声明Spring事务模板的方式来将类或者方法级别的事务划分给代码块更小级别的事务。</p><p>d. 在不同线程中去访问一组DB的数据表时，尽量约定以相同的顺序进行访问；对于同一个单表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</p><p>e. 对于一些特定的业务流程，可以使用提升DB锁粒度的方式（在业务允许的情况下降低一定的并发度），比如表锁，来减少出现死锁的可能。</p><p>本文从一次测试环境的DB死锁Case出发，首先还原了发生死锁的当前场景，给出包括数据表结构、业务库的事务隔离级别、工程日志和数据库死锁日志在内的信息；然后从这些信息中逐步分析，先介绍了InnoDB的锁模型和MVCC机制，以及在四种不同隔离级别下当前读的不同区别；最后根据从死锁日志出提取的信息出发分析了死锁的根本原因，并给出降低死锁产生几率的一般方法。限于笔者的才疏学浅，对MySQL InnoDB的死锁可能还有理解不到位的地方，如有阐述不合理之处还望留言一起探讨。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎之-异步IO（Async IO）</title>
      <link href="2021/01/19/4.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%BC%82%E6%AD%A5IO%EF%BC%88Async%20IO%EF%BC%89/"/>
      <url>2021/01/19/4.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E5%BC%82%E6%AD%A5IO%EF%BC%88Async%20IO%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h2 id="关于AIO与SIO"><a href="#关于AIO与SIO" class="headerlink" title="关于AIO与SIO"></a>关于AIO与SIO</h2><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO的方式来处理磁盘操作。</p><ol><li>同步IO：我们常用的read/write函数（Linux上）就是这类IO，特点是，在函数执行的时候，调用者会等待函数执行完成，而且没有消息通知机制，因为函数返回了，就表示操作完成了，后续直接检查返回值就可知道操作是否成功。这类IO操作，编程比较简单，在同一个线程中就能完成所有操作，但是需要调用者等待，在数据库系统中，比较适合急需某些数据的时候调用，例如WAL中日志必须在返回客户端前落盘，则进行一次同步IO操作。</li><li>异步IO：在数据库中，后台刷数据块的IO线程，基本都使用了异步IO。数据库前台线程只需要把刷块请求提交到异步IO的队列中即可返回做其他事情，而后台线程IO线程，则定期检查这些提交的请求是否已经完成，如果完成再做一些后续处理工作。同时异步IO由于常常是一批一批的请求提交，如果不同请求访问同一个文件且偏移量连续，则可以合并成一个IO请求。例如，第一个请求读取文件1，偏移量100开始的200字节数据，第二个请求读取文件1，偏移量300开始的100字节数据，则这两个请求可以合并为读取文件1，偏移量100开始的300字节数据。数据预读中的逻辑预读也常常使用异步IO技术。</li></ol><h2 id="Innodb-使用异步IO的场景"><a href="#Innodb-使用异步IO的场景" class="headerlink" title="Innodb 使用异步IO的场景"></a>Innodb 使用异步IO的场景</h2><p>  总的来说innodb 只会对数据文件采用异步IO，为了保存日志是真正被写入到磁盘，innodb不会对日志文件启用异步IO;innodb只会对数据文件的read-ahead ,write 这两个操作启用异步IO</p><h2 id="异步IO在mysql中解决了什么问题"><a href="#异步IO在mysql中解决了什么问题" class="headerlink" title="异步IO在mysql中解决了什么问题"></a>异步IO在mysql中解决了什么问题</h2><p>  在没有IO这个功能之前，innodb对数据的读写请求先放入任务队列，后台read-thread ，write-thread从任务队列中拿出任务并执行读写操作；后台读写线程的个数可以通过show engine innodb status 语句来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">376 OS file reads, 54 OS file writes, 7 OS fsyncs</span><br><span class="line">41.77 reads&#x2F;s, 21886 avg bytes&#x2F;read, 6.00 writes&#x2F;s, 0.78 fsyncs&#x2F;s</span><br></pre></td></tr></table></figure><p>  由上面的内容可以看出默认情况下innodb会有4个read-thread 和4个write-thread ，问题就出现在这里，如果业务繁重，读写任务会非常的多，而innodb只有八个读写线程，这样的话队列中的其它读写请求就没能得到及时的响应。</p><p>  引入异步IO之后，读写请求不再像之前那样先放入队列，等着后台的读写线程去执行任务；而是查询线程直接发起异步请求，这样一来冲破了读写线程个数的硬性限制，二来由于异步IO是否阻塞的这也进一步提高了性能。</p><h2 id="怎么启用mysql异步IO"><a href="#怎么启用mysql异步IO" class="headerlink" title="怎么启用mysql异步IO"></a>怎么启用mysql异步IO</h2><p>首先OS要有异步io，且开启，然后mysqld要链接，要不然OS异步io没有开启，数据库的异步io也起不来。（this variable applies to Linux systems only, and cannot be changed while the server is running.）</p><ol><li>文件系统层面需要打开这个功能：<br>一般都是默认开启的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldconfig -v|grep libaio</span><br><span class="line">libaio.so.1.0.0 -&gt; libaio.so.1.0.0</span><br><span class="line">libaio.so.1 -&gt; libaio.so.1.0.1</span><br></pre></td></tr></table></figure><ol start="2"><li>AIO是数据库层面的一个特性需要打开：<br>默认是开启，但是阿里云默认是关闭的，开启的native aio性能提升，可以提高到75%。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show variables like &#39;innodb_use_native_aio&#39;;</span><br><span class="line">+-------------------------+-----------------+</span><br><span class="line">| Variable_name           | Value           |</span><br><span class="line">+-------------------------+-----------------+</span><br><span class="line">| innodb_use_native_aio   | OFF             |</span><br><span class="line">+-------------------------+-----------------+</span><br></pre></td></tr></table></figure><h2 id="异步IO的优缺点"><a href="#异步IO的优缺点" class="headerlink" title="异步IO的优缺点"></a>异步IO的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>不用等待直接响应上一个用户的请求；</li><li>多次的请求在一起排序，请求的数据页是在一起的，一次读出来，减少多次读。（数据库的读写请求队列放在文件系统中单独分配的一块小内存结构里，非文件系统的缓存）<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li></ol><p>异步IO对于我们来说是不可控的，所以说在启用异步IO的情况下相当于是我们把IO的控制权交出去了。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>oh my zsh安装配置(国内可用)</title>
      <link href="2020/12/11/oh%20my%20zsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE(%E5%9B%BD%E5%86%85%E5%8F%AF%E7%94%A8)/"/>
      <url>2020/12/11/oh%20my%20zsh%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE(%E5%9B%BD%E5%86%85%E5%8F%AF%E7%94%A8)/</url>
      
        <content type="html"><![CDATA[<h2 id="oh-my-zsh安装配置-国内可用"><a href="#oh-my-zsh安装配置-国内可用" class="headerlink" title="oh my zsh安装配置(国内可用)"></a>oh my zsh安装配置(国内可用)</h2><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><blockquote><p>dnf 改为系统中软件下载工具命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install zsh</span><br></pre></td></tr></table></figure><h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh my zsh"></a>安装oh my zsh</h3><h4 id="克隆这个项目到本地-前提是你得有装git"><a href="#克隆这个项目到本地-前提是你得有装git" class="headerlink" title="克隆这个项目到本地(前提是你得有装git)"></a>克隆这个项目到本地(前提是你得有装git)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure><h4 id="创建一个zsh的配置文件"><a href="#创建一个zsh的配置文件" class="headerlink" title="创建一个zsh的配置文件"></a>创建一个zsh的配置文件</h4><p>注意:如果你已经有一个~/.zshrc文件的话，建议你先做备份。使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.zshrc ~/.zshrc.orig</span><br></pre></td></tr></table></figure><p>然后开始创建zsh的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="设置zsh为你的默认的shell"><a href="#设置zsh为你的默认的shell" class="headerlink" title="设置zsh为你的默认的shell"></a>设置zsh为你的默认的shell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h4 id="重启并开始使用你的zsh-打开一个新的终端窗口便可…"><a href="#重启并开始使用你的zsh-打开一个新的终端窗口便可…" class="headerlink" title="重启并开始使用你的zsh (打开一个新的终端窗口便可…)"></a>重启并开始使用你的zsh (打开一个新的终端窗口便可…)</h4><h3 id="oh-my-zsh皮肤"><a href="#oh-my-zsh皮肤" class="headerlink" title="oh-my-zsh皮肤"></a>oh-my-zsh皮肤</h3><p><a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><h3 id="自动补全插件"><a href="#自动补全插件" class="headerlink" title="自动补全插件"></a>自动补全插件</h3><p>下载 incr 自动补全插件 <a href="http://mimosa-pudica.net/src/incr-0.2.zsh">http://mimosa-pudica.net/src/incr-0.2.zsh</a><br> 将插件放在 oh-my-zsh 自定义插件目录中</p><p><img src="https://i.loli.net/2020/12/10/batfNkCw2xHdW6q.png" alt="img"></p><p>打开 oh-my-zsh 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/10/RZgrAUXdN4HJwam.png" alt="img"></p><p>在 <code>plugins</code> 中添加 <code>incr</code><br> 在配置文件结束添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/custom/plugins/incr/incr*.zsh</span><br></pre></td></tr></table></figure><p>更新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 添加软件快捷启动方式</title>
      <link href="2020/12/11/Linux%20%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
      <url>2020/12/11/Linux%20%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>拿linux下的IntelliJ IDEA举个例子，其安装以后，启动方式为软件bin目录下的一个sh文件，这时候每次打开需要从文件管理器查找那个sh文件并执行，十分麻烦，为什么不能像其他软件一样有一个在菜单中的应用图片呢？</p></blockquote><p>下面我们来为其创建一个链接。</p><h3 id="跳转到-usr-share-applications"><a href="#跳转到-usr-share-applications" class="headerlink" title="跳转到/usr/share/applications"></a>跳转到/usr/share/applications</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/applications</span><br></pre></td></tr></table></figure><h3 id="编辑这个文件"><a href="#编辑这个文件" class="headerlink" title="编辑这个文件"></a>编辑这个文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit IntelliJ-IDEA.desktop</span><br></pre></td></tr></table></figure><h3 id="添加以下内容"><a href="#添加以下内容" class="headerlink" title="添加以下内容"></a>添加以下内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=IntelliJ IDEA</span><br><span class="line">Icon=/usr/local/idea-IU-203.5981.155/bin/idea.png</span><br><span class="line">Exec=sh /usr/local/idea-IU-203.5981.155/bin/idea.sh</span><br><span class="line">MimeType=application/x-py;</span><br><span class="line">Name[en_US]=IntelliJ IDEA</span><br></pre></td></tr></table></figure><p>注意Icon和Exec的路径要和软件中sh文件和图标文件对应</p><p>4）此时在软件菜单中已经能够看到启动图标了！</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu保存git用户名和密码</title>
      <link href="2020/12/11/Git%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/"/>
      <url>2020/12/11/Git%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如何在Ubuntu下解决Git保存用户名和密码呢？</p></blockquote><h3 id="打开Git-配置文件-该文件中保存着所有的配置信息"><a href="#打开Git-配置文件-该文件中保存着所有的配置信息" class="headerlink" title="打开Git 配置文件,该文件中保存着所有的配置信息"></a>打开Git 配置文件,该文件中保存着所有的配置信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure><h3 id="修改配置文件，添加下面这一行。"><a href="#修改配置文件，添加下面这一行。" class="headerlink" title="修改配置文件，添加下面这一行。"></a>修改配置文件，添加下面这一行。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">helper = store</span><br></pre></td></tr></table></figure><h4 id="记住密码"><a href="#记住密码" class="headerlink" title="记住密码"></a>记住密码</h4><p>helper = store #用来保存密码,提交一次会自动记住 </p><h4 id="密码保存一个小时"><a href="#密码保存一个小时" class="headerlink" title="密码保存一个小时"></a>密码保存一个小时</h4><p>helper = cache – timeout 3600 # 密码只保存一个小时</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu添加开机启动</title>
      <link href="2020/12/11/Ubuntu%20%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
      <url>2020/12/11/Ubuntu%20%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu添加开机启动"><a href="#Ubuntu添加开机启动" class="headerlink" title="Ubuntu添加开机启动"></a>Ubuntu添加开机启动</h2><blockquote><p>以Shadowsocks为例添加软件开机启动项</p></blockquote><ol><li><p>运行terminal</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-session-properties</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/11/HzTSx1ymZqeGRwl.png" alt="image-20201211134227760"></p></li><li><p>查找软件位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis ss-qt</span><br></pre></td></tr></table></figure></li><li><p>添加 /usr/bin/ss-qt5  就能开机启动你的Shadowsocks-qt5  如果其他程序的话  你也可以在 /usr/bin/  目录下面找到，然后使用上面的命令添加就好了</p></li></ol><p><img src="https://i.loli.net/2020/12/11/3I8vlbyqHBitQxp.png" alt="image-20201211134404269"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎之-自适应哈希索引（Adaptive Hash Index）</title>
      <link href="2020/12/07/3.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%EF%BC%88Adaptive%20Hash%20Index%EF%BC%89/"/>
      <url>2020/12/07/3.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%EF%BC%88Adaptive%20Hash%20Index%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li><p>插入缓冲（Insert Buffer）</p></li><li><p>两次写（Double Write）</p></li><li><p>自适应哈希索引（Adaptive Hash Index）</p></li><li><p>异步IO（Async IO）</p></li><li><p>刷新邻接页（Flush Neighbor Page）</p></li></ul><h2 id="自适应哈希索引（Adaptive-Hash-Index）定义"><a href="#自适应哈希索引（Adaptive-Hash-Index）定义" class="headerlink" title="自适应哈希索引（Adaptive Hash Index）定义"></a>自适应哈希索引（Adaptive Hash Index）定义</h2><p>  InnoDB本身不支持哈希索引，所有索引检索都走B树，Adaptive Hash index可以认为是“索引的索引”</p><p>  （Btree上的”索引”）。当对某个页面访问次数满足一定条件会将页面地址存于Hash表，下次查询可以非常快速的找到页面不需要Btree去查。</p><p>  （哈希索引：哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。）</p><p>  AHI的目的是根据用户提供的查询条件加速定位到叶子节点，如果有固定的查询pattern，都可以通过AHI受益，特别是Btree深度比较大的时候。</p><p>自适应哈希索引 （AHI） 是 InnoDB 中最不为人所知的功能之一。从理论上讲，它自主确定何时使用快速哈希查找表补充基于 InnoDB B 树的索引，然后在用户不提示的情况下自动生成它们。</p><p>由于 AHI 工作 “像魔术一样”， 它几乎没有可用的配置。在早期版本中，没有任何可用的配置选项。添加了较新版本<code>innodb_adaptive_hash_index</code> 如果需要，请禁用 AHI（将其设置为”0”或”OFF”）。MySQL 5.7 增加了通过启用 AHI 对 AHI 进行分区的能力<code>innodb_adaptive_hash_index_parts</code>.（5.5以后 （FYI）功能存在于 Percona 服务器中，<code>innodb_adaptive_hash_index_partitions</code>）。</p><p>要了解 AHI 对性能的影响，我们可以把它理解为缓存。如果 AHI发生 “Hit” ，则会有更好的查找性能;如果是 AHI “Miss”， 那么性能会稍微差一点 （因为检查哈希表的匹配速度很快， 但不是免费的） 。</p><p>不过，这并不是唯一的问题。除了查找成本外，还有 AHI 维护成本。我们可以将维护成本（从 AHI 中添加和删除的行）与成功的查找进行比较。高比率意味着以低成本加速了大量查找。低比率意味着相反：我们可能付出太多的维护成本，但收效甚微。</p><p>最后，添加AHI会有额外的成本。如果工作负载包括查找大量索引或表，则可以通过设置<code>innodb_adaptive_hash_index_parts</code> 。但是，如果存在热索引，AHI 可能会成为高并发的瓶颈，可能需要禁用。</p><p>要确定 AHI 是否可能帮助我的工作负载，我们应该验证 AHI 命中和成功查找到维护操作的比率是否尽可能高。</p><p>我们看一些简单工作负载的情况。使用主键的基本 Sysbench 查找 - 尽可能简单的工作负载。我们会发现，即使在这种情况下，我们也会发现一些行为。</p><p>使用 MySQL 5.7.11 与 16GB 缓冲池。系统台的基本命令行是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --test=/usr/share/doc/sysbench/tests/db/select.lua   --report-interval=1 --oltp-table-size=1 --max-time=0 --oltp-read-only=off --max-requests=0 --num-threads=1 --rand-type=uniform --db-driver=mysql --mysql-password=password --mysql-db=test_innodb  run</span><br></pre></td></tr></table></figure><p><strong>查找一行</strong></p><p><code>oltp-table-size=1</code> ;测试 AHI 基本的情况下,有100%的命中率，没有HI维护操作。</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size1.png"><img src="https://i.loli.net/2020/12/07/6Wl3fBSvVKGETDR.png" alt="oltp table size=1"></a></p><p><strong>表中的 10000 行</strong></p><p>OLTP 表设置更改为<code>oltp-table-size=10000</code>：</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size10k.png"><img src="https://i.loli.net/2020/12/07/6p5gyF9LafDwTGM.png" alt="oltp table size=10k"></a></p><p><img src="https://i.loli.net/2020/12/07/3KLupnrhBHRJykj.png" alt="oltp table size=10k-2"></p><p>同样，几乎看不到开销。有一个罕见的事件，16行左右被添加到AHI（可能是由于AHI哈希冲突）。它几乎是完美的。</p><p><strong>表中的 10M 行</strong></p><p>将设置更改为<code>oltp-table-size=10000000</code>，现在有更多的数据（但仍比缓冲池大小少得多）：</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size10m.png"><img src="https://i.loli.net/2020/12/07/x4Z8IcfX3hnHeAk.png" alt="oltp table size=10m"></a></p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size10m-2.png"><img src="https://i.loli.net/2020/12/07/fa2ViFYKJRAjGQt.png" alt="oltp table size=10m-2"></a></p><p>这种情况下，有一个热身期，接近100%的命中率 - 没有完全达到100%（即使在更长的运行后）。在这种情况下，维护操作一直都在运行没有停止的迹象。 对于 1000 万行， 哈希冲突的可能性更高 — 导致更多的 AHI 重建。</p><p><strong>表中 500M 行，均匀分布</strong></p><p>现在，让我们将 OLTP 表大小设置为如下：<code>oltp-table-size=500000000</code>.这会导致数据大小超出 Innodb 缓冲池大小。</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m.png"><img src="https://i.loli.net/2020/12/07/yglezphXQHOPw1J.png" alt="oltp table size=500m"></a></p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-2.png"><img src="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-2.png" alt="oltp table size=500m-2"></a></p><p>这时我们看到很多缓冲池缺失，导致非常差的 AHI 命中率（永远不会达到 1%）。还可以看到从 AHI 添加或者移除数万行的较大开销。在这种情况下，AHI 不会添加任何值</p><p><strong>500M 行，帕雷托分布</strong></p><p>最后，让我们使用设置<code>oltp-table-size=500000000</code>，添加<code>--rand-type=pareto</code>设置启用了倾斜分布，这是许多实际数据访问模式的一个更典型的场景。</p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-Pareto.png"><img src="https://i.loli.net/2020/12/07/IqAZ3yfsY5uEBVW.png" alt="oltp table size=500m-Pareto"></a></p><p><a href="https://www.percona.com/blog/wp-content/uploads/2016/04/oltp-table-size500m-Pareto-2.png"><img src="https://i.loli.net/2020/12/07/rmqYVDuGoQbnEM3.png" alt="oltp table size=500m-Pareto-2"></a></p><p>在这种情况下，我们看到 AHI 命中率逐渐提高，并接近 50%。AHI 维护开销正在下降，但从未达到任何表明它值得的东西。</p><blockquote><p>从上面配置中可以看到，InnoDB中的自适应哈希索引并不总是有效提高性能的！有些情况下，AHI 确实有帮助，有些情况下，AHI 添加了大量数据结构维护开销。在这些情况下，最好禁用 AHI。</p><p>如官网所说：由于很难预先预测<code>adaptive hash index</code>功能是否适合特定系统和工作负载，因此请考虑在启用和禁用时运行基准测试。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 客户端推荐</title>
      <link href="2020/12/03/Redis%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A8%E8%8D%90/"/>
      <url>2020/12/03/Redis%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>日常开发过程中，项目常常都会使用Redis来做缓存或者Session服务器，为了更直观方便，开发者常常会使用一些可视化工具，如 Redis Desktop Manager、Redis Clent等，但界面UI做得不尽人意，作为当今时代，对软件的UI还是有所期待的，今天给大家分享一款，高颜值、功能强大的Redis客户端工具</p><h2 id="Another-Redis-Desktop-Manager"><a href="#Another-Redis-Desktop-Manager" class="headerlink" title="Another Redis Desktop Manager"></a>Another Redis Desktop Manager</h2><p>gitee开源地址：<a href="https://gitee.com/qishibo/AnotherRedisDesktopManager">AnotherRedisDesktopManager: Github国内镜像，供下载使用，有问题可移步到 (gitee.com)</a></p><p>github开源地址：<a href="https://github.com/qishibo/AnotherRedisDesktopManager">qishibo/AnotherRedisDesktopManager: 🚀🚀🚀A faster, better and more stable redis desktop manager, compatible with Linux, windows, mac. What’s more, it won’t crash when loading a large number of keys. (github.com)</a></p><p>一个更快、更好、更稳定的redis桌面管理工具，可以运行于Linux、Windows、Mac三大平台，并且当加载大数量的key不会crash</p><blockquote><p>🚀🚀🚀 A faster, better and more stable redis desktop manager, compatible with Linux, windows, mac. What’s more, it won’t crash when loading a large number of keys.</p></blockquote><p><img src="https://i.loli.net/2020/12/03/1yVO9dftPL6mq7g.png" alt="Another Redis DeskTop Manager"></p><h2 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h2><p><img src="https://i.loli.net/2020/12/03/AIzSwk2qtevHObV.png" alt="多语言支持"></p><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><h3 id="深色主题效果"><a href="#深色主题效果" class="headerlink" title="深色主题效果"></a>深色主题效果</h3><p><img src="https://i.loli.net/2020/12/03/kvaDJuxZLPByHlR.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/12/03/Rwf8qVk7Tnoe2CD.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/12/03/6Nj3aoFxwuY5gfZ.jpg" alt="img"></p><h3 id="亮色主题效果"><a href="#亮色主题效果" class="headerlink" title="亮色主题效果"></a>亮色主题效果</h3><p><img src="https://i.loli.net/2020/12/03/BpAL8UbodZ7IeVa.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/12/03/BpAL8UbodZ7IeVa.jpg"></p><p><img src="https://i.loli.net/2020/12/03/YjtNxwTMr1zkWi9.jpg" alt="img"></p><blockquote><p>服务器状态监控，数据操作等等功能齐全。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> activate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎之-两次写（Double Write）</title>
      <link href="2020/12/03/2.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E4%B8%A4%E6%AC%A1%E5%86%99%EF%BC%88Double%20Write%EF%BC%89/"/>
      <url>2020/12/03/2.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E4%B8%A4%E6%AC%A1%E5%86%99%EF%BC%88Double%20Write%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><h3 id="经典Partial-page-write问题"><a href="#经典Partial-page-write问题" class="headerlink" title="经典Partial page write问题"></a>经典Partial page write问题</h3><p>介绍double write之前我们有必要了解<code>partial page write</code>（部分页失效）。</p><p>InnoDB的Page Size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以Page为单位进行操作的。我们知道，由于文件系统对一次大数据页（例如InnoDB的16KB）大多数情况下不是原子操作，这意味着如果服务器宕机了，可能只做了部分写入。16K的数据，写入4K时，发生了系统断电/os crash ，只有一部分写是成功的，这种情况下就是<code>partial page write</code>问题。</p><p>我们一般可能会想到，如果发生写失效，MySQL可以根据redo log进行恢复。这是一个办法，但是必须清楚地认识到，redo log中记录的是对页的物理修改，如偏移量<code>800</code>，写<code>aaaa</code>记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。MySQL在恢复的过程中检查page的checksum，checksum就是检查page的最后事务号，发生<code>partial page write</code>问题时，page已经损坏，找不到该page中的事务号。在InnoDB看来，这样的数据页是无法通过checksum验证的，就无法恢复。即时我们强制让其通过验证，也无法从崩溃中恢复，因为当前InnoDB存在的一些日志类型，有些是逻辑操作，并不能做到幂等。</p><p>为了解决这个问题，InnoDB实现了<code>double write buffer</code>，简单来说，就是在写数据页之前，先把这个数据页写到一块独立的物理文件位置（ibdata），然后再写到数据页。这样在宕机重启时，如果出现数据页损坏，那么在应用redo log之前，需要通过该页的副本来还原该页，然后再进行redo log重做，这就是<code>double write</code>。<code>double write</code>技术带给innodb存储引擎的是数据页的可靠性，下面对<code>double write</code>技术进行解析，让大家充分理解<code>double write</code>是如何做到保障数据页的可靠性。</p><h3 id="double-write体系结构"><a href="#double-write体系结构" class="headerlink" title="double write体系结构"></a>double write体系结构</h3><p><code>double write</code>由两部分组成，一部分是InnoDB内存中的<code>double write buffer</code>，大小为2M，另一部分是物理磁盘上<code>ibdata</code>系统表空间中大小为2MB，共128个连续的Page，既2个分区。其中120个用于批量写脏，另外8个用于Single Page Flush。做区分的原因是批量刷脏是后台线程做的，不影响前台线程。而Single page flush是用户线程发起的，需要尽快的刷脏并替换出一个空闲页出来。</p><p>对于批量刷脏，每次找到一个可做flush的page，对其持有S lock，然后将该page拷贝到dblwr中，当dblwr满后者一次批量刷脏结束时，将dblwr中的page全部刷到ibdata中，注意这是同步写操作；然后再唤醒后台IO线程去写数据页。当后台IO线程完成写操作后，会去更新dblwr中的计数以腾出空间，释放block上的S锁，完成写入。</p><p>对于Single Page Flush，则做的是同步写操作，在挑出一个可以刷脏的page后，先加入到dblwr中，刷到<code>ibdata</code>，然后写到用户表空间，完成后，会对该用户表空间做一次fsync操作。</p><p>Single Page Flush在buffer pool中free page不够时触发，通常由前台线程发起，由于每次single page flush都会导致一次fsync操作，在大并发负载下，如果大量线程去做flush，很显然会产生严重的性能下降。Percona在5.6版本中做了优化，可以选择由后台线程lru manager来做预刷，避免用户线程陷入其中。</p><p>如果发生了极端情况（断电），InnoDB再次启动后，发现了一个Page数据已经损坏，那么此时就可以从double write buffer中进行数据恢复了。</p><h3 id="double-write工作流程"><a href="#double-write工作流程" class="headerlink" title="double write工作流程"></a>double write工作流程</h3><p>当一系列机制（main函数触发、checkpoint等）触发数据缓冲池中的脏页进行刷新到data file的时候，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的double write buffer，之后通过double write buffer再分两次、每次1MB顺序写入共享表空间的物理磁盘上。然后马上调用fsync函数，同步脏页进磁盘上。由于在这个过程中，double write页的存储时连续的，因此写入磁盘为顺序写，性能很高；完成<code>double write</code>后，再将脏页写入实际的各个表空间文件，这时写入就是离散的了。各模块协作情况如下图（第一步应为脏页产生的redo记录log buffer，然后log buffer写入redo log file，为简化次要步骤直接连线表示）：</p><p><a href="http://www.ywnds.com/wp-content/uploads/2017/04/2017041411205698.jpg"><img src="https://i.loli.net/2020/12/01/BCwp5buVkWTU6X7.jpg" alt="MySQL InnoDB特性：两次写（Double Write）"></a></p><p>查看double write工作情况，可以执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show status like &quot;%InnoDB_dblwr%&quot; ;</span><br><span class="line">+ -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- +</span><br><span class="line">| Variable_name                | Value         |</span><br><span class="line">+ -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- +</span><br><span class="line">| Innodb_dblwr_pages_written   | 61932183      |</span><br><span class="line">| Innodb_dblwr_writes          | 15237891      |</span><br><span class="line">+ -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- +</span><br><span class="line">2 rows in set ( 0.01 sec )</span><br></pre></td></tr></table></figure><p>以上数据显示，double write一共写了 61932183个页，一共写了15237891次，从这组数据我们可以分析，之前讲过在开启double write后，每次脏页刷新必须要先写double write，而double write存在于磁盘上的是两个连续的区，每个区由连续的页组成，一般情况下一个区最多有64个页，所以一次IO写入应该可以最多写64个页。而根据以上我这个系统Innodb_dblwr_pages_written与Innodb_dblwr_writes的比例来看，一次大概在4个页左右，远远还没到64，所以从这个角度也可以看出，系统写入压力并不高。</p><p>如果操作系统在将页写入磁盘的过程中发送了崩溃，在恢复过程中，InnoDB存储引擎可以从工序表空间中的double write中找到该页的副本，将其复制到表空间文件，再应用redo log。下面显示了一个由double write进行恢复的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">090924 11 : 36 : 32    mysqld restarted</span><br><span class="line">090924 11 : 26 : 33    InnoDB : Database was not shut down normally !</span><br><span class="line">InnoDB : Starting crash recovery .</span><br><span class="line">InnoDB : Reading tablespace information from the .ibd files . . .</span><br><span class="line">InnoDB : Crash recovery may have faild for some .ibd files !</span><br><span class="line">InnoDB : Restoring possible half - written data pages from the doublewrite .</span><br><span class="line">InnoDB : buffer . . .</span><br></pre></td></tr></table></figure><h3 id="double-write缺点"><a href="#double-write缺点" class="headerlink" title="double write缺点"></a>double write缺点</h3><p>dblwr位于共享表空间上的double write buffer实际上也是一个文件，引入了一次额外写的开销，每个数据页都被要求写两次。由于需要大量的fsync操作，所以它会降低MySQL的整体性能，但是并不会降低到原来的50%。这主要是因为：</p><ol><li><p>double write是一个连接的存储空间，所以硬盘在写数据的时候是顺序写，而不是随机写，这样性能更高。</p></li><li><p>将数据从double write buffer写到真正的segment中的时候，系统会自动合并连接空间刷新的方式，每次可以刷新多个pages。</p></li></ol><p>double write默认开启，参数skip_innodb_double_write虽然可以禁止使用double write功能，但还是强烈建议大家使用double write。避免部分写失效问题，当然，如果你的数据表空间放在本身就提供了部分写失效防范机制的文件系统上，如ZFS/FusionIO/DirectFS文件系统，在这种情况下，就可以不开启double write了。</p><h3 id="double-write在恢复的时候是如何工作的？"><a href="#double-write在恢复的时候是如何工作的？" class="headerlink" title="double write在恢复的时候是如何工作的？"></a>double write在恢复的时候是如何工作的？</h3><p>如果是写double write buffer本身失败，那么这些数据不会被写到磁盘，InnoDB此时会从磁盘载入原始的数据，然后通过InnoDB的事务日志来计算出正确的数据，重新写入到double write buffer。</p><p>如果double write buffer写成功的话，但是写磁盘失败，InnoDB就不用通过事务日志来计算了，而是直接用buffer的数据再写一遍。如上图中显示，在恢复的时候，InnoDB直接比较页面的checksum，如果不对的话，Innodb存储引擎可以从共享表空间的double write中找到该页的一个最近的副本，将其复制到表空间文件，再应用redo log，就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏，但InnoDB的恢复通常需要较长的时间。</p><h3 id="MariaDB-MySQL-Facebook-Percona-5-7的改进"><a href="#MariaDB-MySQL-Facebook-Percona-5-7的改进" class="headerlink" title="MariaDB/MySQL/Facebook/Percona 5.7的改进"></a>MariaDB/MySQL/Facebook/Percona 5.7的改进</h3><h4 id="MariaDB-MySQL改进"><a href="#MariaDB-MySQL改进" class="headerlink" title="MariaDB/MySQL改进"></a>MariaDB/MySQL改进</h4><p>MariaDB使用参数<a href="https://mariadb.com/kb/en/mariadb/fusion-io-nvmfs-atomic-write-support/?spm=5176.100239.blogcont50627.8.RbCnm5">innodb_use_atomic_writes</a>来控制原子写行为，当打开该选项时，会使用O_DIRECT模式打表空间，通过posix_fallocate来扩展文件（而不是写0扩展），当在启动时检查到支持atomic write时，即使开启了innodb_doublewrite，也会关闭掉。</p><p>Oracle MySQL同样支持FusionIO的Atomic Write特性（Fusion-io Non-Volatile Memory (NVM) file system），对于支持原子写的文件系统，也会自动关闭double write buffer。</p><h4 id="Facebook改进"><a href="#Facebook改进" class="headerlink" title="Facebook改进"></a>Facebook改进</h4><p>实际上这不能算是改进，只是提供了一个新的选项。在现实场景中，宕机是非常低概率的事件。大部分情况下dblwr都是用不上的。但如果我们直接关闭dblwr，如果真的发生例如掉电宕机了，我们需要知道哪些page可能损坏了。</p><p>因此Facebook MySQL提供了一个选项，可以写page之前，只将对应的page number写到dblwr中（而不是写全page），在崩溃恢复时，先读出记录在dblwr中的page号，检查对应的数据页是否损坏，如果损坏了，那就需要从备库重新恢复该实例。</p><h4 id="Percona-5-7改进"><a href="#Percona-5-7改进" class="headerlink" title="Percona 5.7改进"></a>Percona 5.7改进</h4><p>Percona Server的每个版本都对InnoDB的刷脏逻辑做了不少的优化，进入5.7版本也不例外。在官方5.7中已经实现了多个Page Cleaner，我们可以把Page Cleaner配置成和buffer pool instance的个数相同，可以更好的实现并行刷脏。</p><p>但是官方版本中，Page cleaner既要负责刷FLUSH LIST，同时也要做LRU FLUSH(但每个bp instance不超过innodb_lru_scan_depth)。而这两部分任务是可以独立进行的。</p><p>因此Percona Server增加了多个LRU FLUSH线程，可以更高效的进行lru flush，避免用户线程陷入single page flush状态。每个buffer pool instance拥有自己的lru flush线程和page cleaner线程。lru flush基于当前free list的长度进行自适应计算。 每个lru线程负责自己的那个Buffer pool。因此不同lru flush线程的繁忙程度可能是不一样的。</p><p>在解决上述问题后，bp flush的并行效率大大的提升了。但是对于所有的刷脏操作，都需要走到double write buffer。这意味着dblwr成为了新的瓶颈。为了解决这个问题，dblwr进行了拆分，每个bp instance都有自己的dblwr区域。这样各个Lru flush线程及Page cleaner线程在做page flush时就不会相互间产生锁冲突，从而提升了系统的扩展性。</p><p>你可以通过参数来配置一个独立于ibdata之外的文件来存储dblwr，文件被划分成多个区域，分区数为bp instance的个数，每个分区的大小为2 * srv_doublewrite_batch_size，每个batch size默认配置为120个page，其中一个用于刷FLUSH LIST，一个用于刷LRU。</p><p>如果fast shutdown设置为2，dblwr文件在正常shutdown时会被删除掉，并在重启后重建。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎之-插入缓冲（Insert Buffer）</title>
      <link href="2020/12/01/1.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%EF%BC%88Insert%20Buffer%EF%BC%89/"/>
      <url>2020/12/01/1.InnoDB%E5%BC%95%E6%93%8E%E4%B9%8B-%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%EF%BC%88Insert%20Buffer%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="InnoDB引擎之-插入缓冲（Insert-Buffer）"><a href="#InnoDB引擎之-插入缓冲（Insert-Buffer）" class="headerlink" title="InnoDB引擎之-插入缓冲（Insert Buffer）"></a>InnoDB引擎之-插入缓冲（Insert Buffer）</h2><p>InnoDB引擎有几个重点特性，为其带来了更好的性能和可靠性：</p><ul><li>插入缓冲（Insert Buffer）</li><li>两次写（Double Write）</li><li>自适应哈希索引（Adaptive Hash Index）</li><li>异步IO（Async IO）</li><li>刷新邻接页（Flush Neighbor Page）</li></ul><p>今天主题就是 <code>插入缓冲（Insert Buffer）</code>,由于InnoDB引擎底层数据存储结构式B+树，对于索引又有聚集索引和非聚集索引。</p><p>在进行数据插入时必然会引起索引的变化，聚集索引一般都是递增有序的。非聚集索引就不一定是什么数据了，其离散性导致了在插入时结构的不断变化，从而导致插入性能降低。</p><p>为了解决非聚集索引插入性能的问题，InnoDB引擎 创造了Insert Buffer。</p><h3 id="Insert-Buffer-存储"><a href="#Insert-Buffer-存储" class="headerlink" title="Insert Buffer 存储"></a>Insert Buffer 存储</h3><p><img src="https://i.loli.net/2020/12/01/sjZ13dzIkYBhanv.png" alt="InnerDB存储引擎内存结构"></p><p>上图可能大家会认为Insert Buffer 就是InnoDB 缓冲池的一个组成部分。</p><blockquote><p><strong>重点</strong>：其实对也不对，InnoDB 缓冲池确实包含了Insert Buffer的信息，但Insert Buffer 和数据页一样，也是物理存在的（以B+树的形式存在共享表空间中）。</p></blockquote><h3 id="Insert-Buffer-作用"><a href="#Insert-Buffer-作用" class="headerlink" title="Insert Buffer 作用"></a>Insert Buffer 作用</h3><p>先说几个点：</p><ul><li><p>一张表只能有一个主键索引，那是因为其物理存储是一个B+树。（别忘了聚集索引叶子节点存储的数据，而数据只有一份）</p></li><li><p>非聚集索引叶子节点存的是聚集索引的主键</p></li></ul><h3 id="Insert-Buffer-插入过程"><a href="#Insert-Buffer-插入过程" class="headerlink" title="Insert Buffer  插入过程"></a>Insert Buffer  插入过程</h3><h4 id="聚集索引插入"><a href="#聚集索引插入" class="headerlink" title="聚集索引插入"></a>聚集索引插入</h4><p>在InnoDB存储引擎中，主键是行唯一的标识符（聚集索引）。</p><p>插入数据一般都是按照主键递增插入，因此聚集索引都是顺序的，不需要磁盘的随机读取。</p><p>比如表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line"> id INT AUTO_INCREMENT,</span><br><span class="line"> name VARCHAR(30),</span><br><span class="line"> PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上表中主键 id,它有以下的特性：</p><ul><li>id列是自增长的</li><li>id列插入NULL值时，由于AUTO_INCREMENT的原因，其值会递增</li><li>同时数据页中的行记录按id的值进行顺序存放</li></ul><p>一般情况下由于聚集索引的有序性，不需要随机读取页中的数据，顺序插入速度是非常快的。</p><p>但如果你把列 id 插入UUID这种数据，那你插入就是和非聚集索引一样都是随机的了。会导致你的B+ tree结构不停地变化，那性能必然会受到影响。</p><h4 id="非聚集索引插入"><a href="#非聚集索引插入" class="headerlink" title="非聚集索引插入"></a>非聚集索引插入</h4><p>表中一般有很多非聚集索引，比如我按照b字段查询，且b字段不是唯一的。如下表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line"> id INT AUTO_INCREMENT,</span><br><span class="line"> name VARCHAR(30),</span><br><span class="line"> PRIMARY KEY(id),</span><br><span class="line"> KEY(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如上表：</p><ul><li>有一个聚集索引 id</li><li>有一个不唯一的非聚集索引 name</li><li>在插入数据时数据页是按照主键id进行顺序存放</li><li>辅助索引 name的数据插入不是顺序的</li></ul><p>非聚集索引也是一颗B+树，只是叶子节点存的是聚集索引的主键和name 的值.因为不能保证name列的数据是顺序的，所以非聚集索引这棵树的插入必然也不是顺序的了。当然如果name列插入的是时间类型数据，那其非聚集索引的插入也是顺序的。</p><blockquote><p>可以看出非聚集索引插入的离散性导致了插入性能的下降，因此InnoDB引擎设计了 Insert Buffer来提高插入性能 。</p></blockquote><p>  <strong>Insert Buffer 插入过程：</strong></p><pre><code>1. 首先对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中。2. 若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。3. 给外部的感觉好像是树已经插入非聚集的索引的叶子节点，而其实是存放在其他位置了</code></pre><p>  以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，通常会将多个插入操作一起进行merge，这就大大的提升了非聚集索引的插入性能。</p><h3 id="Insert-Buffer的使用要求："><a href="#Insert-Buffer的使用要求：" class="headerlink" title="Insert Buffer的使用要求："></a>Insert Buffer的使用要求：</h3><ul><li>索引是非聚集索引</li><li>索引不是唯一（unique）的</li></ul><p>只有满足上面两个必要条件时，InnoDB存储引擎才会使用Insert Buffer来提高插入性能。</p><p><strong>那为什么必须满足上面两个条件呢？</strong></p><p>第一点索引是非聚集索引就不用说了，人家聚集索引本来就是顺序的也不需要你</p><p>第二点必须不是唯一（unique）的，因为在写入Insert Buffer时，数据库并不会去判断插入记录的唯一性。如果再去查找肯定又是离散读取的情况了，这样Insert Buffer就失去了意义。</p><h3 id="Insert-Buffer信息查看"><a href="#Insert-Buffer信息查看" class="headerlink" title="Insert Buffer信息查看"></a>Insert Buffer信息查看</h3><p>我们可以使用命令SHOW ENGINE INNODB STATUS来查看Insert Buffer的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 7545, free list len 3790, seg size 11336, </span><br><span class="line">8075308 inserts,7540969 merged sec, 2246304 merges</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用命令后，我们会看到很多信息，这里我们只看下INSERT BUFFER 的:</p><ul><li>seg size 代表当前Insert Buffer的大小  11336*16KB</li><li>free listlen 代表了空闲列表的长度</li><li>size 代表了已经合并记录页的数量</li><li>Inserts 代表了插入的记录数</li><li>merged recs 代表了合并的插入记录数量</li><li>merges 代表合并的次数，也就是实际读取页的次数</li></ul><p>merges：merged recs大约为1∶3，代表了Insert Buffer 将对于非聚集索引页的离散IO逻辑请求大约降低了2/3</p><h3 id="Insert-Buffer的问题"><a href="#Insert-Buffer的问题" class="headerlink" title="Insert Buffer的问题"></a>Insert Buffer的问题</h3><p>说了这么多针对于Insert Buffer的好处，但目前Insert Buffer也存在一个问题：</p><p>即在写密集的情况下，插入缓冲会占用过多的缓冲池内存（innodb_buffer_pool），默认最大可以占用到1/2的缓冲池内存。</p><p>占用了过大的缓冲池必然会对其他缓冲池操作带来影响</p><h3 id="Insert-Buffer的优化"><a href="#Insert-Buffer的优化" class="headerlink" title="Insert Buffer的优化"></a>Insert Buffer的优化</h3><p>MySQL5.5之前的版本中其实都叫做Insert Buffer，之后优化为 <code>Change Buffer</code>可以看做是 Insert Buffer 的升级版。</p><p>插入缓冲（ Insert Buffer）这个其实只针对 INSERT 操作做了缓冲，而Change Buffer 对INSERT、DELETE、UPDATE都进行了缓冲，所以可以统称为写缓冲，其可以分为：</p><ul><li>Insert Buffer</li><li>Delete Buffer</li><li>Purgebuffer</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>Insert Buffer到底是个什么？</strong></p><ul><li>其实Insert Buffer的数据结构就是一棵B+树。</li><li>在MySQL 4.1之前的版本中每张表有一棵Insert Buffer B+树</li><li>目前版本是全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer</li><li>这棵B+树存放在共享表空间ibdata1中</li></ul><p><strong>以下几种情况下 Insert Buffer会写入真正非聚集索引，也就是所说的Merge Insert Buffer</strong></p><ul><li>当辅助索引页被读取到缓冲池中时</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时</li><li>Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作</li></ul><p><strong>一句话概括下：</strong>Insert Buffer 就是用于提升非聚集索引页的插入性能的，其数据结构类似于数据页的一个B+树，物理存储在共享表空间ibdata1中 。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL 语句优化整理</title>
      <link href="2020/11/25/SQL%20%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/"/>
      <url>2020/11/25/SQL%20%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>为了提高 SQL 查询效率，我们都会采取一切 SQL 语句的优化。</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>可以在num上设置默认值0，<strong>确保表中num列没有null值</strong>，然后这样查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">10</span> <span class="keyword">or</span> num=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>可以这样查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">10</span></span><br><span class="line">union all</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>下面的查询也将导致全表扫描：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name like <span class="string">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure><p>若要提高效率，可以考虑全文检索。</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="title">in</span>(<span class="params"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span>)</span></span><br></pre></td></tr></table></figure><p>对于连续的数值，能用 between 就不要用 in 了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num between <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；<strong>它必须在编译时进行选择。</strong>然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=@num</span><br></pre></td></tr></table></figure><p>可以改为强制查询使用索引：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="title">with</span>(<span class="params">index(索引名</span>)) <span class="keyword">where</span> num</span>=@num</span><br></pre></td></tr></table></figure><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num/<span class="number">2</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure><p>应改为:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="title">substring</span>(<span class="params">name,<span class="number">1</span>,<span class="number">3</span></span>)</span>=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">--name以abc开头的id</span><br><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="title">datediff</span>(<span class="params">day,createdate,<span class="string">&#x27;2005-11-30&#x27;</span></span>)</span>=<span class="number">0</span></span><br><span class="line">--<span class="string">&#x27;2005-11-30&#x27;</span>生成的id</span><br></pre></td></tr></table></figure><p>应改为:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name like <span class="string">&#x27;abc%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> createdate&gt;=<span class="string">&#x27;2005-11-30&#x27;</span> <span class="keyword">and</span> createdate&lt;<span class="string">&#x27;2005-12-1&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p><strong>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算</strong>，否则系统将不能正确使用索引。</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> <span class="meta">#t from t where 1=0</span></span><br></pre></td></tr></table></figure><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="comment">#t(...)</span></span><br></pre></td></tr></table></figure><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>很多时候用 exists 代替 in 是一个好的选择：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> num <span class="title">in</span>(<span class="params"><span class="keyword">select</span> num <span class="keyword">from</span> b</span>)</span></span><br></pre></td></tr></table></figure><p>用下面的语句替换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> <span class="title">exists</span>(<span class="params"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> num=a.num</span>)</span></span><br></pre></td></tr></table></figure><h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，<strong>一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。</strong>若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h3 id="19"><a href="#19" class="headerlink" title="19"></a>19</h3><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><h3 id="20"><a href="#20" class="headerlink" title="20"></a>20</h3><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><h3 id="21"><a href="#21" class="headerlink" title="21"></a>21</h3><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><h3 id="22"><a href="#22" class="headerlink" title="22"></a>22</h3><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。<strong>但是，对于一次性事件，最好使用导出表。</strong></p><h3 id="23"><a href="#23" class="headerlink" title="23"></a>23</h3><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><h3 id="24"><a href="#24" class="headerlink" title="24"></a>24</h3><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><h3 id="25"><a href="#25" class="headerlink" title="25"></a>25</h3><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><h3 id="26"><a href="#26" class="headerlink" title="26"></a>26</h3><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><h3 id="27"><a href="#27" class="headerlink" title="27"></a>27</h3><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括<strong>“合计”的例程通常要比使用游标执行的速度快。</strong>如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><h3 id="28"><a href="#28" class="headerlink" title="28"></a>28</h3><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><h3 id="29"><a href="#29" class="headerlink" title="29"></a>29</h3><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><h3 id="30"><a href="#30" class="headerlink" title="30"></a>30</h3><p>尽量避免大事务操作，提高系统并发能力。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring事物失效原因整理</title>
      <link href="2020/11/24/Spring%E4%BA%8B%E7%89%A9%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E6%95%B4%E7%90%86/"/>
      <url>2020/11/24/Spring%E4%BA%8B%E7%89%A9%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring事物实现方式及原理"><a href="#Spring事物实现方式及原理" class="headerlink" title="Spring事物实现方式及原理"></a>Spring事物实现方式及原理</h2><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。真正的数据库层的事务提交和回滚是在binlog提交之后进行提交的 通过 redo log 来重做， undo log来回滚。</p><p>一般我们在程序里面使用的都是在方法上面加<code>@Transactional</code> 注解，这种属于声明式事物。</p><p>声明式事务本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><h2 id="失效原因"><a href="#失效原因" class="headerlink" title="失效原因"></a>失效原因</h2><h3 id="数据库本身不支持事物"><a href="#数据库本身不支持事物" class="headerlink" title="数据库本身不支持事物"></a>数据库本身不支持事物</h3><p>这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB</p><h3 id="当前类的调用"><a href="#当前类的调用" class="headerlink" title="当前类的调用"></a>当前类的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        updateUser(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这种情况下是不会有事物管理操作的。</p><p>通过看声明式事物的原理可知，Spring使用的是AOP切面的方式，本质上使用的是动态代理来达到事物管理的目的，当前类调用的方法上面加<code>@Transactional</code> 这个是没有任何作用的，因为调用这个方法的是<code>this</code>.</p><p>OK， 我们在看下面的一种例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        updateUser(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次在 update 方法上加了 <code>@Transactional</code>，updateUser 加了 <code>REQUIRES_NEW</code> 新开启一个事务，那么新开的事务管用么？</p><p>答案是：不管用！</p><p>因为它们发生了自身调用，就调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效，这也是老生常谈的经典问题了。</p><h3 id="方法不是public的"><a href="#方法不是public的" class="headerlink" title="方法不是public的"></a>方法不是public的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private</code> 方法是不会被Spring代理的，因此是不会有事物产生的，这种做法是无效的。</p><h3 id="没有被Spring管理"><a href="#没有被Spring管理" class="headerlink" title="没有被Spring管理"></a>没有被Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有被Spring管理的bean， Spring连代理对象都无法生成，当然无效咯。</p><h3 id="配置的事物传播性有问题"><a href="#配置的事物传播性有问题" class="headerlink" title="配置的事物传播性有问题"></a>配置的事物传播性有问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下Spring的事物传播行为</p><p>Spring 事务的传播行为说的是，当多个事务同时存在的时候， Spring 如何处理这些事务的行为。</p><ol><li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行</li><li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER： 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按 REQUIRED 属性执行</li></ol><p>当传播行为设置了PROPAGATION_NOT_SUPPORTED，PROPAGATION_NEVER，PROPAGATION_SUPPORTS这三种时，就有可能存在事物不生效</p><h3 id="异常被-“抓住”了"><a href="#异常被-“抓住”了" class="headerlink" title="异常被 “抓住”了"></a>异常被 “抓住”了</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">catch</span>(Execption e)&#123;</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;异常&quot;</span>,e)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常被抓了，这样子代理类就没办法知道你到底有没有错误，需不需要回滚，所以这种情况也是没办法回滚的哦。</p><h3 id="接口层声明式事物使用cglib代理"><a href="#接口层声明式事物使用cglib代理" class="headerlink" title="接口层声明式事物使用cglib代理"></a>接口层声明式事物使用cglib代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用</p><p>注解@Transactional cglib与java动态代理最大区别是代理目标对象不用实现接口,那么注解要是写到接口方法上，要是使用cglib代理，这是注解事物就失效了，为了保持兼容注解最好都写到实现类方法上。</p><h3 id="rollbackFor异常指定错误"><a href="#rollbackFor异常指定错误" class="headerlink" title="rollbackFor异常指定错误"></a>rollbackFor异常指定错误</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种没有指定回滚异常，这个时候默认的回滚异常是<code>RuntimeException</code> ，如果出现其他异常那么就不会回滚事物</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java的优雅停机!!!</title>
      <link href="2020/11/24/java%E7%9A%84%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA!!!/"/>
      <url>2020/11/24/java%E7%9A%84%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA!!!/</url>
      
        <content type="html"><![CDATA[<p><strong>优雅停机，就是在要关闭服务之前，不是立马全部关停，而是做好一些善后操作，比如：关闭线程、释放连接资源等。</strong></p><p>再比如，就是不会让调用方的请求处理了一增，一下就中断了。而处理完本次后，再停止服务。</p><p>Java语言中，我们可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook();</span><br></pre></td></tr></table></figure><p>方法来注册钩子，以保证程序平滑退出。（其他语言也类似）</p><p>来个栗子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用线程池处理任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设有5个线程需要执行任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> id = i;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : thread_&quot;</span> + id + <span class="string">&quot; start...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(id);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : thread_&quot;</span> + id + <span class="string">&quot; finish!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            executorService.submit(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个钩子处理未完任务</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No1 shutdown hooking...&quot;</span>);</span><br><span class="line">                <span class="keyword">boolean</span> shutdown = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executorService.shutdown();</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; shutdown signal got, wait threadPool finish.&quot;</span>);</span><br><span class="line">                    executorService.awaitTermination(<span class="number">1500</span>, TimeUnit.SECONDS);</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; all thread&#x27;s done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No1 shutdown done...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 多个关闭钩子并发执行</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No2 shutdown hooking...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; No2 shutdown done...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(<span class="string">&quot;main method exit...&quot;</span>);</span><br><span class="line">        <span class="comment">// 故意调用jvm退出命令，发送关闭信号，否则正常情况下 jvm 会等待最后一个非守护线程关闭才会退出</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr7pe2iaeSicBuGxwcDcL37CZwmow3OzYRKPCYBGiblZfEf1qe3D4Nibia91aR4wrk4uAwFwOsztoUPEgWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>很明显，确实是优雅了，虽然最后收到了一关闭信号，但是仍然保证了任务的处理完成。很棒吧！</p><p>那么，在实际应用中是如何体现优雅停机呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -15 pid</span><br></pre></td></tr></table></figure><p>通过该命令发送一个关闭信号给到jvm, 然后就开始执行 Shutdown Hook 了，你可以做很多:</p><p>1、 关闭 socket 链接</p><p>2、 清理临时文件</p><p>3、 发送消息通知给订阅方，告知自己下线</p><p>4、 将自己将要被销毁的消息通知给子进程</p><p>5、 各种资源的释放</p><p>…</p><p>而在平时工作中，我们不乏看到很多运维同学，是这么干的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><p>如果这么干的话，jvm也无法了,kill -9 相当于一次系统宕机，系统断电。这会给应用杀了个措手不及，没有留给应用任何反应的机会。</p><p>所以，无论如何是优雅不起来了。</p><p>要优雅，是代码</p><p>其中，线程池的关闭方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line">executorService.awaitTermination(<span class="number">1500</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor 在 shutdown 之后会变成 SHUTDOWN 状态，无法接受新的任务，随后等待正在执行的任务执行完成。意味着，shutdown 只是发出一个命令，至于有没有关闭还是得看线程自己。</p><p>ThreadPoolExecutor 对于 shutdownNow 的处理则不太一样，方法执行之后变成 STOP 状态，并对执行中的线程调用 Thread.interrupt() 方法（但如果线程未处理中断，则不会有任何事发生），所以并不代表“立刻关闭”。</p><p>shutdown() ：启动顺序关闭，其中执行先前提交的任务，但不接受新任务。如果已经关闭，则调用没有附加效果。此方法不等待先前提交的任务完成执行。</p><p>shutdownNow()：尝试停止所有正在执行的任务，停止等待任务的处理，并返回正在等待执行的任务的列表。当从此方法返回时，这些任务将从任务队列中耗尽（删除）。此方法不等待主动执行的任务终止。</p><p>executor.awaitTermination(this.awaitTerminationSeconds, TimeUnit.SECONDS)); 控制等待的时间，防止任务无限期的运行（前面已经强调过了，即使是 shutdownNow 也不能保证线程一定停止运行）。</p><p>注意:</p><p>虚拟机会对多个ShutdownHook以未知的顺序调用，都执行完后再退出。</p><p>如果接收到 kill -15 pid 命令时，执行阻塞操作，可以做到等待任务执行完成之后再关闭 JVM。同时，也解释了一些应用执行 kill -15 pid 无法退出的问题，如:中断被阻塞了,或者hook运行了死循环代码。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java8中Stream的实现原理</title>
      <link href="2020/11/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java8%E4%B8%ADStream%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2020/11/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java8%E4%B8%ADStream%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>我们经常会使用Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？</p><p>比如Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线的原理，这是Stream实现的关键所在。</p><p>首先回顾一下容器执行Lambda表达式的方式，以<code>ArrayList.forEach()</code>方法为例，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList.forEach()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);<span class="comment">// 回调方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到<code>ArrayList.forEach()</code>方法的主要逻辑就是一个<em>for</em>循环，在该<em>for</em>循环里不断调用<code>action.accept()</code>回调方法完成对元素的遍历。</p><p>这完全没有什么新奇之处，回调方法在Java GUI的监听器中广泛使用。Lambda表达式的作用就是相当于一个回调方法，这很好理解。</p><p>Stream API中大量使用Lambda表达式作为回调方法，但这并不是关键。理解Stream我们更关心的是另外两个问题：流水线和自动并行。使用Stream或许很容易写入如下形式的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> longestStringLengthStartingWithA</span><br><span class="line">        = strings.stream()</span><br><span class="line">              .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">              .mapToInt(String::length)</span><br><span class="line">              .max();</span><br></pre></td></tr></table></figure><p>上述代码求出以字母<em>A</em>开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。</p><p>类库的实现着使用流水线（<em>Pipeline</em>）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了Stream的所有操作。</p><table><thead><tr><th>Stream操作分类</th><th></th><th></th></tr></thead><tbody><tr><td>中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip()</td><td></td></tr><tr><td>结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td><td></td></tr></tbody></table><p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(<em>Stateless</em>)和有状态的(<em>Stateful</em>)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果。</p><p>比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如<em>找到第一个满足条件的元素</em>。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p><p>为了更好的理解流的中间操作和终端操作，可以通过下面的两段代码来看他们的执行过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;\nA&quot;</span> + x))</span><br><span class="line">   .limit(<span class="number">3</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;B&quot;</span> + x))</span><br><span class="line">   .forEach(x -&gt; System.out.print(<span class="string">&quot;C&quot;</span> + x));</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A1B1C1</span><br><span class="line">A2B2C2</span><br><span class="line">A3B3C3</span><br></pre></td></tr></table></figure><p>中间操作是懒惰的，也就是中间操作不会对数据做任何操作，直到遇到了最终操作。而最终操作，都是比较热情的。他们会往前回溯所有的中间操作。也就是当执行到最后的forEach操作的时候，它会回溯到它的上一步中间操作，上一步中间操作，又会回溯到上上一步的中间操作，…，直到最初的第一步。</p><p>第一次forEach执行的时候，会回溯peek 操作，然后peek会回溯更上一步的limit操作，然后limit会回溯更上一步的peek操作，顶层没有操作了，开始自上向下开始执行，输出：A1B1C1 第二次forEach执行的时候，然后会回溯peek 操作，然后peek会回溯更上一步的limit操作，然后limit会回溯更上一步的peek操作，顶层没有操作了，开始自上向下开始执行，输出：A2B2C2</p><p>… 当第四次forEach执行的时候，然后会回溯peek 操作，然后peek会回溯更上一步的limit操作，到limit的时候，发现limit(3)这个job已经完成，这里就相当于循环里面的break操作，跳出来终止循环。</p><p>再来看第二段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;\nA&quot;</span> + x))</span><br><span class="line">   .skip(<span class="number">6</span>)</span><br><span class="line">   .peek(x -&gt; System.out.print(<span class="string">&quot;B&quot;</span> + x))</span><br><span class="line">   .forEach(x -&gt; System.out.print(<span class="string">&quot;C&quot;</span> + x));</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A1</span><br><span class="line">A2</span><br><span class="line">A3</span><br><span class="line">A4</span><br><span class="line">A5</span><br><span class="line">A6</span><br><span class="line">A7B7C7</span><br><span class="line">A8B8C8</span><br><span class="line">A9B9C9</span><br></pre></td></tr></table></figure><p>第一次forEach执行的时候，会回溯peek操作，然后peek会回溯更上一步的skip操作，skip回溯到上一步的peek操作，顶层没有操作了，开始自上向下开始执行，执行到skip的时候，因为执行到skip，这个操作的意思就是跳过，下面的都不要执行了，也就是就相当于循环里面的continue，结束本次循环。输出：A1</p><p>第二次forEach执行的时候，会回溯peek操作，然后peek会回溯更上一步的skip操作，skip回溯到上一步的peek操作，顶层没有操作了，开始自上向下开始执行，执行到skip的时候，发现这是第二次skip，结束本次循环。输出：A2</p><p>…</p><p>第七次forEach执行的时候，会回溯peek操作，然后peek会回溯更上一步的skip操作，skip回溯到上一步的peek操作，顶层没有操作了，开始自上向下开始执行，执行到skip的时候，发现这是第七次skip，已经大于6了，它已经执行完了skip(6)的job了。这次skip就直接跳过，继续执行下面的操作。输出：A7B7C7</p><p>…直到循环结束。</p><p>面试题推荐：100期面试题汇总</p><h2 id="一种直白的实现方式"><a href="#一种直白的实现方式" class="headerlink" title="一种直白的实现方式"></a>一种直白的实现方式</h2><p>仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。</p><p>具体说来，就是调用<code>filter()</code>方法后立即执行，选出所有以<em>A</em>开头的字符串并放到一个列表list1中，之后让list1传递给<code>mapToInt()</code>方法并立即执行，生成的结果放到list2中，最后遍历list2找出最大的数字作为最终结果。程序的执行流程如如所示：</p><p><img src="https://i.loli.net/2020/11/24/DKJ23moc9dEPHsA.png" alt="Stream Pipeline"></p><p>这样做实现起来非常简单直观，但有两个明显的弊端：</p><ol><li>迭代次数多。迭代次数跟函数调用的次数相等。</li><li>频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。</li></ol><p>这些弊端使得效率底下，根本无法接受。如果不使用Stream API我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String str : strings)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.startsWith(<span class="string">&quot;A&quot;</span>))&#123;<span class="comment">// 1. filter(), 保留以A开头的字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = str.length();<span class="comment">// 2. mapToInt(), 转换成长度</span></span><br><span class="line">        longest = Math.max(len, longest);<span class="comment">// 3. max(), 保留最长的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟Stream API等价的功能，但问题是Stream类库的设计者并不知道用户的意图是什么。</p><p>如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。</p><p>面试题推荐：100期面试题汇总</p><h2 id="Stream流水线解决方案"><a href="#Stream流水线解决方案" class="headerlink" title="Stream流水线解决方案"></a>Stream流水线解决方案</h2><p>我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：</p><ol><li>用户的操作如何记录？</li><li>操作如何叠加？</li><li>叠加之后的操作如何执行？</li><li>执行后的结果（如果有）在哪里？</li></ol><h3 id="操作如何记录"><a href="#操作如何记录" class="headerlink" title="操作如何记录"></a>操作如何记录</h3><p>注意这里使用的是“*操作(operation)*”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是&lt;*数据来源，操作，回调函数*&gt;构成的三元组。</p><p>Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的<em>PipelineHelper</em>来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。</p><p><img src="https://i.loli.net/2020/11/24/HR2qW49MJAe3iBm.png" alt="关系图"></p><p>还有<em>IntPipeline, LongPipeline, DoublePipeline</em>没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟<em>ReferencePipeline</em>是并列关系。</p><p>图中<em>Head</em>用于表示第一个Stage，即调用调用诸如<em>Collection.stream()\</em>方法产生的Stage，很显然这个Stage里不包含任何操作；*StatelessOp*和*StatefulOp*分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。</p><p>Stream流水线组织结构示意图如下：</p><p><img src="https://i.loli.net/2020/11/24/vBNjQsaw68f3HzS.png" alt="Stream流水线组织结构示意图"></p><p>图中通过<code>Collection.stream()</code>方法得到<em>Head</em>也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。<strong>这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作</strong>。这就是Stream记录操作的方式。</p><h3 id="操作如何叠加"><a href="#操作如何叠加" class="headerlink" title="操作如何叠加"></a>操作如何叠加</h3><p>以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。</p><p>这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。</p><p>这种协议由<em>Sink</em>接口完成，<em>Sink</em>接口包含的方法如下表所示：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void begin(long size)</td><td>开始遍历元素之前调用该方法，通知Sink做好准备。</td></tr><tr><td>void end()</td><td>所有元素遍历完成之后调用，通知Sink没有更多的元素了。</td></tr><tr><td>boolean cancellationRequested()</td><td>是否可以结束操作，可以让短路操作尽早结束。</td></tr><tr><td>void accept(T t)</td><td>遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前Stage.accept(T t)方法就行了。</td></tr></tbody></table><p>有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的<code>accept()</code>方法即可，并不需要知道其内部是如何处理的。</p><p>当然对于有状态的操作，Sink的<code>begin()</code>和<code>end()</code>方法也是必须实现的。比如Stream.sorted()是一个有状态的中间操作，其对应的Sink.begin()方法可能创建一个盛放结果的容器，而accept()方法负责将元素添加到该容器，最后end()负责对容器进行排序。</p><p>对于短路操作，<code>Sink.cancellationRequested()</code>也是必须实现的，比如Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回<em>true</em>，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。</p><p><strong>实际上Stream API内部实现的的本质，就是如何重写Sink的这四个接口方法</strong>。</p><p>有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。一种可能的Sink.accept()方法流程是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(U u)</span></span>&#123;</span><br><span class="line">    <span class="number">1.</span> 使用当前Sink包装的回调函数处理u</span><br><span class="line">    <span class="number">2.</span> 将处理结果传递给流水线下游的Sink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sink接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。</p><p>下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看Stream.map()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.map()，调用该方法将产生一个新的Stream</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/*opWripSink()方法返回由回调函数包装而成Sink*/</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; downstream)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    R r = mapper.apply(u);<span class="comment">// 1. 使用当前Sink包装的回调函数mapper处理u</span></span><br><span class="line">                    downstream.accept(r);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看似复杂，其实逻辑很简单，就是将回调函数<em>mapper</em>包装到一个Sink当中。由于Stream.map()是一个无状态的中间操作，所以map()方法返回了一个StatelessOp内部类对象（一个新的Stream），调用这个新Stream的opWripSink()方法将得到一个包装了当前回调函数的Sink。</p><p>再来看一个复杂一点的例子。Stream.sorted()方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，sorted()方法是如何将操作封装成Sink的呢？sorted()一种可能封装的Sink代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.sort()方法用到的Sink实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;<span class="comment">// 存放用于排序的元素</span></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; downstream, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(downstream, comparator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建一个存放排序元素的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.sort(comparator);<span class="comment">// 只有元素全部接收之后才能开始排序</span></span><br><span class="line">        downstream.begin(list.size());</span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;<span class="comment">// 下游Sink不包含短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 下游Sink包含短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;<span class="comment">// 每次都调用cancellationRequested()询问是否可以结束处理。</span></span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);<span class="comment">// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码完美的展现了Sink的四个接口方法是如何协同工作的：</p><ol><li>首先begin()方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；</li><li>之后通过accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；</li><li>最后end()方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；</li><li>如果下游的Sink是短路操作，将结果传递给下游时不断询问下游cancellationRequested()是否可以结束处理。</li></ol><h3 id="叠加之后的操作如何执行"><a href="#叠加之后的操作如何执行" class="headerlink" title="叠加之后的操作如何执行"></a>叠加之后的操作如何执行</h3><p><img src="https://i.loli.net/2020/11/24/cd9faq7bTvUJil4.png" alt="调用关系"></p><p>Sink完美封装了Stream每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。</p><p>是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。</p><p>结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。</p><p>结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理-&gt;转发]模型，结束操作的Sink就是调用链的出口。</p><p>我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在<em>PipelineHelper</em>中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。</p><p>但Stream类库的设计者没有这么做，而是设置了一个<code>Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)</code>方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？</p><p>这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.wrapSink()</span></span><br><span class="line"><span class="comment">// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，</span></span><br><span class="line"><span class="comment">// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());<span class="comment">// 通知开始遍历</span></span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);<span class="comment">// 迭代</span></span><br><span class="line">        wrappedSink.end();<span class="comment">// 通知遍历结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代，最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。后端技术精选公众号内回复“后端面试”，送你一份Java面试题宝典</p><h3 id="执行后的结果在哪里"><a href="#执行后的结果在哪里" class="headerlink" title="执行后的结果在哪里"></a>执行后的结果在哪里</h3><p>最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(<em>Side-effects</em>)，比如使用<code>Stream.forEach()</code>方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？</p><blockquote><p>特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的收集方式</span></span><br><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">      .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br><span class="line"><span class="comment">// 正确的收集方式</span></span><br><span class="line">List&lt;String&gt;results =</span><br><span class="line">     stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">             .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></span><br></pre></td></tr></table></figure><p>回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。</p><table><thead><tr><th>返回类型</th><th>对应的结束操作</th></tr></thead><tbody><tr><td>boolean</td><td>anyMatch() allMatch() noneMatch()</td></tr><tr><td>Optional</td><td>findFirst() findAny()</td></tr><tr><td>归约结果</td><td>reduce() collect()</td></tr><tr><td>数组</td><td>toArray()</td></tr></tbody></table><ol><li>对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。</li><li>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用reduce()方法实现的。</li><li>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做<em>Node</em>的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文详细介绍了Stream流水线的组织方式和执行过程，学习本文将有助于理解原理并写出正确的Stream代码，同时打消你对Stream API效率方面的顾虑。如你所见，Stream API实现如此巧妙，即使我们使用外部迭代手动编写等价代码，也未必更加高效。</p><p>注：留下本文所用的JDK版本，以便有考究癖的人考证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br><span class="line">java version &quot;1.8.0_101&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_101-b13)</span><br><span class="line">Java HotSpot(TM) Server VM (build 25.101-b13, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>epub阅读软件分享</title>
      <link href="2020/11/23/epub%E9%98%85%E8%AF%BB%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
      <url>2020/11/23/epub%E9%98%85%E8%AF%BB%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>智能时代，碎片化信息充斥 着我们的生活。手机不离手，各种社交/新闻软件可以使我们快速摄取信息知识。但是这种信息是片面的，不完整。看似我们获取了很多知识，但这些快餐式的信息传递并不能很好的提升我们的知识广度。还是完完整整的从书本中学习来的更踏实和全面。</p><p>电子书的普及和使用已经是非常完善的了。各种看电子书的设备/阅读软件/电子书格式满足不同的阅读需求。其实没有特别情况或者是经济方面比较宽松的情况下，不太需要购买专门的阅读设备，在手机上使用比较合适的阅读软件也能有很好的阅读体验。并且手机是随身物品，更方便随时阅读，不放过零碎时间。</p><p>铺垫了这么多是想给大家分享一下我使用过一些不错的阅读软件。最近使用epub格式电子书比较多，下面给大家说说可以支持epub格式的阅读软件。</p><h3 id="Neat-Reader"><a href="#Neat-Reader" class="headerlink" title="Neat Reader"></a>Neat Reader</h3><p>当时发现这款阅读器是想在应用商店找一找比较适合本地阅读的软件，neat reader是令我比较惊喜的。软件内部是没有书店书城来提供一些电子书资源的，但是作为看已有的电子书十分的适合。本地epub格式电子书可以一键传入软件中，书架上可以根据书名和最近阅读时间来排序。解析电子书打开速度也还不错，阅读提供了字体格式方面的自定义功能和阅读笔记方面的辅助功能。</p><p>整个软件是没有广告的，也没有什么书籍推荐，打开电子书就可以开始无打扰式阅读。登录账号有高级会员选项，可以额外获得10g云空间，解锁书架自定义排列和更多阅读设置。对于电子书很多又想随时不间断的阅读的用户，可以试试会员功能。</p><p>下载地址：<a href="https://links.jianshu.com/go?to=https://www.neat-reader.cn/">https://www.neat-reader.cn/</a></p><p><img src="https://upload-images.jianshu.io/upload_images/4129931-d34b5aa479238779.png" alt="img"></p><h3 id="Google-Play-Books"><a href="#Google-Play-Books" class="headerlink" title="Google Play Books"></a>Google Play Books</h3><p>看名字就知道是谷歌旗下的阅读软件了，这款软件不同于上一款，它拥有巨大的图书库，可以浏览上百万本好书。书城提供了一个很大的阅读平台，购买的电子书可以直接放在书架上。（顺便一说电子书的购买还是有些贵的）。</p><p>不仅可以线上阅读，支持epub格式和pdf格式的电子书，也可以阅读本地的图书。比较吸引人的一点是文本语音转换引擎可以在软件内大声朗读书籍。并且线上是有有声读物在贩的，在购买前支持试听。阅读时添加的注释可以与Google云端硬盘同步，但是好像没有直接导出功能。</p><p>下载地址：<a href="https://links.jianshu.com/go?to=https://play.google.com/store/apps/details?id=com.google.android.apps.books&hl=en_US">https://play.google.com/store/apps/details?id=com.google.android.apps.books&amp;hl=en_US</a></p><p><img src="https://upload-images.jianshu.io/upload_images/4129931-cafef508cd3e21bf.png" alt="img"></p><h3 id="Moon-Reader"><a href="#Moon-Reader" class="headerlink" title="Moon+ Reader"></a>Moon+ Reader</h3><p>这款可支持的格式比较多，epub, pdf,azw3, mobi, fb2, prc, chm, cbz, cbr等多种格式都可以支持使用。可以连接多个在线书库，内容算是比较丰富。而且它的自定义功能相当多，背景/主题/字体/配色/间距等等有很多选择，白天和夜晚模式也都分别有设置选项。阅读辅助功能除了基本功能，还有翻译功能可使用。</p><p>书架管理方面，可以选择我的珍藏/下载/作者/书籍分类，而且支持自制封面。可以说这款阅读软件比较全面，很是适合阅读的电子书格式比较杂乱的用户。但是我个人不是非常喜欢，感觉稍微有些累赘了。这款免费版是有弹窗广告的，高级版本没有广告而且可以解锁更多自定义功能。</p><p>下载地址：<a href="https://links.jianshu.com/go?to=http://www.moondownload.com/">http://www.moondownload.com/</a></p><p><img src="https://upload-images.jianshu.io/upload_images/4129931-f2538c3c202b5e3a.png" alt="img"></p><p>以上就是我分享的3款软件，它们功能不是很相同，但是使用感方面相当不错。如果你的手机缺一款阅读软件，可以试试我分享的这些。最后，还是想和大家说不要花太多的时间在一些快消新闻/段子上，让读书成为一种习惯。</p>]]></content>
      
      
      <categories>
          
          <category> activate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows10 添加Hyper-V</title>
      <link href="2020/11/23/win10%E6%B2%A1%E6%9C%89Hyper-V%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2020/11/23/win10%E6%B2%A1%E6%9C%89Hyper-V%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>你还在找<code>Windows10</code>家庭版中开启<code>Hyper-v</code>的方法？如果你是因为要用<code>Docker for Windows</code>版本的话，我建议你去升级专业版</p><p><code>Windows10</code>家庭版添加<code>Hyper-V</code>的方法<br>将下面的内容复制到编辑器或者记事本当中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;%~dp0&quot;</span>``<span class="built_in">dir</span> /b %SystemRoot%\servicing\Packages\*Hyper<span class="literal">-V</span>*.mum &gt;hyper<span class="literal">-v</span>.txt``<span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;</span>) <span class="keyword">do</span> dism /online /norestart /<span class="built_in">add-package</span>:<span class="string">&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span>``<span class="built_in">del</span> hyper<span class="literal">-v</span>.txt``Dism /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Hyper</span><span class="literal">-V</span><span class="literal">-All</span> /LimitAccess /ALL</span><br></pre></td></tr></table></figure><p>进行保存，保存为<code>Hyper-V.cmd</code></p><p>在系统桌面上，我们找到并右键点击【Hyper-V.cmd】文件图标，在右键菜单中点击：<code>以管理员身份运行（A）</code></p><p>然后弹出一个 用户帐户控制 – Windows命令处理程序 对话框，我们点击：是</p><p>紧接着进行Windows命令处理，我们等待处理完成以后</p><p><img src="https://i.loli.net/2020/11/20/XktuN2zgAe1bRQ4.png" alt="命令"></p><p>在最末处输入：Y，电脑自动重启，进行配置更新。注意：不能关闭计算机</p><p>配置更新重启完成以后，我们去控制面板、所有控制面板项、程序和功能，点击启用或关闭<code>Windows</code>功能，就会发现我们已经有了<code>Hyper-v</code>功能</p><p><img src="https://i.loli.net/2020/11/20/FbMALVgGOqZINJU.jpg" alt="window功能"></p><p><strong>笔者认为Hyper-V不太方便，建议使用VMware或其它</strong>，提供一下VMware破解网盘地址，三个版本可以根据需要下载。PS：如果需要网盘破解地址可以留言或私信联系。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1LlLPbSEqmKbpb4ZnHfu3kg">https://pan.baidu.com/s/1LlLPbSEqmKbpb4ZnHfu3kg</a><br>提取码：irgp<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么要分16个库</title>
      <link href="2020/11/20/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%8616%E4%B8%AA%E5%BA%93/"/>
      <url>2020/11/20/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%8616%E4%B8%AA%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>  在实际的项目中，Redis常被用作缓存、分布式锁、消息队列等的解决方案。但是在搭建好Redis服务后，Redis默认创建了<strong>16个数据库（db0~db15）</strong>，而在Redis集群下只有一个<strong>db0数据库</strong>。如下图所示。</p><p><img src="https://i.loli.net/2020/11/20/XL2egauRUC9Wkb8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQyNzEyOQ==,size_16,color_FFFFFF,t_70" alt="redis单机">  <img src="https://i.loli.net/2020/11/20/BiUfXu8aFpwxO2R.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQyNzEyOQ==,size_16,color_FFFFFF,t_70" alt="redis集群"></p><h3 id="一、16个数据库的由来"><a href="#一、16个数据库的由来" class="headerlink" title="一、16个数据库的由来"></a>一、16个数据库的由来</h3><p>  Redis是一个类似于<strong>字典结构</strong>的存储服务器，一个Redis实例提供了<strong>多个用来存储数据的字典</strong>，在客户端可以指定将数据存储于哪个字典中。这与在一个关系数据库实例中创建多个数据库类似，所以，可以将Redis中的每个字典都理解为一个独立的数据库。</p><p><img src="https://i.loli.net/2020/11/20/wzmtKMXQSunWgo8.png" alt="在这里插入图片描述"><br>  我们讲过Redis默认支持16个数据库，这可以通过修改Redis的配置文件/redis/redis.conf中的<strong>databases字段</strong>的值，设置完毕并重启Redis即可完成配置。</p><p><img src="https://i.loli.net/2020/11/20/k7aW1VlCZdRnMgz.jpg" alt="img"><br>  此外，客户端与Redis建立连接之后，默认会选择0号数据库即db0，但可以使用**<code>select</code>命令**更换存储的数据库。</p><p><img src="https://i.loli.net/2020/11/20/SVgpJ6OdNb7Kxfe.png" alt="更换db"></p><p>  也可以通过修改配置文件的方式选择默认数据库。</p><p><img src="https://i.loli.net/2020/11/20/7DMR6zBv4EKaLQc.jpg" alt="配置文件"></p><h3 id="二、正解Redis数据库概念"><a href="#二、正解Redis数据库概念" class="headerlink" title="二、正解Redis数据库概念"></a>二、正解Redis数据库概念</h3><p>  可以看到，Redis的数据库都以<strong>db+编号</strong>的方式命名，这是因为Redis不支持自定义数据库名。开发者则需要自己记录存储的数据与数据库之间的对应关系。此外，<strong>Redis不支持为每个数据库设置不同的访问密码，即客户端要么可以访问全部的数据库，要么所有的数据库都不能被访问。</strong></p><p>  Redis中存在这么一个命令<code>flushall</code>，该命令可以清空当前Redis实例下所有数据库的数据。这与类似于mysql的关系型数据库不同，<strong>关系型数据库的每个数据库常用于存储不同应用程序的数据，且不提供清除当前实例下所有数据库数据的方法。</strong></p><p>  因此，对于Redis来说，用<strong>命名空间</strong>的方式理解Redis提供的<strong>db0~db15数据库</strong>会更合适，且一个Redis实例不适合存储多个应用程序的数据。比如，我们可以这么做：<strong>使用db0数据库存储应用程序在生产环境的数据，用db1数据库存储测试环境的数据。</strong>但是，<strong>不适合用db0数据库存储应用程序A的数据，用db1存储应用程序B的数据。**</strong>不同的应用程序应使用不同的Redis实例。<strong>此外，我们不必担心使用过多的Redis实例造成数据库服务压力过大，因为Redis是非常轻量级的，</strong>一个空的Redis实例占用的内存只有1MB左右。**</p><h3 id="三、集群环境下的Redis实例"><a href="#三、集群环境下的Redis实例" class="headerlink" title="三、集群环境下的Redis实例"></a>三、集群环境下的Redis实例</h3><p>  在单体Redis的情况下可以使用<code>select</code>命令来实现数据库的切换，但在集群环境下，Redis不支持使用<code>select</code>命令来切换数据库，这是因为在集群环境下只有一个<strong>db0数据库</strong>。集群与单体Redis的区别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、key批量操作支持有限：例如mget、mset必须在一个slot；</span><br><span class="line"><span class="number">2</span>、Key事务和Lua支持有限：操作的key必须在一个节点；</span><br><span class="line"><span class="number">3</span>、key是数据分区的最小粒度：不支持bigkey分区；</span><br><span class="line"><span class="number">4</span>、不支持多个数据库：集群模式下只有一个db0；</span><br><span class="line"><span class="number">5</span>、复制只支持一层：不支持树形复制结构。</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ul><li>Redis实例默认创建了16个数据库，且不支持自定义命名，以dbX的方式命名（db0~db15）；</li><li>默认数据库的数量可以在配置文件中修改；</li><li>应以命名空间的方式理解Redis数据库db，<strong>多个应用程序不应使用同一个Redis的不同库，而应一个应用程序对应一个Redis实例，不同的数据库可用于存储不同环境的数据。</strong></li><li><strong>Redis集群下只有db0，不支持多db。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eureka注册指定IP段</title>
      <link href="2020/11/19/Eureka%E6%B3%A8%E5%86%8C%E6%8C%87%E5%AE%9AIP%E6%AE%B5/"/>
      <url>2020/11/19/Eureka%E6%B3%A8%E5%86%8C%E6%8C%87%E5%AE%9AIP%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>最近项目在Eureka注册时，发现一个问题：注册的IP地址不是 10.10.3.XXX 的网络IP，而是另外一个网段的地址。</p><p>通过 ipconfig 命令查看本机的IP地址发现，该IP是本机虚拟网卡VMware的地址。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">无线局域网适配器 本地连接* <span class="number">13</span>:</span><br><span class="line"></span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line"></span><br><span class="line">以太网适配器 以太网 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">65</span>b2:b524:<span class="number">664</span>b:c414%<span class="number">13</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">10</span>.<span class="number">10</span>.<span class="number">3</span>.<span class="number">208</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . : <span class="number">10</span>.<span class="number">10</span>.<span class="number">3</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">以太网适配器 VMware Network Adapter VMnet1:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::d86f:a26d:c8f6:<span class="number">7038</span>%<span class="number">3</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192</span>.<span class="number">168</span>.<span class="number">15</span>.<span class="number">1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line"></span><br><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">6415</span>:<span class="number">235</span>:<span class="number">98</span>c4:<span class="number">9</span>ca7%<span class="number">2</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192</span>.<span class="number">168</span>.<span class="number">38</span>.<span class="number">1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></table></figure><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>Eureka管理页面注册列表展示的IP地址非局域网IP地址，是虚拟机的虚拟IP地址</p><h3 id="可能引起的问题"><a href="#可能引起的问题" class="headerlink" title="可能引起的问题"></a>可能引起的问题</h3><p>多人开发时，同事通过Feign调用接口，无法正确匹配IP地址，从而导致接口调用失败。</p><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>通过百度查找，提供了该解决方案：在 yml 文件中添加一下的配置，以达到忽略指定网卡的目的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">ignored-interfaces:</span> <span class="comment">## 忽略网卡</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">VMware.*</span></span><br></pre></td></tr></table></figure><p><strong>可是当我添加该配置后，发现仍不起作用！</strong>页面上显示的instance-id 还是 192.168.38.1 。这就很难受了</p><h2 id="刨根问底"><a href="#刨根问底" class="headerlink" title="刨根问底"></a>刨根问底</h2><p>于是我想能不能跑一跑Spring的启动代码，看看他到底是怎么取IP的。首先从Eureka自动配置类EurekaClientAutoConfiguration入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title">eurekaInstanceConfigBean</span><span class="params">(InetUtils inetUtils,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;</span><br><span class="line">    String hostname = getProperty(<span class="string">&quot;eureka.instance.hostname&quot;</span>);</span><br><span class="line">    <span class="comment">// 是否使用IP地址注册。这里就是从配置文件寻值，没找到就用默认值 false</span></span><br><span class="line">    <span class="keyword">boolean</span> preferIpAddress = Boolean.parseBoolean(getProperty(<span class="string">&quot;eureka.instance.prefer-ip-address&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取配置的IP地址</span></span><br><span class="line">    String ipAddress = getProperty(<span class="string">&quot;eureka.instance.ip-address&quot;</span>);</span><br><span class="line"></span><br><span class="line">    instance.setPreferIpAddress(preferIpAddress);</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(ipAddress)) &#123;</span><br><span class="line">        instance.setIpAddress(ipAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，Eureka并没有自己直接去系统获取IP地址，而是通过Spring的InetUtils类的findFirstNonLoopbackHostInfo来设置IP地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EurekaInstanceConfigBean</span><span class="params">(InetUtils inetUtils)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inetUtils = inetUtils;</span><br><span class="line">    <span class="keyword">this</span>.hostInfo = <span class="keyword">this</span>.inetUtils.findFirstNonLoopbackHostInfo();</span><br><span class="line">    <span class="keyword">this</span>.ipAddress = <span class="keyword">this</span>.hostInfo.getIpAddress();</span><br><span class="line">    <span class="keyword">this</span>.hostname = <span class="keyword">this</span>.hostInfo.getHostname();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看看findFirstNonLoopbackHostInfo()方法的代码。我在本地Debug跑的时候，项目启动该类会被调用两次，一次没有读取配置文件，项目启动Banner也没有打印，第二次配置文件已经读取。启动日志也打印了一部分。这里原因留个坑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">findFirstNonLoopbackAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InetAddress result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lowest = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (Enumeration&lt;NetworkInterface&gt; nics = NetworkInterface</span><br><span class="line">.getNetworkInterfaces(); nics.hasMoreElements();) &#123;</span><br><span class="line">NetworkInterface ifc = nics.nextElement();</span><br><span class="line">                <span class="comment">// 该网络接口是否启用并正在运行。调用的是native方法</span></span><br><span class="line"><span class="keyword">if</span> (ifc.isUp()) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;Testing interface: &quot;</span> + ifc.getDisplayName());</span><br><span class="line"><span class="keyword">if</span> (ifc.getIndex() &lt; lowest || result == <span class="keyword">null</span>) &#123;</span><br><span class="line">lowest = ifc.getIndex();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该网卡名称不在忽略范围内</span></span><br><span class="line"><span class="comment">// @formatter:off</span></span><br><span class="line"><span class="keyword">if</span> (!ignoreInterface(ifc.getDisplayName())) &#123;</span><br><span class="line">                        <span class="comment">// 遍历IP地址</span></span><br><span class="line"><span class="keyword">for</span> (Enumeration&lt;InetAddress&gt; addrs = ifc</span><br><span class="line">.getInetAddresses(); addrs.hasMoreElements();) &#123;</span><br><span class="line">InetAddress address = addrs.nextElement();</span><br><span class="line">                            <span class="comment">// 找到 IPV4 且不是回环地址(127.0.0.1) 且是优先选择的地址</span></span><br><span class="line"><span class="keyword">if</span> (address <span class="keyword">instanceof</span> Inet4Address</span><br><span class="line">&amp;&amp; !address.isLoopbackAddress()</span><br><span class="line">&amp;&amp; isPreferredAddress(address)) &#123;</span><br><span class="line">log.trace(<span class="string">&quot;Found non-loopback interface: &quot;</span></span><br><span class="line">+ ifc.getDisplayName());</span><br><span class="line">                     </span><br><span class="line">result = address;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @formatter:on</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">log.error(<span class="string">&quot;Cannot get first non-loopback address&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> InetAddress.getLocalHost();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">log.warn(<span class="string">&quot;Unable to retrieve localhost&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码及注释可以看到，SpringCloud选择IP的原则是：<strong>选择已启动网卡的第一个不在忽略范围且不是回环地址(127.0.0.1)且是优先选择地址的IPV4地址</strong></p><p>那么我们想要重定义其所选的IP地址，就需要从忽略范围 和 是否是优先选择地址来做了。</p><h3 id="判断是否在忽略范围的代码"><a href="#判断是否在忽略范围的代码" class="headerlink" title="判断是否在忽略范围的代码"></a>判断是否在忽略范围的代码</h3><p>由该段代码知，要忽略的网口集合需要从 IgnoredInterfaces 这个属性中获得，那这个属性的值是什么？怎么配置呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** for testing */</span> <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreInterface</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历IgnoredInterfaces属性集合，该集合内是忽略的网口名字的正则表达式形式</span></span><br><span class="line">    <span class="keyword">for</span> (String regex : <span class="keyword">this</span>.properties.getIgnoredInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaceName.matches(regex)) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Ignoring interface: &quot;</span> + interfaceName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否是首选地址的代码"><a href="#判断是否是首选地址的代码" class="headerlink" title="判断是否是首选地址的代码"></a>判断是否是首选地址的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** for testing */</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isPreferredAddress</span><span class="params">(InetAddress address)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果配置了仅使用本地接口，则当该InetAddress是本地站点地址时返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isUseOnlySiteLocalInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> siteLocalAddress = address.isSiteLocalAddress();</span><br><span class="line">        <span class="keyword">if</span> (!siteLocalAddress) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Ignoring address: &quot;</span> + address.getHostAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> siteLocalAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果preferredNetworks列表没有配置，则所有地址返回True</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; preferredNetworks = <span class="keyword">this</span>.properties.getPreferredNetworks();</span><br><span class="line">    <span class="keyword">if</span> (preferredNetworks.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果配置了，则返回符合正则的地址</span></span><br><span class="line">    <span class="keyword">for</span> (String regex : preferredNetworks) &#123;</span><br><span class="line">        <span class="keyword">final</span> String hostAddress = address.getHostAddress();</span><br><span class="line">        <span class="keyword">if</span> (hostAddress.matches(regex) || hostAddress.startsWith(regex)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.trace(<span class="string">&quot;Ignoring address: &quot;</span> + address.getHostAddress());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/19/c67Qf2Zb9OXmqtI.png" alt="断点"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>eureka 显示的 instance-id 有两种值，通过 prefer-ip-address 的值来选择</li></ol><ul><li>ip:端口 true</li><li>hostname 主机名 false(默认)</li></ul><ol><li>当 prefer-ip-address 的值为 true 时，eureka 取这个值：eureka.client.instance-id</li></ol><ul><li>配置文件中的： eureka.client.instance-id 。可以配置成自己手写的值，也可以自动获取，通过 ${spring.cloud.client.ip-address}/{server.port} 来获取。<strong>但是 spring.cloud.client.ip-address 值的取值有一个BUG，Spring 从 InetUtils 获取 ipaddress 作为该值。但是取得是刚刚项目启动时获取的 ipaddress 参数(在加载yml中的配置之前)</strong></li><li>如果没有配置就又取hostname了</li></ul><ol><li>feign / ribbon 调用地址使用的是读取配置文件后的地址。故配置了忽略名单后，显示的虽然错误。但不会影响服务调用。</li></ol><p>所以如果读者想要即不影响调用，又不影响直接看地址需要增加一下配置：</p><p>yml写法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">ignoredInterfaces:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">VMware.*</span> <span class="comment"># 忽略虚拟机网卡</span></span><br><span class="line">      <span class="attr">use-only-site-local-interfaces:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">preferred-networks:</span> <span class="number">10.10</span><span class="string">.*.*</span> <span class="comment"># 优先使用 10.10.*.*</span></span><br></pre></td></tr></table></figure><p>properties写法：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略虚拟机网卡</span></span><br><span class="line"><span class="meta">spring.cloud.inetutils.ignoredInterfaces</span>=<span class="string">VMware.*</span></span><br><span class="line"><span class="meta">spring.cloud.inetutils.use-only-site-local-interfaces</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 优先使用 10.10.*.*</span></span><br><span class="line"><span class="meta">spring.cloud.inetutils.preferred-networks</span>=<span class="string">10.10.*.*</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gas Mask：hosts 文件管理编辑利器</title>
      <link href="2020/11/17/Gas%20Mask%EF%BC%9Ahosts%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8/"/>
      <url>2020/11/17/Gas%20Mask%EF%BC%9Ahosts%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%BC%96%E8%BE%91%E5%88%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Gas-Mask：hosts-文件管理编辑利器"><a href="#Gas-Mask：hosts-文件管理编辑利器" class="headerlink" title="Gas Mask：hosts 文件管理编辑利器"></a>Gas Mask：hosts 文件管理编辑利器</h2><p>开发过程中，管理 hosts 文件是大部分程序员在切换环境的时候都接触过的事情。管理的方式特别简单，打开编辑器，注释某些行，反注释某些行。这个方式后来有更好的工具替代，就是本文要介绍的 Gas Mask。</p><p>经常地，我们在修改 hosts 的时候，面对一批 ip 容易分不清到底谁是谁，导致最后注释错误。我还因此把本来对开发环境的修改错误地修改到生产环境去了。</p><p>而 Gas Mask 能避免这样的错误。</p><p><img src="https://pic3.zhimg.com/a09acea151fb67a16801b8efe4b7571a_r.jpg" alt="img"></p><p>在这里我要介绍我使用的方式。</p><p>可以创建的类型总共有3种，LOCAL/REMOTE/COMBINED。</p><p>REMOTE ：主要是公共 hosts 文件的共享，一些人科学上网的方式就是通过这个，具体地址网上找一下。REMOTE 这种方式跟 LOCAL 是一样的区别只在于是否本地。</p><p>LOCAL ：如果你有多个环境，那么为每个环境分别创建一份 LOCAL 类型的 hosts。除了跟环境相关的配置，其他都不要放进去。每一个业务就是一份独立的 hosts，这是为了后边的 COMBINED 用法。</p><p>COMBINED：组合多个 hosts 文件为一个。如果没有这个功能，其实单单用 LOCAL 类型的 hosts 是可以的了，但还不够灵活。比方说「科学上网」的 hosts 是无论什么环境下都要配置的，那我不得不在创建每一个新的 hosts 以后，科学上网相关的记录都配置到 这个 hosts 中。</p><h4 id="网盘地址："><a href="#网盘地址：" class="headerlink" title="网盘地址："></a>网盘地址：</h4><blockquote><p>链接：<a href="https://pan.baidu.com/s/120Hn7I6dzVighhhvJWiHNw">https://pan.baidu.com/s/120Hn7I6dzVighhhvJWiHNw</a><br>提取码：eqr2<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA激活</title>
      <link href="2020/11/16/IDEA%E6%BF%80%E6%B4%BB/"/>
      <url>2020/11/16/IDEA%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="下载破解包"><a href="#下载破解包" class="headerlink" title="下载破解包"></a>下载破解包</h2><blockquote><p>链接：<a href="https://pan.baidu.com/s/1K35p2hyauEQvIN-iuwcXfw">https://pan.baidu.com/s/1K35p2hyauEQvIN-iuwcXfw</a><br>提取码：h4dz<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote><h2 id="下载最新的-IDEA-2020-2-1-版本安装包"><a href="#下载最新的-IDEA-2020-2-1-版本安装包" class="headerlink" title="下载最新的 IDEA 2020.2.1 版本安装包"></a>下载最新的 IDEA 2020.2.1 版本安装包</h2><p>我们先从 IDEA 官网下载 IDEA 2020.2.1 版本的安装包，下载链接如下：</p><blockquote><p> <a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a></p></blockquote><h2 id="先卸载老版本的-IDEA"><a href="#先卸载老版本的-IDEA" class="headerlink" title="先卸载老版本的 IDEA"></a>先卸载老版本的 IDEA</h2><blockquote><p>注意，如果电脑上之前有安装老版本的 IDEA, 需要先卸载干净，否则可能安装失败！</p><p>注意，一定要先卸载干净掉老版本的 IDEA。</p></blockquote><p>1.笔者之前安装了老版本的 IDEA, 所以要先卸载，未安装老版本 IDEA 的小伙伴直接看后面步骤就行:</p><p><img src="https://i.loli.net/2020/11/16/C2Q6ExFbmI5Rj4e.png" alt="卸载老版本的IDEA"></p><p>卸载成功后，双击刚刚下载好的 <code>idea</code> exe 格式安装包, 打开它；</p><h2 id="开始激活-IDEA-2020-2-1-版本"><a href="#开始激活-IDEA-2020-2-1-版本" class="headerlink" title="开始激活 IDEA 2020.2.1 版本"></a>开始激活 IDEA 2020.2.1 版本</h2><p>2.安装目录默认为 <code>C:\Program Files\JetBrains\IntelliJ IDEA 2020.2.1</code>, 这里笔者选择的是默认路径:</p><p><img src="https://i.loli.net/2020/11/16/RwWextUu6vykX9K.png" alt="IDEA 2020.2.1安装第一步"></p><p>3.勾选自己想要创建的桌面快捷方式，笔者的操作系统是 64 位的，所以勾选的 64 位快捷方式：</p><p><img src="https://i.loli.net/2020/11/16/j4oz1QfXyuI5GcD.png" alt="IDEA 2020.2.1安装第二步"></p><p>4.点击 <code>Install</code>：</p><p><img src="https://i.loli.net/2020/11/16/MHI6hz9SvganKlj.png" alt="IDEA 2020.2.1安装第三步"></p><p>5.安装完成后，勾选 <code>Run IntelliJ IDEA</code>，点击 <code>Finish</code> 运行软件:</p><p><img src="https://i.loli.net/2020/11/16/xJO6up71GkNmR5n.png" alt="IDEA 2020.2.1安装第四步"></p><p>6.等待 IDEA 2020.2.1 运行, 中间会先弹出一个注册框，我们勾选 <code>Evaluate for free</code>, 点击 <code>Evaluate</code>， 先试用30天:</p><p><img src="https://i.loli.net/2020/11/16/P7HzytADgUieWOG.png" alt="试用IDEA 30天"></p><p>7.进入 IDEA 中， 我们先随便建个 Java 工程， 然后将网盘中最新的 IDEA 破解补丁 <code>jetbrains-agent-latest.zip</code>拖入 IDEA 界面中，如下图所示：</p><p><img src="https://i.loli.net/2020/11/16/AMFljrsHbZJC4QN.png" alt="将最新的IDEA破解包拖入IDEA中"></p><p>8.拖入补丁后会弹框，点击 <code>restart</code> 重启 IDEA：</p><p><img src="https://i.loli.net/2020/11/16/mDWMd8JlpV3rQKO.png" alt="重启IDEA"></p><p>9.配置助手会提示您，需要使用哪种激活方式，这里我们选择默认的 <code>Activation Code</code>，通过安装参数来激活，点击<code>为IDEA安装</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LFq51qqupnaiTNn39w6zATiOTxZI2JYuRJEBlzmUDv4zeeNlXhMgJZVb0q5QkLr+CIUrSuNB7ucifrGXawLB4qswPOXYG7+ItDNUR/9UkLTUWlnHLX07hnR1USOrWIjTmbytcIKEdaI6x0RskyotuItj84xxoSBP/iRBW2EHpOc</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/16/mwOuL7jsfrBkFPv.png" alt="IDEA配置助手"></p><p><img src="https://i.loli.net/2020/11/16/MpP54SjOzHcWAJy.png" alt="IDEA 2020.2.1破解补丁安装成功"></p><ol><li>点击<code>是</code>，重启IDEA, 即激活成功啦~</li></ol><h2 id="验证-IDEA-是否激活成功"><a href="#验证-IDEA-是否激活成功" class="headerlink" title="验证 IDEA 是否激活成功"></a>验证 IDEA 是否激活成功</h2><p>你说激活成功就激活成功了？我咋不信呢？</p><p>别急，接下来我们就来验证一下 IDEA 是否已经激活成功了，步骤如下：</p><p>1.进入 IDEA 界面后，点击 <code>Help</code> -&gt; <code>Register</code> 查看：</p><p><img src="https://i.loli.net/2020/11/16/4kK9hAG5a6IsDfS.png" alt="img"></p><p>2.可以看到，已经成功激活至 2089 年辣，撸到老，哈哈~</p><p><img src="https://i.loli.net/2020/11/16/Rrdpsn1ebuyNMwY.png" alt="IDEA 2020.2.1版本激活到2089年了"></p>]]></content>
      
      
      <categories>
          
          <category> activate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unsafe和CAS</title>
      <link href="2020/11/13/Unsafe%E5%92%8CCAS/"/>
      <url>2020/11/13/Unsafe%E5%92%8CCAS/</url>
      
        <content type="html"><![CDATA[<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>​    Java无法直接访问底层操作系统，而是通过本地<code>native</code>方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类<code>Unsafe</code>，它提供了硬件级别的原子操作。这个类尽管里面的方法都是<code>public</code>的，但是并没有办法使用它们，JDK API文档也没有提供任何关于这个类中方法的介绍。总而言之，对于<code>Unsafe</code>类的使用都是受限的，只有授信的代码才能获得该类的实例，当然JDK库里面的类是可以随意使用的。</p><p>​    <code>Unsafe</code>提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过Java本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。</p><p>举两个栗子，比方说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field paramField)</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法可以用来获取给定的paramField的内存地址偏移量，这个值对于给定的<code>field</code>是唯一的且固定不变的。在比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class paramClass)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class paramClass)</span></span>;</span><br></pre></td></tr></table></figure><p>其中前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。next方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> paramLong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> paramLong)</span></span>;</span><br></pre></td></tr></table></figure><p>分别用来分配内存，扩充内存和释放内存的。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>​    CAS，<code>Compare and Swap</code>即比较并交换，设计并发算法时常用到的技术，<code>java.utile.concurrent</code>包完全建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。当前的处理器基本都支持CAS，只不过不同的厂家实现不一样罢了。CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回<code>true</code>，否则什么都不做并返回<code>false</code>。</p><p>CAS也是通过<code>Unsafe</code>实现的，看下一下三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure><p>就拿中间这个比较并交换<code>int</code>为例，如果我们不用CAS，那么代码大致是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        i = j;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这段代码在并发下是肯定有问题的，有可能线程1运行到了第5行正准备运行第7行，线程2运行了，把<code>i</code>修改为<code>10</code>，线程切换回去，线程1由于先前已经满足第5行的<code>if</code>了，所以导致这两个线程同时修改了变量<code>i</code>。解决办法也很简单，给<code>compareAndSwqpInt</code>方法加锁同步就行了，这样<code>compareAndSwapInt</code>方法就变成了一个原子操作。CAS也是一样的道理，比较、交换也是一组原子操作，不会被外部打断，先更加<code>paramLong/paramLong1</code>获取到内存中当前的内存值V，在将内存值V和原值A作比较，要是相等就修改为要修改的值B，由于CAS都是硬件级别的操作，因此效率会高一些。</p><p>由CAS分析<code>AtomicInteger</code>原理，<code>java.util.concurrent.atomic</code>包下的原子操作类都是基于CAS实现的，下面先分析一下<code>AtomicInteger</code>类变量的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>关于这段代码中出现的几个成员属性：</p><ol><li><code>Unsafe</code>是CAS的核心类</li><li><code>valueOffset</code>表示的是变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据原值的。</li><li>「关键」:value是用<code>volatile</code>修饰的</li></ol><p><code>AtomicInteger</code>中<code>getAndIncrement</code>是如何实现的，比如常用的<code>andAndGet</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + delta;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码如何在不加锁的情况下通过CAS实现线程安全：</p><ol><li><code>AtomicInteger</code>中<code>value</code>原始值为3，即主内存中<code>AtomicInteger</code>的<code>value</code>为3，根据Java内存模型，线程1和线程2各自持有一份<code>value</code>的副本，值为3.</li><li>线程1运行到第三行获取到当前的<code>value</code>为3，线程切换。</li><li>线程2开始运行，获取<code>value</code>为3，利用CAS对比内存中的值也为3，比较成功，修改内存，此时内存中的<code>value</code>改变比如说4，线程切换。</li><li>线程1恢复运行，利用CAS比较发现自己的<code>value</code>为3，内存中的<code>value</code>为4，得到一个重要的结论-&gt;此时<code>value</code>正在被另外一个线程修改，所以我不能去修改。</li><li>线程1的<code>compareAndSet</code>失败，循环判断，因为<code>value</code>是<code>volatile</code>修饰的，所以它具备可见性的特性，线程2对于<code>value</code>的改变能被线程1看到，只要线程1发现当前获取的<code>value</code>是4，内存中的<code>value</code>也是4，说明线程2对于<code>value</code>的修改已经完毕并且线程1可以尝试去修改它。</li><li>最后说一点，比如说此时线程3也准备修改<code>value</code>了，因为比较-交换是一个原子操作不可被打断，线程3修改了<code>value</code>，线程1进行<code>compareAndSet</code>的时候必然返回<code>false</code>，这样线程1会继续循环去获取最新的<code>value</code>并进行<code>compareAndSet</code>，直至获取的<code>value</code>和内存中<code>value</code>一致为止。</li></ol><p>整个过程中，利用CAS机制保证了对于<code>value</code>修改线程安全性。</p><h3 id="CAS缺点（ABA）"><a href="#CAS缺点（ABA）" class="headerlink" title="CAS缺点（ABA）"></a>CAS缺点（ABA）</h3><p>​    CAS这种操作显然无法涵盖并发下的所有场景，并且CAS从语义上来说也不是完美的，存在这一一个逻辑漏洞：如果一个变量初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其它线程修改过了吗？<strong>如果这段期间它的值曾经被改成了B，然后又改回A，那么CAS操作就会误认为它从来没有被修改过。</strong>这个漏洞称为CAS操作的<code>ABA</code>问题。<code>java.util.concurrent</code>包为了解决这个问题，提供了一个带有标记性的原子引用类<code>AtomicStampedRenference</code>，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较<del>鸡肋</del>，大部分情况下<code>ABA</code>问题并不会影响程序并发的正确性，如果需要解决<code>ABA</code>问题，使用传统的互斥同步可能回避原子类更加高效。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock原理</title>
      <link href="2020/11/13/ReentrantLock/"/>
      <url>2020/11/13/ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><h3 id="1-1-锁调用过程"><a href="#1-1-锁调用过程" class="headerlink" title="1.1 锁调用过程"></a>1.1 锁调用过程</h3><p>ReentrantLock把所有Lock接口的操作都委派到一个Sync类上，该类继承了AbstractQueuedSynchronizer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><p>Sync有两个子类<strong>NonfairSync（[default]非公平）</strong>、<strong>FairSync（公平）</strong></p><p>ReentrantLock.lock()方法调用过程</p><p><img src="https://i.loli.net/2020/11/05/hnENZDC4vGHKUOd.png" alt="非公平锁执行过程"></p><p>AbstractQueuedSynchronizer中抽象了绝大多数Lock的功能，而只把tryAcquire方法延迟到子类中实现。tryAcquire方法的语义在于用具体子类判断请求线程是否可以获得锁，无论成功与否AbstractQueuedSynchronizer都将处理后面的流程。</p><h3 id="1-2-加锁实现"><a href="#1-2-加锁实现" class="headerlink" title="1.2 加锁实现"></a>1.2 加锁实现</h3><p>AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在**<u>执行的线程并不在队列中</u>**，而那些等待执行的线程全部处于阻塞状态。</p><p>线程的显式阻塞是通过调用LockSupport.park()完成，而LockSupport.park()则调用sun.misc.Unsafe.park()本地方法，再进一步，HotSpot在Linux中中通过调用pthread_mutex_lock函数把线程交给系统内核进行阻塞。 </p><p><img src="https://i.loli.net/2020/11/05/kx9NjKItLvu4CiS.png" alt="队列图"></p><p>与synchronized相同的是，这也是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系。令人疑惑的是为什么采用CLH队列呢？原生的CLH队列是用于自旋锁，但Doug Lea把其改造为阻塞锁。<br>当有线程竞争锁时，该线程会首先尝试获得锁，这对于那些已经在队列中排队的线程来说显得不公平，这也是非公平锁的由来，与synchronized实现类似，这样会极大提高吞吐量。<br>如果已经存在Running线程，则新的竞争线程会被追加到队尾，具体是采用基于CAS的Lock-Free算法，因为线程并发对Tail调用CAS可能会导致其他线程CAS失败，解决办法是循环CAS直至成功。</p><h4 id="1-2-1-Sync-nonfairTryAcquire"><a href="#1-2-1-Sync-nonfairTryAcquire" class="headerlink" title="1.2.1 Sync.nonfairTryAcquire"></a>1.2.1 Sync.nonfairTryAcquire</h4><p>nonfairTryAcquire方法将是lock方法间接调用的第一个方法，每次请求锁时都会首先调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会首先判断当前状态，如果c==0说明没有线程正在竞争该锁，如果不c !=0 说明有线程正拥有了该锁。<br>如果发现c==0，则通过CAS设置该状态值为acquires,acquires的初始调用值为1，每次线程重入该锁都会+1，每次unlock都会-1，但为0时释放锁。如果CAS设置成功，其他线程调用CAS都不会成功，当前线程得到了该锁，这个Running线程并未进入等待队列。<br>如果c !=0 但发现自己已经拥有锁，只是简单地++acquires，并修改status值，但因为没有竞争，所以通过setStatus修改，而非CAS，也就是说这段代码实现了偏向锁的功能，并且实现的非常漂亮。</p><h4 id="1-2-2-AbstractQueuedSynchronizer-addWaiter"><a href="#1-2-2-AbstractQueuedSynchronizer-addWaiter" class="headerlink" title="1.2.2 AbstractQueuedSynchronizer.addWaiter"></a>1.2.2 AbstractQueuedSynchronizer.addWaiter</h4><p>addWaiter方法负责把当前无法获得锁的线程包装为一个Node添加到队尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中参数mode是独占锁还是共享锁，默认为null，独占锁。追加到队尾的动作分两步：<br>如果当前队尾已经存在(tail!=null)，则使用CAS把当前线程更新为Tail<br>如果当前Tail为null或则线程调用CAS设置队尾失败，则通过enq方法继续设置Tail </p><p><strong>调用AbstractQueuedSynchronizer.enq</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法就是循环调用CAS，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾（或设置队头）。</p><p><strong>addWaiter的目的就是通过CAS把当前线程追加到队尾，并返回包装后的Node实例。</strong><br>把线程要包装为Node对象的主要原因，除了用Node构造供虚拟队列外，还用Node包装了各种线程状态，这些状态被精心设计为一些数字值：</p><blockquote><p>SIGNAL(-1) ：线程的后继线程正/已被阻塞，当该线程release或cancel时要重新这个后继线程(unpark)<br>CANCELLED(1)：因为超时或中断，该线程已经被取消<br>CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了Condition.await而被阻塞<br>PROPAGATE(-3)：传播共享锁<br>0：0代表无状态</p></blockquote><h4 id="1-2-3-AbstractQueuedSynchronizer-acquireQueued"><a href="#1-2-3-AbstractQueuedSynchronizer-acquireQueued" class="headerlink" title="1.2.3 AbstractQueuedSynchronizer.acquireQueued"></a>1.2.3 AbstractQueuedSynchronizer.acquireQueued</h4><p>acquireQueued的主要作用是把已经追加到队列的线程节点（addWaiter方法返回值）进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Various flavors of acquire, varying in exclusive/shared and</span></span><br><span class="line"><span class="comment"> * control modes.  Each is mostly the same, but annoyingly</span></span><br><span class="line"><span class="comment"> * different.  Only a little bit of factoring is possible due to</span></span><br><span class="line"><span class="comment"> * interactions of exception mechanics (including ensuring that we</span></span><br><span class="line"><span class="comment"> * cancel if tryAcquire throws exception) and other control, at</span></span><br><span class="line"><span class="comment"> * least not without hurting performance too much.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看看这个方法是个无限循环，感觉如果p == head &amp;&amp; tryAcquire(arg)条件不满足循环将永远无法结束，当然不会出现死循环，奥秘在于第12行的<strong>parkAndCheckInterrupt会把当前线程挂起，从而阻塞住线程的调用栈。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前面所述，LockSupport.park最终把线程交给系统（Linux）内核进行阻塞。当然也不是马上把请求不到锁的线程进行阻塞，还要检查该线程的状态，比如如果该线程处于Cancel状态则没有必要，具体的检查在shouldParkAfterFailedAcquire中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>检查原则在于：</p><ul><li>规则1：如果前继的节点状态为SIGNAL，表明当前节点需要unpark，则返回成功，此时acquireQueued方法的第12行（parkAndCheckInterrupt）将导致线程阻塞</li><li>规则2：如果前继节点状态为CANCELLED(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，返回false，acquireQueued方法的无限循环将递归调用该方法，直至规则1返回true，导致线程阻塞</li><li>规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，返回false后进入acquireQueued的无限循环，与规则2同</li></ul><p>总体看来，shouldParkAfterFailedAcquire就是靠前继节点判断当前线程是否应该被阻塞，如果前继节点处于CANCELLED状态，则顺便删除这些节点重新构造队列。 </p></blockquote><h3 id="1-3-解锁"><a href="#1-3-解锁" class="headerlink" title="1.3 解锁"></a>1.3 解锁</h3><p>请求锁不成功的线程会被挂起在acquireQueued方法的第12行，12行以后的代码必须等线程被解锁锁才能执行，假如被阻塞的线程得到解锁，则执行第13行，即设置interrupted = true，之后又进入无限循环。</p><p>从无限循环的代码可以看出，并不是得到解锁的线程一定能获得锁，必须在第6行中调用tryAccquire重新竞争，因为锁是非公平的，有可能被新加入的线程获得，从而导致刚被唤醒的线程再次被阻塞，这个细节充分体现了“非公平”的精髓。通过之后将要介绍的解锁机制会看到，第一个被解锁的线程就是Head，因此p == head的判断基本都会成功。</p><p>至此可以看到，把tryAcquire方法延迟到子类中实现的做法非常精妙并具有极强的可扩展性，令人叹为观止！当然精妙的不是这个Template设计模式，而是Doug Lea对锁结构的精心布局。</p><p>解锁代码相对简单，主要体现在AbstractQueuedSynchronizer.release和Sync.tryRelease方法中： </p><p><strong>class AbstractQueuedSynchronizer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>class Sync</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to set the state to reflect a release in exclusive</span></span><br><span class="line"><span class="comment"> * mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is always invoked by the thread performing release.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation throws</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument. This value is always the one</span></span><br><span class="line"><span class="comment"> *        passed to a release method, or the current state value upon</span></span><br><span class="line"><span class="comment"> *        entry to a condition wait.  The value is otherwise</span></span><br><span class="line"><span class="comment"> *        uninterpreted and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this object is now in a fully released</span></span><br><span class="line"><span class="comment"> *         state, so that any waiting threads may attempt to acquire;</span></span><br><span class="line"><span class="comment"> *         and &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if releasing would place this</span></span><br><span class="line"><span class="comment"> *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment"> *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment"> *         correctly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryRelease与tryAcquire语义相同，把如何释放的逻辑延迟到子类中。</p><p>tryRelease语义很明确：如果线程多次锁定，则进行多次释放，直至status==0则真正释放锁，所谓释放锁即设置status为0，因为无竞争所以没有使用CAS。<br>release的语义在于：如果可以释放锁，则唤醒队列第一个线程（Head），唤醒代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找出第一个可以unpark的线程，一般说来head.next == head，Head就是第一个线程，但Head.next可能被取消或被置为null，因此比较稳妥的办法是从后往前找第一个可用线程。貌似回溯会导致性能降低，其实这个发生的几率很小，所以不会有性能影响。之后便是通知系统内核继续该线程，在Linux下是通过pthread_mutex_unlock完成。之后，被解锁的线程进入上面所说的重新竞争状态。</p><h3 id="1-4-Lock-VS-Synchronized"><a href="#1-4-Lock-VS-Synchronized" class="headerlink" title="1.4 Lock VS Synchronized"></a>1.4 Lock VS Synchronized</h3><p>AbstractQueuedSynchronizer通过构造一个基于<strong>阻塞的CLH队列</strong>容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。</p><p>synchronized的底层也是一个基于CAS操作的等待队列，但JVM实现的更精细，把等待队列分为ContentionList和EntryList，目的是为了降低线程的出列速度；当然也实现了偏向锁，从数据结构来说二者设计没有本质区别。但synchronized还实现了自旋锁，并针对不同的系统和硬件体系进行了优化，而Lock则完全依靠系统阻塞挂起等待线程。</p><p>Lock比synchronized更适合在应用层扩展，可以继承AbstractQueuedSynchronizer定义各种实现，比如实现读写锁（ReadWriteLock），公平或不公平锁；同时，Lock对应的Condition也比wait/notify要方便的多、灵活的多。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized关键字原理</title>
      <link href="2020/11/13/synchronized/"/>
      <url>2020/11/13/synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized关键字原理"><a href="#synchronized关键字原理" class="headerlink" title="synchronized关键字原理"></a>synchronized关键字原理</h2><p>众所周知<code>synchronized</code>关键字是解决并发问题常用解决方案，有以下三种方式：</p><ul><li>同步普通方法，锁的是当前对象。</li><li>同步精通方法，所得是当前<code>Class</code>对象。</li><li>同步块，所得是<code>()</code>中的对象。</li></ul><p>​    实现原理：<code>JVM</code>是通过进入、退出对象监视器(<code>Monitor</code>)来实现对方法、同步块的同步的。具体实现是在编译之后在同步方法调用前加入一个<code>monitor.enter</code>指令，在退出方法和异常出插入<code>monitor.exit</code>的指令。其本质就是对一个对象监视器(<code>Monitor</code>)进行获取，而这个获取的过程具有排他性从而达到了同一时刻只能一个线程访问的目的。而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程<code>monitor.exit</code>之后才能尝试继续获取锁。</p><p>流程图如下：</p><p><img src="https://i.loli.net/2020/11/05/RKMWDmpaT67Hgdv.jpg" alt="5d313f638492c49210.jpg"></p><p>通过一段代码来演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (Synchronize.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Synchronize&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>javap -c Syncchronize</code>可以查看编译之后的具体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class com.crossoverjie.synchronize.Synchronize &#123;</span><br><span class="line">  public com.crossoverjie.synchronize.Synchronize();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  &#x2F;&#x2F; class com&#x2F;crossoverjie&#x2F;synchronize&#x2F;Synchronize</span><br><span class="line">       2: dup</span><br><span class="line">       3: astore_1</span><br><span class="line">       **4: monitorenter**</span><br><span class="line">       5: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       8: ldc           #4                  &#x2F;&#x2F; String Synchronize</span><br><span class="line">      10: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">      13: aload_1</span><br><span class="line">      **14: monitorexit**</span><br><span class="line">      15: goto          23</span><br><span class="line">      18: astore_2</span><br><span class="line">      19: aload_1</span><br><span class="line">      20: monitorexit</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: athrow</span><br><span class="line">      23: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           5    15    18   any</span><br><span class="line">          18    21    18   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在同步块的入口和出口分别有<code>monitorenter,monitorexit</code>指令。</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>​    <code>synchronized</code>很多都称之为重量锁，<code>JDK1.6</code>中对<code>synchronized</code>进行了各种优化，为了能减少获取和释放锁带来的小号引入了<code>偏向锁</code>和<code>轻量锁</code>。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>​    在使用<code>synchronized</code>时，<code>JVM</code>会对同一<strong>对象使用的锁</strong>进行优化，比如<code>StringBuffer</code>的<code>append</code>方法是<code>synchronized</code>修饰的，<code>JVM</code>会把相关的<code>append</code>操作合并成一个<code>synchronized</code>块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粗化前</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 粗化后</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>​    在使用<code>synchronized</code>时，当我们同步锁住的对象在方法体内时（一个栈帧）多线程执行不会有任何影响，<code>JVM</code>会消除当前方法的<code>synchronized</code>。</p><blockquote><p><strong>如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步</strong>。</p><p><strong>说明了逃逸分析把锁消除了，并在性能上得到了很大的提升。这里说明一下Java的逃逸分析是方法级别的，因为JIT的即时编译是方法级别。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 消除前</span></span><br><span class="line"><span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消除后</span></span><br><span class="line">System.out.println(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><blockquote><p><strong>这个简单来说就是把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为不用生成对象头。 二、程序内存回收效率高，并且GC频率也会减少，总的来说和上面优点一的效果差不多</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逃逸分析开启之后 -XX:+DoEscapeAnalysis（JDK1.8默认开启</span></span><br><span class="line"><span class="comment">     ）</span></span><br><span class="line"><span class="comment">     * jps -l</span></span><br><span class="line"><span class="comment">     * jmap -histo id</span></span><br><span class="line"><span class="comment">     * 可以看到对象并没有被创建一千次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5_000_000</span>; i++)&#123;</span><br><span class="line">    createObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这说明了JVM在逃逸分析之后，将对象分配在了方法createObject()方法栈上。<strong>方法栈上的对象在方法执行完之后，栈桢弹出，对象就会自动回收。这样的话就不需要等内存满时再触发内存回收。这样的好处是</strong>程序内存回收效率高，并且GC频率也会减少**，程序的性能就提高了。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile关键字</title>
      <link href="2020/11/13/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/11/13/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="1-1内存可见性"><a href="#1-1内存可见性" class="headerlink" title="1.1内存可见性"></a>1.1内存可见性</h3><p>​    由于<code>Java</code>内存模型(<code>JMM</code>)规定，所有的变量都存放在主内存中，而每个线程都有着自己的工作内存(高速内存)。</p><p>​    线程在工作时，需要将主内存中的数据拷贝到工作内存中。这样对数据的任何操作都是基于工作内存(效率提高)，并且不能直接操作主内存以及其他线程工作内存中的数据，之后再将更新之后的数据刷新到主内存中。</p><blockquote><p>这里所提到的主内存可以简单的认为是<strong>堆内存</strong>，而工作内存则可以认为是<strong>栈内存</strong>。</p></blockquote><p>如图所示：</p><p><img src="https://i.loli.net/2020/11/05/WYSa9e1f36NZRAU.jpg" alt="5d31384d22ac511765.jpg"></p><p>所以在并发运行时可能会出现线程B所读取到的数据是线程A更新之前的数据。</p><p>显然这肯定是会出问题的，因此<code>volatile</code>的作用出现了：</p><blockquote><p>当一个变量被<code>volatile</code>修饰时，任何线程对它的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。</p></blockquote><p><code>volatile</code>修饰之后并不是让线程直接从主内存中获取数据，依然需要将变量拷贝到工作内存中。</p><h3 id="1-2内存可见性的应用"><a href="#1-2内存可见性的应用" class="headerlink" title="1.2内存可见性的应用"></a>1.2内存可见性的应用</h3><p>当我们需要在两个线程间依据主内存通信时，通信的那个变量就必须用<code>volatile</code>来修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Volatile aVolatile = <span class="keyword">new</span> Volatile();</span><br><span class="line">        <span class="keyword">new</span> Thread(aVolatile,<span class="string">&quot;thread A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程正在运行&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">            String value = sc.next();</span><br><span class="line">            <span class="keyword">if</span>(value.equals(<span class="string">&quot;1&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        aVolatile.stopThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程退出了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程在修改了标志位使得线程A立即停止，如果没有用<code>volatile</code>修饰，就有可能出现延迟。</p><p>但这里有个无趣，这样的使用方式容易给人的<strong>感觉</strong>是：<del>对<code>volatile</code>修饰的变量进行并发操作是线程安全的</del>。</p><p>这里要重点强调，**<code>volatile</code>并不能保证线程安全**！</p><p>如下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileInc</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span> ; <span class="comment">//使用 volatile 修饰基本数据内存不能保证原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static AtomicInteger count = new AtomicInteger() ;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span> ;i++)&#123;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="comment">//count.incrementAndGet() ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileInc volatileInc = <span class="keyword">new</span> VolatileInc() ;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(volatileInc,<span class="string">&quot;t1&quot;</span>) ;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(volatileInc,<span class="string">&quot;t2&quot;</span>) ;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t1.join();</span></span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//t2.join();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span> ;i++)&#123;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="comment">//count.incrementAndGet();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终Count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们三个线程（t1,t2,main）同时对一个<code>int</code>进行累加时会发现最终的值都会小于30000。</p><blockquote><p>这是因为虽然<code>volatile</code>保证了内存可见性，每个线程拿到的值都是最新值，但<code>count++</code>这个操作并不是原子的，这里面涉及<code>获取值</code>、<code>自增</code>、<code>赋值</code>的操作并不能同时完成。</p></blockquote><p>所以想达到线程安全：</p><ul><li>使这三个线程串行执行（单线程，并没有发挥多线程的优势）。</li><li>使用<code>synchronized</code>或者锁的方式来保证原子性。</li><li><code>Atomic</code>包中<code>AtomicInteger</code>来替换<code>int</code>，它利用了<code>CAS</code>指令来保证了原子性。</li></ul><h3 id="1-3指令重排"><a href="#1-3指令重排" class="headerlink" title="1.3指令重排"></a>1.3指令重排</h3><p>​    内存可见只是<code>volatile</code>的其中一个语义，它还可以防止<code>JVM</code>进行指令重排优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span> ;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">20</span> ;<span class="comment">//2</span></span><br><span class="line"><span class="keyword">int</span> c= a+b ;<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>理想情况下它的执行顺序是：<code>1 &gt; 2 &gt; 3</code>。但是有一种可能经过JVM优化之后代码顺序变为<code>2 &gt; 1 &gt; 3</code>。</p><p>可以发现不管JVM怎么优化，前提都是保证单线程中最终结果不变的情况。这里可能还看不出什么问题。看下一段伪代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; value ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = fasle ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下方法发生在线程 A 中 初始化 Map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//耗时操作</span></span><br><span class="line">    value = getMapValue() ;<span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span> ;<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发生在线程 B中 等到 Map 初始化成功进行其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">        sleep() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">    doSomeThing(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就能看出问题了，当<code>flag</code>没有被<code>volatile</code>修饰时，<code>JVM</code>对1和2进行重排，导致<code>value</code>都还没有被初始化就有可能被线程B使用了。所以加上<code>volatile</code>之后可以防止这样的重排优化，保证业务的正确性。</p><p><strong>指令重排的应用经典场景（双重懒加载单例）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//防止指令重排</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>volatile</code>关键字主要为了防止指令重排。</p><p>如果不用，<code>singleton = new Singleton();</code>，这段代码其实分为三步：</p><ol><li>分配内存空间。</li><li>初始化对象。</li><li>将<code>singleton</code>对象指向分配的内存地址。</li></ol><p>加上<code>volatile</code>是为了保证以上操作顺序执行，反之有可能第二步在第三步之间被执行就有可能某个线程拿到的单例对象是还没初始化的，以至于报错。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>volatile</code>在Java并发中用的很多，比如像<code>Atomic</code>包中的<code>value</code>、以及<code>AbstractQueuedLongSynchronizer</code> 中的<code>state</code>都是被定义为<code>volatile</code>来用于保证内存可见性。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA自定义模板</title>
      <link href="2020/11/13/IDEA%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/"/>
      <url>2020/11/13/IDEA%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA自定义模板"><a href="#IDEA自定义模板" class="headerlink" title="IDEA自定义模板"></a>IDEA自定义模板</h1><h2 id="1-自定义IDEA编辑模板变量详解-Edit-Template-Variables"><a href="#1-自定义IDEA编辑模板变量详解-Edit-Template-Variables" class="headerlink" title="1. 自定义IDEA编辑模板变量详解(Edit Template Variables)"></a>1. 自定义IDEA编辑模板变量详解(Edit Template Variables)</h2><table><thead><tr><th><strong><em>\</em>作用**</strong></th><th><strong><em>\</em>描述**</strong></th></tr></thead><tbody><tr><td><strong><em>\</em>annotated(“annotation qname”)**</strong></td><td>使用驻留在指定位置的注释创建类型符号。 例如，请参见迭代组中的活动模板。</td></tr><tr><td><strong><em>\</em>anonymousSuper()**</strong></td><td>为Kotlin对象表达式建议一个超类型。</td></tr><tr><td><strong><em>\</em>arrayVariable()**</strong></td><td>建议当前作用域中适用的所有数组变量。 例如，请参见迭代组中的活动模板。</td></tr><tr><td><strong><em>\</em>blockCommentEnd**</strong></td><td>返回在当前语言上下文中指示块注释结束的字符。</td></tr><tr><td><strong><em>\</em>blockCommentStart**</strong></td><td>返回在当前语言上下文中指示块注释开始的字符。</td></tr><tr><td><strong><em>\</em>camelCase(String)**</strong></td><td>将字符串转换为camelCase。 例如，camelCase(my-text-file)、camelCase(my text file)和camelCase(my_text_file)都返回myTextFile。</td></tr><tr><td><strong><em>\</em>capitalize(String)**</strong></td><td>将参数的第一个字母大写。</td></tr><tr><td><strong><em>\</em>capitalizeAndUnderscore(sCamelCaseName)**</strong></td><td>将作为参数传递的CamelCase名称的所有字母大写，并在各部分之间插入下划线。例如，大写和下划线(FooBar)返回FOO_BAR。</td></tr><tr><td><strong><em>\</em>castToLeftSideType()**</strong></td><td>将右侧表达式转换为左侧表达式类型。在迭代组中，它使用一个模板来生成raw类型和泛型集合。</td></tr><tr><td><strong><em>\</em>className()**</strong></td><td>返回当前类的名称(展开模板的类)。</td></tr><tr><td><strong><em>\</em>classNameComplete()**</strong></td><td>这个表达式替代了变量位置上的类名补全。</td></tr><tr><td><strong><em>\</em>clipboard()**</strong></td><td>返回系统剪贴板的内容。</td></tr><tr><td><strong><em>\</em>commentEnd()**</strong></td><td>返回指示当前语言上下文中注释结尾的字符。如果行注释是用当前语言定义的，则返回值为空。</td></tr><tr><td><strong><em>\</em>commentStart()**</strong></td><td>返回指示当前语言上下文中注释开头的字符。如果行注释是用当前语言定义的，则它们的开始指示符更好。</td></tr><tr><td><strong><em>\</em>complete()**</strong></td><td>在变量的位置调用代码完成。</td></tr><tr><td><strong><em>\</em>completeSmart()**</strong></td><td>在变量的位置调用智能类型完成。</td></tr><tr><td><strong><em>\</em>componentTypeOf(<array>)**</strong></td><td>返回数组的组件类型。有关示例，请参见迭代组和其他组中的活动模板。</td></tr><tr><td><strong><em>\</em>concat(expressions…)**</strong></td><td>返回作为参数传递给函数的所有字符串的串联。</td></tr><tr><td><strong><em>\</em>currentPackage()**</strong></td><td>返回当前包名称。</td></tr><tr><td><strong><em>\</em>date(sDate)**</strong></td><td>如果没有参数，则以默认系统格式返回当前日期。</td></tr><tr><td><strong><em>\</em>decapitalize(sName)**</strong></td><td>将参数的第一个字母替换为相应的小写字母。</td></tr><tr><td><strong><em>\</em>descendantClassEnum(<String>)**</strong></td><td>返回指定为字符串参数的类的子级。</td></tr><tr><td><strong><em>\</em>enum(sCompletionString1,sCompletionString2,…)**</strong></td><td>返回在扩展模板时建议完成的逗号分隔字符串列表。</td></tr><tr><td><strong><em>\</em>escapeString(sEscapeString)**</strong></td><td>转义指定为参数的字符串。</td></tr><tr><td><strong><em>\</em>expectedType()**</strong></td><td>返回模板扩展到的表达式的预期类型。如果模板在赋值的右部分、返回后等展开，则很有意义。</td></tr><tr><td><strong><em>\</em>fileName()**</strong></td><td>返回当前文件的名称及其扩展名。</td></tr><tr><td><strong><em>\</em>fileNameWithoutExtension()**</strong></td><td>返回不带扩展名的当前文件的名称。</td></tr><tr><td><strong><em>\</em>firstWord(sFirstWord)**</strong></td><td>返回作为参数传递的字符串的第一个字。</td></tr><tr><td><strong><em>\</em>groovyScript(“groovy code”, arg1)**</strong></td><td>返回具有指定代码的groovy脚本。 可以将groovyscript（）函数与多个参数一起使用。第一个参数是所执行脚本的文本或包含脚本的文件的路径。下一个参数绑定到脚本中可用的_1、_2、_3、…_n变量。此外，脚本中还提供了_editor变量。此变量绑定到当前编辑器。</td></tr><tr><td><strong><em>\</em>guessElementType (<container>)**</strong></td><td>猜测java.util.collection中存储的元素类型。为了猜测，intellij想法试图找到元素添加到容器或从容器中提取的位置。</td></tr><tr><td><strong><em>\</em>iterableComponentType(<ArrayOrIterable>)**</strong></td><td>返回可iterable组件的类型，如数组或集合。</td></tr><tr><td><strong><em>\</em>iterableVariable()**</strong></td><td>返回可迭代的变量的名称。</td></tr><tr><td><strong><em>\</em>JsArrayVariable()**</strong></td><td>返回当前javascript数组的名称。</td></tr><tr><td><strong><em>\</em>jsClassName()**</strong></td><td>返回当前javascript类的名称。</td></tr><tr><td><strong><em>\</em>jsComponentTypeOf()**</strong></td><td>返回当前javascript组件的类型。</td></tr><tr><td><strong><em>\</em>jsDefineParameter**</strong></td><td>基于模块的名称，返回参数fromdefine（[“module”]、function（<parameter_in_question>&gt;））。</td></tr><tr><td><strong><em>\</em>jsMethodName()**</strong></td><td>返回当前javascript方法的名称。</td></tr><tr><td><strong><em>\</em>jsQualifiedClassName()**</strong></td><td>返回当前javascript类的完整名称。</td></tr><tr><td><strong><em>\</em>jsSuggestIndexName()**</strong></td><td>返回最常用的索引变量的建议名称：i、j、k等。当前作用域中尚未使用的名称将首先显示。</td></tr><tr><td><strong><em>\</em>jsSuggestVariableName()**</strong></td><td>根据引用变量命名规则的代码样式设置，基于变量类型和初始值设定项表达式返回变量的建议名称。 例如，如果它是一个在迭代中保存元素的变量，那么intellij-idea会猜测最合理的名称，并考虑到被迭代的容器的名称。</td></tr><tr><td><strong><em>\</em>jsSuggestDefaultVariableKind(Boolean)**</strong></td><td>布尔参数确定当前上下文中是否允许常量。如果未指定参数，则允许使用常量。当模板展开时，将显示一个下拉列表，其中包含typescript和es6的var、let和const选项，以及早期javascript版本的一个var选项。</td></tr><tr><td><strong><em>\</em>jsSuggestImportedEntityName()**</strong></td><td>根据文件名，将’import*类型的import语句的名称建议为$item$from“$module$”`或’import$item$from“$module$”。</td></tr><tr><td><strong><em>\</em>lineCommentStart**</strong></td><td>返回在当前语言上下文中指示行注释开头的字符。</td></tr><tr><td><strong><em>\</em>lineNumber()**</strong></td><td>返回当前行号。</td></tr><tr><td><strong><em>\</em>lowercaseAndDash(String)**</strong></td><td>将camelcase字符串转换为小写，并插入n个破折号作为分隔符。例如，LowerCaseandDash（MyExampleName）返回我的示例名称。</td></tr><tr><td><strong><em>\</em>methodName()**</strong></td><td>返回展开模板的方法的名称。</td></tr><tr><td><strong><em>\</em>methodParameters()**</strong></td><td>返回展开模板的方法的参数列表。</td></tr><tr><td><strong><em>\</em>methodReturnType()**</strong></td><td>返回当前方法返回的值的类型（模板在其中展开）。</td></tr><tr><td><strong><em>\</em>qualifiedClassName()**</strong></td><td>返回当前类的完全限定名（在其中展开模板）。</td></tr><tr><td><strong><em>\</em>rightSideType()**</strong></td><td>用右侧表达式的类型声明左侧变量。在迭代组中，它使用一个模板来生成原始类型和泛型集合。</td></tr><tr><td><strong><em>\</em>snakeCase(String)**</strong></td><td>将字符串转换为蛇形大小写。例如，snakecase（foo bar）返回foo_bar。</td></tr><tr><td><strong><em>\</em>spaceSeparated(String)**</strong></td><td>将字符串转换为小写并插入空格作为分隔符。例如，spaceseparated（foo bar）返回foo bar。</td></tr><tr><td><strong><em>\</em>substringBefore(String,Delimiter)**</strong></td><td>删除指定分隔符后的扩展名并仅返回文件名。这有助于测试文件名（例如，substringbefore（$filename$，“.”）返回component test.js中的组件测试。</td></tr><tr><td><strong><em>\</em>subtypes(sType)**</strong></td><td>返回作为参数传递的类型的子类型。</td></tr><tr><td><strong><em>\</em>suggestFirstVariableName(sFirstVariableName)**</strong></td><td>不代表真的，假的，这个，超级的。</td></tr><tr><td><strong><em>\</em>suggestIndexName()**</strong></td><td>建议使用最常用的索引变量的名称：i、j、k等（第一个不在当前范围内使用的变量）。</td></tr><tr><td><strong><em>\</em>suggestVariableName()**</strong></td><td>根据引用变量命名规则的代码样式设置，基于变量类型及其初始值设定项表达式建议变量的名称。例如，如果它是一个在迭代中保存元素的变量，那么intellij-idea会猜测最合理的名称，并考虑到要迭代的容器的名称。</td></tr><tr><td><strong><em>\</em>time(sSystemTime)**</strong></td><td>以指定格式返回当前系统时间。</td></tr><tr><td><strong><em>\</em>typeOfVariable(VAR)**</strong></td><td>返回作为参数传递的变量的类型。</td></tr><tr><td><strong><em>\</em>underscoresToCamelCase(String)**</strong></td><td>用作为参数传递的字符串中的camelcase字母替换下划线。例如，underlinestocamelcase（foo_bar）返回foo bar。</td></tr><tr><td><strong><em>\</em>underscoresToSpaces(sParameterWithUnderscores)**</strong></td><td>用作为参数传递的字符串中的空格替换下划线。例如，underlinestospaces（foo_bar）返回foo bar。</td></tr><tr><td><strong><em>\</em>user()**</strong></td><td>返回当前用户的名称。</td></tr><tr><td><strong><em>\</em>variableOfType(<type>)**</strong></td><td>建议可以分配给作为参数传递的类型的所有变量，例如，VababeLoFype（“java. U.L.Vector”）。如果传递一个空字符串（“”）作为参数，那么函数将建议所有变量，而不管其类型如何。</td></tr></tbody></table><h2 id="2-方法注释"><a href="#2-方法注释" class="headerlink" title="2. 方法注释"></a>2. 方法注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * 功能描述: &lt;br&gt;</span><br><span class="line"> * -    $description$</span><br><span class="line"> *       </span><br><span class="line"> $param$</span><br><span class="line"> * <span class="meta">@return</span> $<span class="keyword">return</span>$    clink$c$</span><br><span class="line"> * <span class="meta">@author</span> yyx</span><br><span class="line"> * <span class="meta">@date</span> $DATE$ $TIME$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/04/52qysaSU39NOxPd.png" alt="参数截图"></p><h3 id="注释中多个参数处理函数"><a href="#注释中多个参数处理函数" class="headerlink" title="注释中多个参数处理函数"></a><u>注释中多个参数处理函数</u></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java groovyScript(<span class="string">&quot;def result=&#x27;&#x27;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#x27;[\\\\[|\\\\]|\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;if(i==0)&#123;result+=&#x27;* @param &#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\n&#x27; : &#x27;&#x27;)&#125;else&#123;result+=&#x27; * @param &#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\n&#x27; : &#x27;&#x27;)&#125;&#125;; return result&quot;</span>, methodParameters())</span><br></pre></td></tr></table></figure><h2 id="3-类注释"><a href="#3-类注释" class="headerlink" title="3. 类注释"></a>3. 类注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $END$</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yyx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> $DATE$ $TIME$</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="4-自动Resource-Autowired"><a href="#4-自动Resource-Autowired" class="headerlink" title="4. 自动Resource||Autowired"></a>4. 自动Resource||Autowired</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resource</span></span><br><span class="line"><span class="meta">@javax</span>.annotation.Resource</span><br><span class="line"><span class="keyword">private</span> $PARAM$ $VAL$;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Autowired</span></span><br><span class="line"><span class="meta">@org</span>.springframework.beans.factory.annotation.Autowired</span><br><span class="line"><span class="keyword">private</span> $PARAM$ $VAL$;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/04/4W8ORXmQoqawBfu.png" alt="参数处理"></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于if else写法建议</title>
      <link href="2020/11/13/%E5%85%B3%E4%BA%8Eif%20else%E5%86%99%E6%B3%95%E5%BB%BA%E8%AE%AE/"/>
      <url>2020/11/13/%E5%85%B3%E4%BA%8Eif%20else%E5%86%99%E6%B3%95%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="关于if-else写法建议"><a href="#关于if-else写法建议" class="headerlink" title="关于if else写法建议"></a>关于if else写法建议</h2><h3 id="为什么我们写的代码都是if-else"><a href="#为什么我们写的代码都是if-else" class="headerlink" title="为什么我们写的代码都是if-else?"></a>为什么我们写的代码都是if-else?</h3><p> 程序员想必都经历过这样的场景：刚开始自己写的代码很简洁，逻辑清晰，函数精简，没有一个if-else，<br> 可随着代码逻辑不断完善和业务的瞬息万变:比如需要对入参进行类型和值进行判断；这里要判断下对象是否为null；不同类型执行不同的流程。<br> 落地到具体实现只能不停地加if-else来处理，渐渐地，代码变得越来越庞大，函数越来越长，文件行数也迅速突破上千行，维护难度也越来越大，到后期基本达到一种难以维护的状态。</p><p><strong>虽然我们都很不情愿写出满屏if-else的代码，可逻辑上就是需要特殊判断，很绝望，可也没办法避免啊。</strong></p><p> 其实回头看看自己的代码，<strong>写if-else不外乎两种场景：异常逻辑处理和不同状态处理。</strong></p><p> 两者最主要的区别是：异常逻辑处理说明只能一个分支是正常流程，而不同状态处理都所有分支都是正常流程。</p><p> <em>怎么理解？举个例子：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例一：异常逻辑处理例子</span></span><br><span class="line">Object obj = getObj();</span><br><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//举例二：状态处理例子</span></span><br><span class="line">Object obj = getObj();</span><br><span class="line"><span class="keyword">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第一个例子<code>if (obj != null)</code>是异常处理，是代码健壮性判断，只有if里面才是正常的处理流程，<code>else</code>分支是出错处理流程；</p><p> 而第二个例子不管type等于1，2还是其他情况，都属于业务的正常流程。<strong>对于这两种情况重构的方法也不一样。</strong></p><h3 id="代码if-else代码太多有什么缺点？"><a href="#代码if-else代码太多有什么缺点？" class="headerlink" title="代码if-else代码太多有什么缺点？"></a>代码if-else代码太多有什么缺点？</h3><p><em>缺点相当明显了：</em></p><ol><li>最大的问题是代码逻辑复杂，维护性差，极容易引发bug。</li><li>如果使用if-else，说明if分支和else分支的重视是同等的，但大多数情况并非如此，容易引起误解和理解困难。</li></ol><h3 id="是否有好的方法优化？如何重构？"><a href="#是否有好的方法优化？如何重构？" class="headerlink" title="是否有好的方法优化？如何重构？"></a>是否有好的方法优化？如何重构？</h3><p>重构if-else时，心中无时无刻把握一个原则：</p><blockquote><p>  <strong><em>尽可能地维持正常流程代码在最外层。</em></strong></p></blockquote><p> 意思是说，可以写if-else语句时一定要尽量保持主干代码是正常流程，避免嵌套过深。</p><p> 实现的手段有：<em>减少嵌套、移除临时变量、条件取反判断、合并条件表达式等。</em></p><p> 下面举几个实例来讲解这些重构方法：</p><h4 id="异常逻辑处理型重构方法实例一："><a href="#异常逻辑处理型重构方法实例一：" class="headerlink" title="异常逻辑处理型重构方法实例一："></a>异常逻辑处理型重构方法实例一：</h4><p> <em>重构前：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disablityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(_monthsDisabled &gt; <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(_isPartTime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do somethig</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>重构后:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disablityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span> || _monthsDisabled &gt; <span class="number">12</span> || _isPartTime) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//do somethig</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>这里的重构手法叫合并条件表达式：如果有一系列条件测试都得到相同结果，将这些结果测试合并为一个条件表达式。</strong></p><p> 这个重构手法简单易懂，带来的效果也非常明显，能有效地较少if语句，减少代码量逻辑上也更加易懂。</p><h4 id="异常逻辑处理型重构方法实例二："><a href="#异常逻辑处理型重构方法实例二：" class="headerlink" title="异常逻辑处理型重构方法实例二："></a>异常逻辑处理型重构方法实例二：</h4><p> <em>重构前：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(_isDead) &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_isSeparated)&#123;</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_isRetired)&#123;</span><br><span class="line">                result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result = normalPayAmount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p> <em>重构后：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_isDead) </span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_isSeparated)</span><br><span class="line">        <span class="keyword">return</span> separatedAmount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_isRetired)</span><br><span class="line">        <span class="keyword">return</span> retiredAmount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 怎么样？比对两个版本，会发现重构后的版本逻辑清晰，简洁易懂。</p><p> <em>和重构前到底有什么区别呢？</em></p><p> 最大的区别是**<em>减少if-else嵌套**</em>。</p><p> 可以看到，最初的版本if-else最深的嵌套有三层，看上去逻辑分支非常多，进到里面基本都要被绕晕。其实，仔细想想嵌套内的if-else和最外层并没有关联性的，完全可以提取最顶层。</p><blockquote><p>  改为平行关系，而非包含关系，if-else数量没有变化，但是逻辑清晰明了，一目了然。</p></blockquote><p> 另一个重构点是<strong>废除了<code>result</code>临时变量，直接return返回</strong>。好处也显而易见直接结束流程，缩短异常分支流程。原来的做法先赋值给result最后统一return，那么对于最后return的值到底是那个函数返回的结果不明确，增加了一层理解难度。</p><p> <strong>总结重构的要点：如果if-else嵌套没有关联性，直接提取到第一层，一定要避免逻辑嵌套太深。尽量减少临时变量改用return直接返回。</strong></p><h4 id="异常逻辑处理型重构方法实例三："><a href="#异常逻辑处理型重构方法实例三：" class="headerlink" title="异常逻辑处理型重构方法实例三："></a>异常逻辑处理型重构方法实例三：</h4><p> <em>重构前：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_capital &gt; <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            resutl = (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第一步，运用第一招:减少嵌套和移除临时变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样重构后，还不够，因为主要的语句<code>(_income / _duration) * ADJ_FACTOR</code>;在if内部，并非在最外层，根据优化原则（<em>尽可能地维持正常流程代码在最外层</em>），可以再继续重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这才是好的代码风格，逻辑清晰，一目了然，没有if-else嵌套难以理解的流程。</p><p> <strong>这里用到的重构方法是：将条件反转使异常情况先退出，让正常流程维持在主干流程。</strong></p><h4 id="异常逻辑处理型重构方法实例四："><a href="#异常逻辑处理型重构方法实例四：" class="headerlink" title="异常逻辑处理型重构方法实例四："></a>异常逻辑处理型重构方法实例四：</h4><p> <em>重构前：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找年龄大于18岁且为男性的学生列表 */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title">getStudents</span><span class="params">(<span class="keyword">int</span> uid)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     ArrayList&lt;Student&gt; result = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">     </span><br><span class="line">     Student stu = getStudentByUid(uid);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (stu != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Teacher teacher = stu.getTeacher();</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span>(teacher != <span class="keyword">null</span>)&#123;</span><br><span class="line">             ArrayList&lt;Student&gt; students = teacher.getStudents();</span><br><span class="line">             <span class="keyword">if</span>(students != <span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(student.getAge() &gt; = <span class="number">18</span> &amp;&amp; student.getGender() == MALE)&#123;</span><br><span class="line">                         result.add(student);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 logger.error(<span class="string">&quot;获取学生列表失败&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             logger.error(<span class="string">&quot;获取老师信息失败&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.error(<span class="string">&quot;获取学生信息失败&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 典型的”箭头型”代码，最大的问题是**<em>嵌套过深，解决方法是异常条件先退出，保持主干流程是核心流程**</em>：</p><p> <em>重构后：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找年龄大于18岁且为男性的学生列表 */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title">getStudents</span><span class="params">(<span class="keyword">int</span> uid)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     ArrayList&lt;Student&gt; result = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">     Student stu = getStudentByUid(uid);</span><br><span class="line">     <span class="keyword">if</span> (stu == <span class="keyword">null</span>) &#123;</span><br><span class="line">         logger.error(<span class="string">&quot;获取学生信息失败&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Teacher teacher = stu.getTeacher();</span><br><span class="line">     <span class="keyword">if</span>(teacher == <span class="keyword">null</span>)&#123;</span><br><span class="line">         logger.error(<span class="string">&quot;获取老师信息失败&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList&lt;Student&gt; students = teacher.getStudents();</span><br><span class="line">     <span class="keyword">if</span>(students == <span class="keyword">null</span>)&#123;</span><br><span class="line">         logger.error(<span class="string">&quot;获取学生列表失败&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">         <span class="keyword">if</span>(student.getAge() &gt; <span class="number">18</span> &amp;&amp; student.getGender() == MALE)&#123;</span><br><span class="line">             result.add(student);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="状态处理型重构方法实例一"><a href="#状态处理型重构方法实例一" class="headerlink" title="状态处理型重构方法实例一"></a>状态处理型重构方法实例一</h4><p> <em>重构前：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Object obj = getObj();</span><br><span class="line">    <span class="keyword">double</span> money = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">        ObjectA objA = obj.getObjectA();</span><br><span class="line">        money = objA.getMoney()*obj.getNormalMoneryA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">        ObjectB objB = obj.getObjectB();</span><br><span class="line">        money = objB.getMoney()*obj.getNormalMoneryB()+<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>重构后：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Object obj = getObj();</span><br><span class="line">    <span class="keyword">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType1Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType2Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getType1Money</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    ObjectA objA = obj.getObjectA();</span><br><span class="line">    <span class="keyword">return</span> objA.getMoney()*obj.getNormalMoneryA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getType2Money</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    ObjectB objB = obj.getObjectB();</span><br><span class="line">    <span class="keyword">return</span> objB.getMoney()*obj.getNormalMoneryB()+<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong><em>这里使用的重构方法是：把if-else内的代码都封装成一个公共函数。</em></strong>函数的好处是屏蔽内部实现，缩短if-else分支的代码。代码结构和逻辑上清晰，能一下看出来每一个条件内做的功能。</p><h4 id="状态处理型重构方法实例二"><a href="#状态处理型重构方法实例二" class="headerlink" title="状态处理型重构方法实例二"></a>状态处理型重构方法实例二</h4><p> 针对状态处理的代码，一种优雅的做法是**<em>用多态取代条件表达式(《重构》推荐做法)**</em>。</p><blockquote><p>  你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。将这个表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。</p></blockquote><p> <em>重构前：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(_type)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EUROPEAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> AFRICAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed()-getLoadFactor()*_numberOfCoconuts;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">            <span class="keyword">return</span> (_isNailed)?<span class="number">0</span>:getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>重构后：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">African</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed()-getLoadFactor()*_numberOfCoconuts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NorwegianBlue</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (_isNailed)?<span class="number">0</span>:getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>可以看到，使用多态后直接没有了if-else，但使用多态对原来代码修改过大，需要一番功夫才行。最好在设计之初就使用多态方式。</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> if-else代码是每一个程序员最容易写出的代码，同时也是最容易被写烂的代码，稍不注意，就产生一堆难以维护和逻辑混乱的代码。</p><p> 针对条件型代码重构把握一个原则：</p><blockquote><p>  尽可能地维持正常流程代码在最外层，保持主干流程是正常核心流程。</p></blockquote><p> 为维持这个原则：合并条件表达式可以有效地减少if语句数目；减少嵌套能减少深层次逻辑；</p><p> 异常条件先退出自然而然主干流程就是正常流程。</p><p> 针对状态处理型重构方法有两种：一种是把不同状态的操作封装成函数，简短if-else内代码行数；另一种是利用面向对象多态特性直接干掉了条件判断。</p><p> 现在回头看看自己的代码，犯了哪些典型错误，赶紧运用这些重构方法重构代码吧！！</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Explain执行计划</title>
      <link href="2020/11/13/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>2020/11/13/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="Explain执行计划"><a href="#Explain执行计划" class="headerlink" title="Explain执行计划"></a>Explain执行计划</h2><h3 id="1-Explain有什么用"><a href="#1-Explain有什么用" class="headerlink" title="1.Explain有什么用"></a>1.Explain有什么用</h3><p>  当Explain与SQL一起执行时，MySQL会显示来自优化器关于SQL执行的信息。MySQL解释了他将如何处理该语句，包括如何连接表以及什么顺序连接表等。</p><ul><li><p>表的加载顺序</p></li><li><p>sql的查询类型</p></li><li><p>可能用到哪些索引，哪些索引又被实际使用</p></li><li><p>表与表之间的引用关系</p></li><li><p>一个表中有多少行被优化器查询…</p></li></ul><h3 id="2-Explain有哪些信息"><a href="#2-Explain有哪些信息" class="headerlink" title="2.Explain有哪些信息"></a>2.Explain有哪些信息</h3><p>Explain执行计划包含字段信息如下：分别是<code>id</code>、<code>select_type</code>、<code>table</code>、<code>partitions</code>、<code>type</code>、<code>possible_keys</code>、<code>key</code>、<code>key_len</code>、<code>ref</code>、<code>rows</code>、<code>filtered</code>、<code>Extra</code> 12个字段。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h3 id="3-Explain执行计划详解"><a href="#3-Explain执行计划详解" class="headerlink" title="3.Explain执行计划详解"></a>3.Explain执行计划详解</h3><h4 id="3-1-id"><a href="#3-1-id" class="headerlink" title="3.1 id"></a>3.1 id</h4><p><code>id</code> :表示查询中执行select子句或者操作表的顺序。<code>id</code><strong>值越大，优先级越高，越先执行。</strong><code>id</code>大致会出现3种情况</p><h5 id="1、id相同"><a href="#1、id相同" class="headerlink" title="1、id相同"></a>1、<code>id</code>相同</h5><p>看到三条记录的<code>id</code>都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id = t.two_id AND t.three_id = r.three_id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type   |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref                  |</span> rows <span class="params">| filtered |</span> Extra                                              <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> o     <span class="params">| NULL       |</span> ALL    <span class="params">| NULL          |</span> NULL    <span class="params">| NULL    |</span> NULL                 <span class="params">|    2 |</span>      <span class="number">100</span> <span class="params">| NULL                                               |</span></span><br><span class="line"><span class="params">|  1 |</span> SIMPLE      <span class="params">| t     |</span> NULL       <span class="params">| ALL    |</span> PRIMARY       <span class="params">| NULL    |</span> NULL    <span class="params">| NULL                 |</span>    <span class="number">2</span> <span class="params">|       50 |</span> Using where; Using join buffer (Block Nested Loop) <span class="params">|</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> r     <span class="params">| NULL       |</span> eq_ref <span class="params">| PRIMARY       |</span> PRIMARY <span class="params">| 4       |</span> xin-slave.t.three_id <span class="params">|    1 |</span>      <span class="number">100</span> <span class="params">| NULL                                               |</span></span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br></pre></td></tr></table></figure><h5 id="2、id不同"><a href="#2、id不同" class="headerlink" title="2、id不同"></a>2、<code>id</code>不同</h5><p>如果我们的 <code>SQL</code> 中存在子查询，那么 <code>id</code>的序号会递增，<code>id</code>值越大优先级越高，越先被执行 。当三个表依次嵌套，发现最里层的子查询 <code>id</code>最大，最先执行。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name=<span class="string">&#x27;我是第三表2&#x27;</span>));</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| PRIMARY     |</span> o     <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    2 |</span>       <span class="number">50</span> <span class="params">| Using where |</span></span><br><span class="line"><span class="params">|  2 |</span> SUBQUERY    <span class="params">| t     |</span> NULL       <span class="params">| ALL  |</span> NULL          <span class="params">| NULL |</span> NULL    <span class="params">| NULL |</span>    <span class="number">2</span> <span class="params">|       50 |</span> Using where <span class="params">|</span></span><br><span class="line"><span class="params">|</span>  <span class="number">3</span> <span class="params">| SUBQUERY    |</span> r     <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    2 |</span>       <span class="number">50</span> <span class="params">| Using where |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h5 id="3、以上两种同时存在"><a href="#3、以上两种同时存在" class="headerlink" title="3、以上两种同时存在"></a>3、以上两种同时存在</h5><p>将上边的 <code>SQL</code> 稍微修改一下，增加一个子查询，发现 <code>id</code>的以上两种同时存在。相同<code>id</code>划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 <code>id</code>值越大，优先级越高，越先执行。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name=<span class="string">&#x27;我是第三表2&#x27;</span>)) AND o.one_id <span class="keyword">in</span>(select one_id from one where o.one_name=<span class="string">&quot;我是第一表2&quot;</span>);</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type   |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref                |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| PRIMARY     |</span> o     <span class="params">| NULL       |</span> ALL    <span class="params">| PRIMARY       |</span> NULL    <span class="params">| NULL    |</span> NULL               <span class="params">|    2 |</span>       <span class="number">50</span> <span class="params">| Using where |</span></span><br><span class="line"><span class="params">|  1 |</span> PRIMARY     <span class="params">| one   |</span> NULL       <span class="params">| eq_ref |</span> PRIMARY       <span class="params">| PRIMARY |</span> <span class="number">4</span>       <span class="params">| xin-slave.o.one_id |</span>    <span class="number">1</span> <span class="params">|      100 |</span> Using index <span class="params">|</span></span><br><span class="line"><span class="params">|</span>  <span class="number">2</span> <span class="params">| SUBQUERY    |</span> t     <span class="params">| NULL       |</span> ALL    <span class="params">| NULL          |</span> NULL    <span class="params">| NULL    |</span> NULL               <span class="params">|    2 |</span>       <span class="number">50</span> <span class="params">| Using where |</span></span><br><span class="line"><span class="params">|  3 |</span> SUBQUERY    <span class="params">| r     |</span> NULL       <span class="params">| ALL    |</span> NULL          <span class="params">| NULL    |</span> NULL    <span class="params">| NULL               |</span>    <span class="number">2</span> <span class="params">|       50 |</span> Using where <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h4 id="3-2select-type"><a href="#3-2select-type" class="headerlink" title="3.2select_type"></a>3.2select_type</h4><p><code>select_type</code>：表示 <code>select</code> 查询的类型，主要是用于区分各种复杂的查询，例如：<code>普通查询</code>、<code>联合查询</code>、<code>子查询</code>等。</p><h5 id="1、SIMPLE"><a href="#1、SIMPLE" class="headerlink" title="1、SIMPLE"></a>1、SIMPLE</h5><p><code>SIMPLE</code>：表示最简单的 select 查询语句，也就是在查询中不包含子查询或者 <code>union</code>交并差集等操作。</p><h5 id="2、PRIMARY"><a href="#2、PRIMARY" class="headerlink" title="2、PRIMARY"></a>2、PRIMARY</h5><p><code>PRIMARY</code>：当查询语句中包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</p><h5 id="3、SUBQUERY"><a href="#3、SUBQUERY" class="headerlink" title="3、SUBQUERY"></a>3、SUBQUERY</h5><p><code>SUBQUERY</code>：当 <code>select</code> 或 <code>where</code> 列表中包含了子查询，该子查询被标记为：<code>SUBQUERY</code> 。</p><h5 id="4、DERIVED"><a href="#4、DERIVED" class="headerlink" title="4、DERIVED"></a>4、DERIVED</h5><p><code>DERIVED</code>：表示包含在<code>from</code>子句中的子查询的select，在我们的 <code>from</code> 列表中包含的子查询会被标记为<code>derived</code> 。</p><h5 id="5、UNION"><a href="#5、UNION" class="headerlink" title="5、UNION"></a>5、UNION</h5><p><code>UNION</code>：如果<code>union</code>后边又出现的<code>select</code> 语句，则会被标记为<code>union</code>；若 <code>union</code> 包含在 <code>from</code> 子句的子查询中，外层 <code>select</code> 将被标记为 <code>derived</code>。</p><h5 id="6、UNION-RESULT"><a href="#6、UNION-RESULT" class="headerlink" title="6、UNION RESULT"></a>6、UNION RESULT</h5><p><code>UNION RESULT</code>：代表从<code>union</code>的临时表中读取数据，而<code>table</code>列的<code>&lt;union1,4&gt;</code>表示用第一个和第四个<code>select</code>的结果进行<code>union</code>操作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select t.two_name, ( select one.one_id from one) o from (select two_id,two_name from two where two_name =<span class="string">&#x27;&#x27;</span>) t  union (select r.three_name,r.three_id from three r);</span><br><span class="line"></span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line"><span class="params">| id   |</span> select_type  <span class="params">| table      |</span> partitions <span class="params">| type  |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra           <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="params">|</span>    <span class="number">1</span> <span class="params">| PRIMARY      |</span> two        <span class="params">| NULL       |</span> ALL   <span class="params">| NULL          |</span> NULL    <span class="params">| NULL    |</span> NULL <span class="params">|    2 |</span>       <span class="number">50</span> <span class="params">| Using where     |</span></span><br><span class="line"><span class="params">|    2 |</span> SUBQUERY     <span class="params">| one        |</span> NULL       <span class="params">| index |</span> NULL          <span class="params">| PRIMARY |</span> <span class="number">4</span>       <span class="params">| NULL |</span>    <span class="number">2</span> <span class="params">|      100 |</span> Using index     <span class="params">|</span></span><br><span class="line"><span class="params">|</span>    <span class="number">4</span> <span class="params">| UNION        |</span> r          <span class="params">| NULL       |</span> ALL   <span class="params">| NULL          |</span> NULL    <span class="params">| NULL    |</span> NULL <span class="params">|    2 |</span>      <span class="number">100</span> <span class="params">| NULL            |</span></span><br><span class="line"><span class="params">| NULL |</span> UNION RESULT <span class="params">| &lt;union1,4&gt; |</span> NULL       <span class="params">| ALL   |</span> NULL          <span class="params">| NULL    |</span> NULL    <span class="params">| NULL |</span> NULL <span class="params">| NULL     |</span> Using temporary <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure><h4 id="3-3table"><a href="#3-3table" class="headerlink" title="3.3table"></a>3.3table</h4><p>查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表，例如上边的<code>DERIVED</code>、 <code>&lt;union1,4&gt;</code>等。</p><h4 id="3-4partitions"><a href="#3-4partitions" class="headerlink" title="3.4partitions"></a>3.4partitions</h4><p>查询时匹配到的分区信息，对于非分区表值为<code>NULL</code>，当查询的是分区表时，<code>partitions</code>显示分区表命中的分区情况。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table          |</span> partitions                      <span class="params">| type  |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> one            <span class="params">| p201801,p201802,p201803,p300012 |</span> index <span class="params">| NULL          |</span> PRIMARY <span class="params">| 9       |</span> NULL <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| Using index |</span></span><br><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h4 id="3-5type"><a href="#3-5type" class="headerlink" title="3.5type"></a>3.5type</h4><p><code>type</code>：查询使用了何种类型，它在 <code>SQL</code>优化中是一个非常重要的指标，以下性能从好到坏依次是：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code></p><h5 id="1、system"><a href="#1、system" class="headerlink" title="1、system"></a>1、system</h5><p><code>system</code>：当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。</p><h5 id="2、const"><a href="#2、const" class="headerlink" title="2、const"></a>2、const</h5><p><code>const</code>：表示查询时命中 <code>primary key</code> 主键或者 <code>unique</code> 唯一索引，或者被连接的部分是一个常量(<code>const</code>)值。这类扫描效率极高，返回数据量少，速度非常快。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where three_id=<span class="number">1</span>;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type  |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref   |</span> rows <span class="params">| filtered |</span> Extra <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> three <span class="params">| NULL       |</span> const <span class="params">| PRIMARY       |</span> PRIMARY <span class="params">| 4       |</span> const <span class="params">|    1 |</span>      <span class="number">100</span> <span class="params">| NULL  |</span></span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure><h5 id="3、eq-ref"><a href="#3、eq-ref" class="headerlink" title="3、eq_ref"></a>3、eq_ref</h5><p><code>eq_ref</code>：查询时命中主键<code>primary key</code> 或者 <code>unique key</code>索引， <code>type</code> 就是 <code>eq_ref</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select o.one_name from one o ,two t where o.one_id = t.two_id ; </span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type   |</span> possible_keys <span class="params">| key      |</span> key_len <span class="params">| ref                |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> o     <span class="params">| NULL       |</span> index  <span class="params">| PRIMARY       |</span> idx_name <span class="params">| 768     |</span> NULL               <span class="params">|    2 |</span>      <span class="number">100</span> <span class="params">| Using index |</span></span><br><span class="line"><span class="params">|  1 |</span> SIMPLE      <span class="params">| t     |</span> NULL       <span class="params">| eq_ref |</span> PRIMARY       <span class="params">| PRIMARY  |</span> <span class="number">4</span>       <span class="params">| xin-slave.o.one_id |</span>    <span class="number">1</span> <span class="params">|      100 |</span> Using index <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h5 id="4、ref"><a href="#4、ref" class="headerlink" title="4、ref"></a>4、ref</h5><p><code>ref</code>：区别于<code>eq_ref</code> ，<code>ref</code>表示使用非唯一性索引，会找到很多个符合条件的行。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select o.one_id from one o where o.one_name = <span class="string">&quot;xin&quot;</span> ; </span><br><span class="line">+--------+</span><br><span class="line"><span class="params">| one_id |</span></span><br><span class="line">+--------+</span><br><span class="line"><span class="params">|      1 |</span></span><br><span class="line"><span class="params">|      3 |</span></span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select o.one_id from one o where o.one_name = &quot;xin&quot; ; </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ref  | idx_name      | idx_name | 768     | const |    1 |      100 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h5 id="5、ref-or-null"><a href="#5、ref-or-null" class="headerlink" title="5、ref_or_null"></a>5、ref_or_null</h5><p><code>ref_or_null</code>：这种连接类型类似于 ref，区别在于 <code>MySQL</code>会额外搜索包含<code>NULL</code>值的行。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select o.one_id from one o where o.one_name = <span class="string">&quot;xin&quot;</span> OR o.one_name IS NULL; </span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type        |</span> possible_keys <span class="params">| key      |</span> key_len <span class="params">| ref   |</span> rows <span class="params">| filtered |</span> Extra                    <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> o     <span class="params">| NULL       |</span> ref_or_null <span class="params">| idx_name      |</span> idx_name <span class="params">| 768     |</span> const <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| Using where; Using index |</span></span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br></pre></td></tr></table></figure><h5 id="6、index-merge"><a href="#6、index-merge" class="headerlink" title="6、index_merge"></a>6、index_merge</h5><p><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</p><p>下边示例中同时使用到主键<code>one_id</code> 和 字段<code>one_name</code>的<code>idx_name</code> 索引 。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from one o where o.one_id &gt;<span class="number">1</span> <span class="keyword">and</span> o.one_name =<span class="string">&#x27;xin&#x27;</span>; </span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type        |</span> possible_keys    <span class="params">| key              |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra                                          <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> o     <span class="params">| NULL       |</span> index_merge <span class="params">| PRIMARY,idx_name |</span> idx_name,PRIMARY <span class="params">| 772,4   |</span> NULL <span class="params">|    1 |</span>      <span class="number">100</span> <span class="params">| Using intersect(idx_name,PRIMARY); Using where |</span></span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br></pre></td></tr></table></figure><h5 id="7、unique-subquery"><a href="#7、unique-subquery" class="headerlink" title="7、unique_subquery"></a>7、unique_subquery</h5><p><code>unique_subquery</code>：替换下面的 <code>IN</code>子查询，子查询返回不重复的集合。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">value</span> <span class="title">IN</span> (<span class="params">SELECT primary_key FROM single_table WHERE some_expr</span>)</span></span><br></pre></td></tr></table></figure><h5 id="8、index-subquery"><a href="#8、index-subquery" class="headerlink" title="8、index_subquery"></a>8、index_subquery</h5><p><code>index_subquery</code>：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">value</span> <span class="title">IN</span> (<span class="params">SELECT key_column FROM single_table WHERE some_expr</span>)</span></span><br></pre></td></tr></table></figure><h5 id="9、range"><a href="#9、range" class="headerlink" title="9、range"></a>9、range</h5><p><code>range</code>：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在<code>where</code>语句中使用 <code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code> 等条件查询 <code>type</code> 都是 <code>range</code>。</p><p>举个栗子：<code>three</code>表中<code>three_id</code>为唯一主键，<code>user_id</code>普通字段未建索引。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where three_id BETWEEN <span class="number">2</span> AND <span class="number">3</span>;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type  |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> three <span class="params">| NULL       |</span> range <span class="params">| PRIMARY       |</span> PRIMARY <span class="params">| 4       |</span> NULL <span class="params">|    1 |</span>      <span class="number">100</span> <span class="params">| Using where |</span></span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>从结果中看到只有对设置了索引的字段，做范围检索 <code>type</code> 才是 <code>range</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where user_id BETWEEN <span class="number">2</span> AND <span class="number">3</span>;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> three <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    3 |</span>    <span class="number">33.33</span> <span class="params">| Using where |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h5 id="10、index"><a href="#10、index" class="headerlink" title="10、index"></a>10、index</h5><p><code>index</code>：<code>Index</code> 与<code>ALL</code> 其实都是读全表，区别在于<code>index</code>是遍历索引树读取，而<code>ALL</code>是从硬盘中读取。</p><p>下边示例：<code>three_id</code> 为主键，不带 <code>where</code> 条件全表查询 ，<code>type</code>结果为<code>index</code> 。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT three_id from three ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type  |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> three <span class="params">| NULL       |</span> index <span class="params">| NULL          |</span> PRIMARY <span class="params">| 4       |</span> NULL <span class="params">|    1 |</span>      <span class="number">100</span> <span class="params">| Using index |</span></span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h5 id="11、ALL"><a href="#11、ALL" class="headerlink" title="11、ALL"></a>11、ALL</h5><p><code>ALL</code>：将遍历全表以找到匹配的行，性能最差。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from two ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> two   <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    2 |</span>      <span class="number">100</span> <span class="params">| NULL  |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure><h4 id="3-6possible-keys"><a href="#3-6possible-keys" class="headerlink" title="3.6possible_keys"></a>3.6possible_keys</h4><p><code>possible_keys</code>：表示在<code>MySQL</code>中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，<strong>但这个索引并不定一会是最终查询数据时所被用到的索引</strong>。具体请参考上边的例子。</p><h4 id="3-7key"><a href="#3-7key" class="headerlink" title="3.7key"></a>3.7key</h4><p><code>key</code>：区别于<code>possible_keys</code>，key是查询中实际使用到的索引，若没有使用索引，显示为<code>NULL</code>。具体请参考上边的例子。</p><blockquote><p>当 <code>type</code> 为 <code>index_merge</code> 时，可能会显示多个索引。</p></blockquote><h4 id="3-8key-len"><a href="#3-8key-len" class="headerlink" title="3.8key_len"></a>3.8key_len</h4><p><code>key_len</code>：表示查询用到的索引长度（字节数），原则上长度越短越好 。</p><ul><li>单列索引，那么需要将整个索引长度算进去；</li><li>多列索引，不是所有列都能用到，需要计算查询中实际用到的列。</li></ul><blockquote><p>注意：<code>key_len</code>只计算<code>where</code>条件中用到的索引长度，而排序和分组即便是用到了索引，也不会计算到<code>key_len</code>中。</p></blockquote><h4 id="3-9ref"><a href="#3-9ref" class="headerlink" title="3.9ref"></a>3.9ref</h4><p><code>ref</code>：常见的有：<code>const</code>，<code>func</code>，<code>null</code>，字段名。</p><ul><li>当使用常量等值查询，显示<code>const</code>，</li><li>当关联查询时，会显示相应关联表的<code>关联字段</code></li><li>如果查询条件使用了<code>表达式</code>、<code>函数</code>，或者条件列发生内部隐式转换，可能显示为<code>func</code></li><li>其他情况<code>null</code></li></ul><h4 id="3-10rows"><a href="#3-10rows" class="headerlink" title="3.10rows"></a>3.10rows</h4><p><code>rows</code>：以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。</p><p>这是评估<code>SQL</code> 性能的一个比较重要的数据，<code>mysql</code>需要扫描的行数，很直观的显示 <code>SQL</code> 性能的好坏，一般情况下 <code>rows</code> 值越小越好。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> three <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| NULL  |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure><h4 id="3-11filtered"><a href="#3-11filtered" class="headerlink" title="3.11filtered"></a>3.11filtered</h4><p><code>filtered</code> 这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。</p><p>在<code>MySQL.5.7</code>版本以前想要显示<code>filtered</code>需要使用<code>explain extended</code>命令。<code>MySQL.5.7</code>后，默认<code>explain</code>直接显示<code>partitions</code>和<code>filtered</code>的信息。</p><h4 id="3-12Extra"><a href="#3-12Extra" class="headerlink" title="3.12Extra"></a>3.12Extra</h4><p><code>Extra</code> ：不适合在其他列中显示的信息，<code>Explain</code> 中的很多额外的信息会在 <code>Extra</code> 字段显示。</p><h5 id="1、Using-index"><a href="#1、Using-index" class="headerlink" title="1、Using index"></a>1、Using index</h5><p><code>Using index</code>：我们在相应的 <code>select</code> 操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，<code>SQl</code>优化中理想的状态。</p><p>什么又是覆盖索引?</p><p>一条 <code>SQL</code>只需要通过索引就可以返回，我们所需要查询的数据（一个或几个字段），而不必通过二级索引，查到主键之后再通过主键查询整行数据（<code>select *</code> ）。</p><p><code>one_id</code>表为主键</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type  |</span> possible_keys <span class="params">| key        |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> one   <span class="params">| NULL       |</span> index <span class="params">| NULL          |</span> idx_two_id <span class="params">| 5       |</span> NULL <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| Using index |</span></span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：想要使用到覆盖索引，我们在 <code>select</code> 时只取出需要的字段，不可<code>select *</code>，而且该字段建了索引。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from one ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> one   <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| NULL  |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure><h5 id="2、Using-where"><a href="#2、Using-where" class="headerlink" title="2、Using where"></a>2、Using where</h5><p><code>Using where</code>：查询时未找到可用的索引，进而通过<code>where</code>条件过滤获取所需数据，但要注意的是并不是所有带<code>where</code>语句的查询都会显示<code>Using where</code>。</p><p>下边示例<code>create_time</code> 并未用到索引，<code>type</code> 为 <code>ALL</code>，即<code>MySQL</code>通过全表扫描后再按<code>where</code>条件筛选数据。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one where create_time =<span class="string">&#x27;2020-05-18&#x27;</span>;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> one   <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    3 |</span>    <span class="number">33.33</span> <span class="params">| Using where |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h5 id="3、Using-temporary"><a href="#3、Using-temporary" class="headerlink" title="3、Using temporary"></a>3、Using temporary</h5><p><code>Using temporary</code>：表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one where one_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) group by one_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> one   <span class="params">| NULL       |</span> range<span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    3 |</span>    <span class="number">33.33</span> <span class="params">| Using where; Using temporary; Using filesort |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h5 id="4、Using-filesort"><a href="#4、Using-filesort" class="headerlink" title="4、Using filesort"></a>4、Using filesort</h5><p><code>Using filesort</code>：表示无法利用索引完成的排序操作，也就是<code>ORDER BY</code>的字段没有索引，通常这样的SQL都是需要优化的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY create_time;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra          <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> one   <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| Using filesort |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure><p>如果<code>ORDER BY</code>字段有索引就会用到覆盖索引，相比执行速度快很多。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY one_id;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type  |</span> possible_keys <span class="params">| key     |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra       <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> one   <span class="params">| NULL       |</span> index <span class="params">| NULL          |</span> PRIMARY <span class="params">| 4       |</span> NULL <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| Using index |</span></span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br></pre></td></tr></table></figure><h5 id="5、Using-join-buffer"><a href="#5、Using-join-buffer" class="headerlink" title="5、Using join buffer"></a>5、Using join buffer</h5><p><code>Using join buffer</code>：在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。</p><p>先看一下有索引的情况：连接条件 <code>one_name</code> 、<code>two_name</code> 都用到索引。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type  |</span> possible_keys <span class="params">| key      |</span> key_len <span class="params">| ref                  |</span> rows <span class="params">| filtered |</span> Extra                    <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> o     <span class="params">| NULL       |</span> index <span class="params">| idx_name      |</span> idx_name <span class="params">| 768     |</span> NULL                 <span class="params">|    3 |</span>      <span class="number">100</span> <span class="params">| Using where; Using index |</span></span><br><span class="line"><span class="params">|  1 |</span> SIMPLE      <span class="params">| t     |</span> NULL       <span class="params">| ref   |</span> idx_name      <span class="params">| idx_name |</span> <span class="number">768</span>     <span class="params">| xin-slave.o.one_name |</span>    <span class="number">1</span> <span class="params">|      100 |</span> Using index              <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>接下来删掉 连接条件 <code>one_name</code> 、<code>two_name</code> 的字段索引。发现<code>Extra</code> 列变成 <code>Using join buffer</code>，<code>type</code>均为全表扫描，这也是<code>SQL</code>优化中需要注意的地方。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra                                              <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> t     <span class="params">| NULL       |</span> ALL  <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">|    2 |</span>      <span class="number">100</span> <span class="params">| NULL                                               |</span></span><br><span class="line"><span class="params">|  1 |</span> SIMPLE      <span class="params">| o     |</span> NULL       <span class="params">| ALL  |</span> NULL          <span class="params">| NULL |</span> NULL    <span class="params">| NULL |</span>    <span class="number">3</span> <span class="params">|    33.33 |</span> Using where; Using join buffer (Block Nested Loop) <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h5 id="6、Impossible-where"><a href="#6、Impossible-where" class="headerlink" title="6、Impossible where"></a>6、Impossible where</h5><p><code>Impossible where</code>：表示在我们用不太正确的<code>where</code>语句，导致没有符合条件的行。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one WHERE <span class="number">1</span>=<span class="number">2</span>;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra            <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> NULL  <span class="params">| NULL       |</span> NULL <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">| NULL |</span> NULL     <span class="params">| Impossible WHERE |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br></pre></td></tr></table></figure><h5 id="7、No-tables-used"><a href="#7、No-tables-used" class="headerlink" title="7、No tables used"></a>7、No tables used</h5><p><code>No tables used</code>：我们的查询语句中没有<code>FROM</code>子句，或者有 <code>FROM DUAL</code>子句。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select now();</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line"><span class="params">| id |</span> select_type <span class="params">| table |</span> partitions <span class="params">| type |</span> possible_keys <span class="params">| key  |</span> key_len <span class="params">| ref  |</span> rows <span class="params">| filtered |</span> Extra          <span class="params">|</span></span><br><span class="line"><span class="params">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="params">|</span>  <span class="number">1</span> <span class="params">| SIMPLE      |</span> NULL  <span class="params">| NULL       |</span> NULL <span class="params">| NULL          |</span> NULL <span class="params">| NULL    |</span> NULL <span class="params">| NULL |</span> NULL     <span class="params">| No tables used |</span></span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure><p><code>Extra</code>列的信息非常非常多，这里就不再一一列举了，详见 <code>MySQL</code>官方文档 ：[<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
